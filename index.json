[{"categories":["源码剖析"],"content":" 纸上得来终觉浅，绝知此事要躬行。——陆游《冬夜读书示子聿》 csv2是一个轻量级 C++ 库，用于将 CSV 文件解析为 C++ 中的 STL 容器。该库的主要功能是高效地处理 CSV 数据，简化了处理 CSV 文件的代码编写过程。以下是它的主要特性： 简单易用：通过使用 STL 容器（如 std::vector 和 std::tuple），使得开发者能够轻松将 CSV 文件的内容转换为标准 C++ 数据结构。 依赖少：该库只有 C++17 标准库的依赖，因此不需要额外的第三方库。 高效解析：该库采用高效的解析机制，支持处理大型 CSV 文件。 轻量级：代码库很小，适用于嵌入式或对依赖库要求较高的项目。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:0:0","tags":["CSV","C++"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r准备项目源代码地址为p-ranav/csv2 v1.0。 阅读工具为 CLion。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:1:0","tags":["CSV","C++"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r剖析整个项目包含 4 个文件，分别是: reader.hpp、mio.hpp、writer.hpp和parameters.hpp。 .c vs .cc vs. .cpp vs .hpp vs .h vs .cxx: 由于历史渊源，造成头文件和源代码文件有些不同的命名方式，但本质而言没有什么区别。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:2:0","tags":["CSV","C++"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\rreader.hppreader.hpp 文件中主要定义了一个名为Reader的类。数据部分主要有: 紧接着定义了两个方法: mmap和parse，分别从文件和字符串内容解析内容。 从文件中解析内容: #include \"csv2/reader.hpp\" #include \u003cstring\u003e using namespace std; int main(){ csv2::Reader\u003ccsv2::delimiter\u003c','\u003e, csv2::quote_character\u003c'\"'\u003e, csv2::first_row_is_header\u003ctrue\u003e, csv2::trim_policy::trim_whitespace\u003e csv; std::string content = \"Name, Age\\nPeter, 12\\nLucy, 78\"; if(csv.parse(content)){ const auto header = csv.header(); for (const auto row: csv) { for (const auto cell: row) { // Do something with cell value std::string value; cell.read_value(value); cout \u003c\u003c value \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; } } } 从字符串中解析内容: #include \"csv2/reader.hpp\" #include \u003cstring\u003e using namespace std; int main(){ csv2::Reader\u003ccsv2::delimiter\u003c','\u003e, csv2::quote_character\u003c'\"'\u003e, csv2::first_row_is_header\u003ctrue\u003e, csv2::trim_policy::trim_whitespace\u003e csv; if(csv.mmap(\"demo.csv\")){ const auto header = csv.header(); for (const auto row: csv) { for (const auto cell: row) { // Do something with cell value std::string value; cell.read_value(value); cout \u003c\u003c value \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; } } } parse方法中使用了知识点 10。 reader.hpp 中还定义了Cell、Row、RowIterator等类。 为了方便在之后的类中使用 RowIterator、Row 和 CellIterator，文件中加了 forward-declaration，如上图所示。 CellCell 类的数据部分定义如下: 其中的buffer_指向 memory-mapped buffer，可参考知识点 4，我们可以简单的将其理解为指向数据内容的一个指针。 主要包括两个方法: read_raw_value和read_value，两个方法稍有区别，前者处理无转义字符，后者处理有转义字符。 RowRow 类的数据部分定义如下: 和 Cell 类的定义大同小异。Row 类中还定义了另一个类 CellIterator: class CellIterator { friend class Row; const char *buffer_; size_t buffer_size_; size_t start_; size_t current_; size_t end_; public: CellIterator(const char *buffer, size_t buffer_size, size_t start, size_t end) : buffer_(buffer), buffer_size_(buffer_size), start_(start), current_(start_), end_(end) { } CellIterator \u0026operator++() { current_ += 1; return *this; } Cell operator*() { bool escaped{false}; class Cell cell; cell.buffer_ = buffer_; cell.start_ = current_; cell.end_ = end_; size_t last_quote_location = 0; bool quote_opened = false; for (auto i = current_; i \u003c end_; i++) { current_ = i; if (buffer_[i] == delimiter::value \u0026\u0026 !quote_opened) { // actual delimiter // end of cell cell.end_ = current_; cell.escaped_ = escaped; return cell; } else { if (buffer_[i] == quote_character::value) { if (!quote_opened) { // first quote for this cell quote_opened = true; last_quote_location = i; } else { escaped = (last_quote_location == i - 1); last_quote_location += (i - last_quote_location) * size_t(!escaped); quote_opened = escaped || (buffer_[i + 1] != delimiter::value); } } } } cell.end_ = current_ + 1; return cell; } bool operator!=(const CellIterator \u0026rhs) { return current_ != rhs.current_; } }; CellIterator 中定义了自增操作符、取值操作符和不等操作符。Iterator 必须实现这三个操作符: #include \u003ciostream\u003e using namespace std; // forward-declaration to allow use in Iter class IntVector; class Iter { public: Iter (const IntVector* p_vec, int pos) : _pos( pos ) , _p_vec( p_vec ) { } // these three methods form the basis of an iterator for use with // a range-based for loop bool operator!= (const Iter\u0026 other) const { return _pos != other._pos; } // this method must be defined after the definition of IntVector // since it needs to use it int operator* () const; const Iter\u0026 operator++ () { ++_pos; // although not strictly necessary for a range-based for loop // following the normal convention of returning a value from // operator++ is a good idea. return *this; } private: int _pos; const IntVector *_p_vec; }; class IntVector { public: IntVector () { } int get (int col) const { return _data[ col ]; } Iter begin () const { return Iter( this, 0 ); } Iter end () const { return Iter( this, 100 ); } void set (int index, int val) { _data[ index ] = val; } private: int _data[ 100 ]; }; int Iter::operator* () const { return _p_vec-\u003eget( _pos ); } // sample usage of the range-based for loop on IntVector int main() { IntVector v; for ( int i = 0; i \u003c 100; i++ ) { v.set( i , i ); } for ( int i : v ) { cout \u003c\u003c i \u003c\u003c endl; } } C++ 11 range-based for loops: https://www.cprogramming.com/","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:2:1","tags":["CSV","C++"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\rmio.hppmio.hpp 相比与其他三个文件的代码多了不少，也复杂了许多。文件一开始定义了template \u003caccess_mode AccessMode, typename ByteT\u003e struct basic_mmap结构体，然后围绕这个结构体声明了一系列操作符: 其定义在行号 1058 处: 之后定义了 5 个工厂方法，方便构建mmap、mmap_source以及mmap_sink对象: 然后在 587 处开始定义了字符串相关的工具函数: 在 684 处开始定义了与 Windows 平台相关的open_file_helper函数。 然后定义了template \u003ctypename String\u003e file_handle_type open_file，inline size_t query_file_size和inline mmap_context memory_map函数，以及struct mmap_context结构体。之后，实现了许多在template \u003caccess_mode AccessMode, typename ByteT\u003e struct basic_mmap声明的方法。 最后定义了template \u003caccess_mode AccessMode, typename ByteT\u003e class basic_shared_mmap类。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:2:2","tags":["CSV","C++"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\rwriter.hppwriter.hpp 中包含将数据导出的功能。主要定义了两个方法:write_row和write_rows，代表写入一行和写入多行。 例如，将数据写入到文件中: #include \u003ccsv2/reader.hpp\u003e #include \u003ccsv2/parameters.hpp\u003e #include \u003ccsv2/mio.hpp\u003e #include \u003ccsv2/writer.hpp\u003e #include \u003ciostream\u003e #include \u003costream\u003e #include \u003cvector\u003e #include \u003cstring\u003e using namespace csv2; using namespace std; int main() { std::ofstream out(\"info.csv\"); csv2::Writer\u003ccsv2::delimiter\u003c','\u003e, std::ofstream\u003e writer(out); std::vector\u003cstd::string\u003e header = { \"Name\", \"Age\" }; writer.write_row(header); writer.write_rows(content); } ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:2:3","tags":["CSV","C++"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\rparameters.hpp首先，为了组织代码引入了trim_policy命名空间。 包含了no_trimming、trim_characters两个结构体，以及using trim_whitespace = trim_characters\u003c' ', '\\t'\u003e;一句，于是给空白符' '和'\\t'新的使用方式——trim_whitespace。需要注意的是，该标识符在trim_policy命名空间中。 此外，还包含delimiter、quote_character以及first_row_is_header三个结构体，和之前不同的是它们在csv2命令空间中。 整个文件的结构体里面的方法或数据都是static的，表示我们可以用delimiter\u003c':'\u003e::value的方式直接获取里面的数据，而不用实例化（实例化从逻辑上好像也有一些问题，同样是用:作为分隔符却实例化了两个不同的对象，有点奇怪）。 关于可变参数模板可看知识点 5。 pair 的使用: https://cplusplus.com/reference/utility/pair/pair/ ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:2:4","tags":["CSV","C++"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r知识点","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:0","tags":["CSV","C++"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r1. CMake 项目添加第三方库在 CMakeLists.txt 中添加如下语句: 即可将三方库的头文件包含进来。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:1","tags":["CSV","C++"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r2. Static Const 使用mio.hpp 中有如下一段代码: /** * Determines the operating system's page allocation granularity. * * On the first call to this function, it invokes the operating system specific syscall * to determine the page size, caches the value, and returns it. Any subsequent call to * this function serves the cached value, so no further syscalls are made. */ inline size_t page_size() { static const size_t page_size = [] { #ifdef _WIN32 SYSTEM_INFO SystemInfo; GetSystemInfo(\u0026SystemInfo); return SystemInfo.dwAllocationGranularity; #else return sysconf(_SC_PAGE_SIZE); #endif }(); return page_size; } page_size()内部的匿名函数只会运行一次，得益于static const声明，这样可以避免重复调用sysconf()函数（如注释所述）。 https://www.tutorialspoint.com/static-const-vs-hashdefine-vs-enum ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:2","tags":["CSV","C++"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r3. static_assertmio.hpp 中有static_assert的写法。 static_assert declaration: https://en.cppreference.com/w/cpp/language/static_assert Understanding static_assert in C++ 11: https://www.geeksforgeeks.org/understanding-static_assert-c-11/ ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:3","tags":["CSV","C++"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r4. mmapmio.hpp 中的memory_map函数使用了mmap。 Use the mmap Function to Write to the Memory in C Shared Memory: https://kuafu1994.github.io/MoreOnMemory/sharedMemory.html mapread.c 和 mapwrite.c: https://gist.github.com/marcetcheverry/991042 Memory Mapped I/O: https://www.cs.uleth.ca/~holzmann/C/system/mmap.html 存储映射 I/O存储映射 I/O（Memory-Mapped I/O）能将一个磁盘文件映射到存储空间的一个缓冲区上，当从缓冲区中取数据时，就相当于读文件中的相应字节。与此类似，将数据存入缓冲区时，相应字节就自动写入文件。如此一来，就可以在不调用 read 和 write 的情况下执行 I/O。——《UNIX 环境高级编程》14.8 节 探索内存原理的内存映射文件: https://zhuanlan.zhihu.com/p/429987335 File Mapping in C++ Applications: https://www.geeksforgeeks.org/file-mapping-in-cpp-applications/ File Mapping: https://learn.microsoft.com/en-us/windows/win32/memory/file-mapping Mapping files into virtual memory in C on windows: https://stackoverflow.com/questions/68368291/mapping-files-into-virtual-memory-in-c-on-windows 示例代码: #include \u003ccstdio\u003e #include \u003cwindows.h\u003e #include \u003ciostream\u003e using namespace std; int main(int argc, char* argv[]) { const TCHAR* lpFileName = TEXT(\"hello.txt\"); HANDLE hFile; HANDLE hMap; LPVOID lpBasePtr; LARGE_INTEGER liFileSize; hFile = CreateFile(lpFileName, GENERIC_READ, // dwDesiredAccess 0, // dwShareMode NULL, // lpSecurityAttributes OPEN_EXISTING, // dwCreationDisposition FILE_ATTRIBUTE_NORMAL, // dwFlagsAndAttributes 0); // hTemplateFile if (hFile == INVALID_HANDLE_VALUE) { fprintf(stderr, \"CreateFile failed with error %d\\n\", GetLastError()); return 1; } if (!GetFileSizeEx(hFile, \u0026liFileSize)) { fprintf(stderr, \"GetFileSize failed with error %d\\n\", GetLastError()); CloseHandle(hFile); return 1; } if (liFileSize.QuadPart == 0) { fprintf(stderr, \"File is empty\\n\"); CloseHandle(hFile); return 1; } hMap = CreateFileMapping( hFile, NULL, // Mapping attributes PAGE_READONLY, // Protection flags 0, // MaximumSizeHigh 0, // MaximumSizeLow NULL); // Name if (hMap == 0) { fprintf(stderr, \"CreateFileMapping failed with error %d\\n\", GetLastError()); CloseHandle(hFile); return 1; } lpBasePtr = MapViewOfFile( hMap, FILE_MAP_READ, // dwDesiredAccess 0, // dwFileOffsetHigh 0, // dwFileOffsetLow 0); // dwNumberOfBytesToMap if (lpBasePtr == NULL) { fprintf(stderr, \"MapViewOfFile failed with error %d\\n\", GetLastError()); CloseHandle(hMap); CloseHandle(hFile); return 1; } // Display file content as ASCII charaters char* ptr = (char*)lpBasePtr; LONGLONG i = liFileSize.QuadPart; while (i-- \u003e 0) { fputc(*ptr++, stdout); } UnmapViewOfFile(lpBasePtr); CloseHandle(hMap); CloseHandle(hFile); printf(\"\\nDone\\n\"); } ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:4","tags":["CSV","C++"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r5. 可变参数模板在 parameters.hpp 中使用了可变参数模板（Variadic Template Function）。 C++11 – Variadic Template Function | Tutorial \u0026 Examples template\u003ctypename T\u003e void logging(T t){ cout \u003c\u003c t; cout \u003c\u003c \"\\nLast Call\\n\"; } template\u003ctypename T, typename ... Args\u003e void logging(T first, Args... args){ cout \u003c\u003c first \u003c\u003c \", \"; logging(args...); } ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:5","tags":["CSV","C++"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r6. #pragma onceWhat does #pragma once mean in C? 截至到 2023 年为止，主流的编译器都支持#pragma once。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:6","tags":["CSV","C++"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r7. __has_include()根据Source file inclusion的描述，__has_include()可以用来检测某个头文件是否存在，但此时并没有将其引入。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:7","tags":["CSV","C++"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r8. defined(identifier)reader.hpp 中有#if defined(identifier)一句。 #if, #elif, #else, and #endif directives ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:8","tags":["CSV","C++"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r9. 模板默认参数reader.hpp 有默认模板参数的写法: 在 C++ 17 之前，如果不用任何模板参数且正常使用 Reader 类的话，需要使用如下语法: Reader\u003c\u003e reader; 将 CMakeLists.txt 中的 C++版本由 14 set(CMAKE_CXX_STANDARD 14) 改为 17 set(CMAKE_CXX_STANDARD 17) 即可用如下轻便的语法使用 Reader。 Reader reader; ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:9","tags":["CSV","C++"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r10. std::forwardhttps://cplusplus.com/reference/utility/forward/ 通过使用std::forward函数可以根据实参调用不同的函数，如下面例子所示: #include \u003cutility\u003e // std::forward #include \u003ciostream\u003e // std::cout // function with lvalue and rvalue reference overloads: void overloaded (const int\u0026 x) {std::cout \u003c\u003c \"[lvalue]\";} void overloaded (int\u0026\u0026 x) {std::cout \u003c\u003c \"[rvalue]\";} // function template taking rvalue reference to deduced type: template \u003cclass T\u003e void fn (T\u0026\u0026 x) { overloaded (x); // always an lvalue overloaded (std::forward\u003cT\u003e(x)); // rvalue if argument is rvalue } int main () { int a; std::cout \u003c\u003c \"calling fn with lvalue: \"; fn (a); std::cout \u003c\u003c '\\n'; std::cout \u003c\u003c \"calling fn with rvalue: \"; fn (0); std::cout \u003c\u003c '\\n'; return 0; } ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:10","tags":["CSV","C++"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r11. std::stringhttps://cplusplus.com/reference/string/string/ string::erase 可用于清除指定位置的字符。 string::reserve 可用于指定 string 存储空间的大小。 string::push_back 可将字符存入 string 中。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:11","tags":["CSV","C++"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r最后项目中涉及到的存储映射 I/O ，若要想彻底弄清楚机制，可能需要补充一些操作系统方面的知识。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:4:0","tags":["CSV","C++"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["搜索"],"content":"搜索引擎是我们日常学习工作最常使用的服务之一。你可能每天都在用它，但是却仍旧不知道“搜索”。高效地使用搜索引擎可以事半功倍，下面就盘点一下那些年我们可能错过的实用 Google 搜索技巧吧！ ","date":"2024-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:0:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r使用加号(或空格)表示与不需要使用“+”来表示逻辑与，只要空格就可以了。什么意思呢？简单地说就是，当我们在搜索框输入A B搜索时，就是告诉 Google，我们要搜索的内容与 A 并且和 B 有关。比如说，我们想要搜索与 java 和 python 有关的内容，就可以用java python进行搜索。 ","date":"2024-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:1:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r使用双引号搜索短语如果想要搜索一些短语，比如我们想要搜索与purpose of education有关的内容，而在搜索框输入purpose of education进行搜索，这显然不是很对。因为我们知道 Google 会把它理解成三个关键字的逻辑与，而不是把三个关键字整体当成一个短语。这个时候，就有必要使用双引号，告诉 Google 需要把双引号中的内容看成一个短语。 ","date":"2024-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:2:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r使用星号星号*是常用的通配符，也可以在搜索中使用，代表任意文字。具体来说，假如有一天，突然想起了朋友们之前在谈论金庸先生的一部叫什么八部的小说，小说的名字却怎么都想不起来，只依稀记得八部两个字，这个时候我们就可以使用星号*表示所有可能的文字进行搜索。 ","date":"2024-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:3:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r使用减号我们可能想要过滤掉一些不太感兴趣的信息，这个时候就可以使用-。 我们对盗梦空间这部电影不太感兴趣，于是可以使用减号（-），将其从搜索结果中排除。 ","date":"2024-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:4:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r使用波浪号把波浪号~加在某个词前面，告诉 Google：要搜索与波浪号~后面的那个词相关的近义词。比如，我们要搜索关于大学（college）测验分数（test scores）但不是 SAT 入学分数的相关内容。 college 的近义词，比如 higher education, university 也会一起搜索出来。 ","date":"2024-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:5:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r列出相似网页有一天你发现了一个非常喜欢的网站，比如 Coursera，于是乎你想知道还有没有类似的网站。我们可以使用操作符related:来解决这件事。 ","date":"2024-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:6:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r搜索数字范围可以使用..表示数字范围。具体来说， ","date":"2024-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:7:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r使用OR表示或用OR表示逻辑或。比如，搜索詹姆斯或科比，或者二者都有的网页。 ","date":"2024-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:8:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r其他指令 操作符 用途 用法 allinanchor: 限制搜索的词是网页中链接中包含的关键字（可使用多个关键词） allinanchor:keyword1 keyword2 allintext: 限制搜索的词是网页内文包含的关键词（可使用多个关键词） allintext:keyword1 keyword2 allintitle: 限制搜索的词是网页标题中包含的关键词（可使用多个关键词） allintitle:keyword1 keyword2 allinurl: 限制搜索的词是网页网址中包含的关键词（可使用多个关键词） allinurl:keyword1 keyword2 filetype: 限制所搜索的文件一个特定的格式 filetype:extension inanchor: 限制搜索的词是网页中链接中包含的关键词 inanchor:keyword intext: 限制搜索的词是网页内文中包含的关键词 intext:keyword intitle: 限制搜索的词是网页标题中包含的关键词 intitle:keyword inurl: 限制搜索的词是网页网址中包含的关键词 inurl:keyword site: 限制所进行的搜索在指定的域名或网站中 site:domain 举个例子，假如我们要搜索在伯乐在线上的有关 Java 的文章，就可以使用site:操作符，如下所示： ","date":"2024-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:9:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r番外篇Google 还包含了许多其他实用有趣的功能。比如： ","date":"2024-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:10:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r查看天气 ","date":"2024-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:10:1","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r股票报价 ","date":"2024-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:10:2","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r单词含义 ","date":"2024-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:10:3","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r计算器 ","date":"2024-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:10:4","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r画函数图像 ","date":"2024-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:10:5","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r页面旋转 更多有趣的内容，可查看阅读下列文章。 15 fun things to type into Google 20 Really Cool Google Features You Probably Don’t Know About 8 Hidden (And Useful) Features in Google Search ","date":"2024-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:10:6","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r参考 Ten Tips for Smarter Google Searches 15 fun things to type into Google ","date":"2024-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:11:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["JavaScript"],"content":"在用 JavaScript 编程时，我们会经常用到数组对象，本文我们就来盘点一下那些好用的数组方法吧！😁 为了方便演示，我们先创建两个数组： const a = ['JavaScript', 'Php', 'Python', 'Ruby', 'C++', 'Node.js', 'Java', 'C++']; const b = [1, 3, 8, 16, 32, 48, 5]; ","date":"2024-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:0:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\revery()首先，我们想知道数组a中的所有元素长度都是大于 4 的吗？对于这个数组的而言，结果是显然的。我们可以用如下的for循环得到问题的答案， let result = true; for (let i = 0; i \u003c a.length; i++\u003e){ if (a[i].length \u003c= 4){ result = false; break } } console.log(result); 结果如下： 但用for循环的方式多少显得有些麻烦，我们可以更加简洁地得到结果，那就是使用every()方法。 a.every(word =\u003e word.length \u003e 4); 通过传入一个箭头函数，就将问题解决啦，而且代码变得简洁清晰多了 😉。 ","date":"2024-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:1:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rsome()接下来，我们想知道数组b中是否有大于 10 的元素呢？看起来这问题似乎有点傻，但…… 如果数组b中有 1 万个元素呢？ 我们同样可以使用for循环得到问题的答案： let result = false; for (let i = 0; i \u003c b.length; i++){ if (b[i] \u003e 10){ result = true; break; } } console.log(result); 我们还可以用some()方法， b.some(elem =\u003e elem \u003e 10); 如上所示，我们总是可以通过every()方法检测数组中所有元素都满足某种要求，而通过some()方法检测数组中是否有某个元素满足某种要求。 ","date":"2024-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:2:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rfilter()我们已经知道数组a中并不是所有元素的长度都是大于 4 的，那么具体是哪些元素的长度大于 4 呢？有没有什么办法可以把它们都找到呢？ 老规矩，我们依旧可以用for循环。 let words = []; for (let i = 0; i \u003c a.length; i++){ if (a[i].length \u003e 4){ words.push(a[i]); } } console.log(words); 但我们还是推荐更加简短的filter()方法， a.filter(word =\u003e word.length \u003e 4); 结果如下： ","date":"2024-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:3:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rmap()接下来，我们来做另外一件事，那就是给数组a中的每个元素后追加一个字符串“ is awesome!”，我们可以怎么做呢？——用map()方法。 a.map(word =\u003e word + \" is awesome!\"); ","date":"2024-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:4:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rforEach()如果我们想将数组a中长度大于 4 的元素每每追加一个字符串“ is awesome!”并依次打印输出怎么做？ 首先我们可以用filter()方法进行筛选，然后用map()方法进行追加，最后用forEach()方法进行迭代打印输出。 a.filter(word =\u003e word.length \u003e 4).map(word =\u003e word + \" is awesome!\").forEach(word =\u003e console.log(word)); 现在你可能发现了map()和filter()方法返回一个数组的好处了吧！😋 ","date":"2024-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:5:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rreduce()如果想将数组b进行求和运算该怎么做呢？——用reduce()方法。 reduce()方法的原型如下： array.reduce(reducer [, initialValue]) reducer为一个回调函数，以及可选初始化参数initialValue。reduce()方法会在每个数组元素上调用reducer()函数，reducer()函数返回一个累积的值，这个值在下一次调用reducer()函数时作为参数传入。 reducer()函数的原型如下： function reducer(accumulator, currentValue, currentIndex, array){} 回到给数组b进行求和的问题，代码如下： b.reduce((accu, curr) =\u003e accu + curr); ","date":"2024-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:6:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rincludes()假如我们想知道数组中是否包含某个元素怎么整？比如，数组a包含Julia吗？ 当然，我们可以用之前学到过的some()方法， a.some(word =\u003e word === 'Julia'); 但还是推荐使用includes()方法： a.includes('Julia'); 无它，简明而已！ ","date":"2024-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:7:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rfind()filter()可以帮我们找到数组b中所有大于 8 的元素，但有时候我们要的不是所有，而是第一个。此时我们可以用find()方法。 b.find(elem =\u003e elem \u003e 8); ","date":"2024-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:8:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rfindIndex()如果你对第一个元素（详见find()方法）不感兴趣，而是迫切想知道满足某条件的第一个元素的下标，那么可以用findIndex()方法。 b.findIndex(elem =\u003e elem \u003e 8); ","date":"2024-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:9:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\r总结本文介绍了 9 个能让我们代码更加简洁的数组方法，分别是every()，some()，filter()，map()，forEach()，reduce()，includes()，find()和findIndex()，希望能让给你带来一点启发。 ","date":"2024-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:10:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\r推荐最后，推荐几个网站！ JavaScript Tutorial: https://www.javascripttutorial.net/ MDN Web Docs: https://developer.mozilla.org/en-US/ 感兴趣的同学可以去瞅瞅 😍。 ","date":"2024-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:11:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\r参考https://www.w3schools.com/jsref/jsref_obj_array.asp ","date":"2024-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:12:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"\r项目json-tutorial: 从零开始的 JSON 库教程 http-parser: http request/response parser for c mongoose: Embedded Web Server xgboost: Scalable, Portable and Distributed Gradient Boosting (GBDT, GBRT or GBM) Library, for Python, R, Java, Scala, C++ and more. Runs on single machine, Hadoop, Spark, Dask, Flink and DataFlow darknet: Convolutional Neural Networks ","date":"2024-02-26","objectID":"/resource/:1:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\r2024Stanford CS107 Programming Paradigms 编程范式 清华大学 操作系统 清华大学 经济学原理 耶鲁大学 聆听音乐 Machine Learning 2022 Spring Deep Learning for Human Language Processing 2020 Spring 6.824 Schedule: Spring 2022 ","date":"2024-02-25","objectID":"/opencourse/:1:0","tags":null,"title":"公开课","uri":"/opencourse/"},{"categories":null,"content":"\r2024","date":"2024-02-25","objectID":"/book/:1:0","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r计算机JavaScript 高级程序设计 第 4 版 Unix\u0026Linux 大学教程 学习 JavaScript 数据结构与算法 第 3 版 Hands-on Machine Learning with Scikit-Learn, Keras \u0026 TensorFlow 2nd Edition 编写可读代码的艺术 ","date":"2024-02-25","objectID":"/book/:1:1","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r文学红楼梦 金瓶梅 ","date":"2024-02-25","objectID":"/book/:1:2","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r传记王安石传 毛泽东传 ","date":"2024-02-25","objectID":"/book/:1:3","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r经济经济学原理 ","date":"2024-02-25","objectID":"/book/:1:4","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r饮食一日一果 ","date":"2024-02-25","objectID":"/book/:1:5","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r写作文心 ","date":"2024-02-25","objectID":"/book/:1:6","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r哲学哲学家们都干了些什么 苏菲的世界 理想国 ","date":"2024-02-25","objectID":"/book/:1:7","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r政治政治学通识 ","date":"2024-02-25","objectID":"/book/:1:8","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r电影认识电影 ","date":"2024-02-25","objectID":"/book/:1:9","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r历史明朝那些事儿 万历十五年 ","date":"2024-02-25","objectID":"/book/:1:10","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r2024 # 标题 年份 论文 代码 状态 1 You Only Look Once: Unified, Real-Time Object Detection 2015 Link Link ❎ 2 YOLOv4: Optimal Speed and Accuracy of Object Detection 2020 Link Link ❎ 3 A Neural Algorithm of Artistic Style 2015 Link Link ❎ ","date":"2024-02-25","objectID":"/paper/:1:0","tags":null,"title":"论文","uri":"/paper/"},{"categories":null,"content":"\r简介一个热爱学习的东尼君 ","date":"2024-02-25","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":["JavaScript"],"content":"Axios是一个基于 Promise 的 HTTP 客户端，我们可以在浏览器和 Node.js 中使用它。Axios 使向 REST 端点发送异步 HTTP 请求和执行 CRUD 操作变得更加容易。它可以在纯 JavaScript 中使用，也可以在 Vue 或者 React 之类的库中使用。 先看一个在浏览器中使用 Axios 的例子，我们发送一个请求到https://api.github.com/users/USERNAME，以获取到用户的一些信息。 新建一个名为 1.html 的文件，代码如下： \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e\u003c/head\u003e \u003ctitle\u003eAxios\u003c/title\u003e \u003cbody\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"main.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e main.js 代码如下： axios.get(\"https://api.github.com/users/andyfree96\").then(response =\u003e { console.log(response.data); }).catch(error =\u003e { console.log(\"ERROR!\"); }); 启动服务器， 如果您没有安装http-server的话，请自行安装一下。 打开浏览器，就可以看到： 成功获取到用户信息。 之后的教程将在 Node.js 中使用 Axios，而不是在浏览器。 ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:0:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\r安装 Axios本文使用的 Node.js 版本是： 初始化一个 Node.js 应用， npm init -y 在命令行中输入npm i axios安装即可。 ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:1:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\rAxios 的响应对象当我们发送一个请求给服务器后，它会返回一个响应。Axios 的响应对象包含如下内容： data - 服务器返回的响应主体数据 status - 服务器返回的响应状态码 statusText - 返回的状态信息 headers - 返回的头部信息 config - 请求的配置信息 request - 请求对象 ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:2:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\rAxios 的 GET 请求我们以回调函数或者 async/await 的方式发送 Get 请求。 回调函数： const axios = require(\"axios\"); axios.get(\"https://api.github.com/users/andyfree96\").then((response) =\u003e { console.log(response.status); console.log(response.statusText); console.log(response.data); }); 结果如下： async/await： const axios = require(\"axios\"); async function makeGetRequest() { let response = await axios.get(\"https://httpbin.org/get\"); let data = response.data; console.log(data); console.log(response.request._header); } makeGetRequest(); 结果如下： ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:3:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\rAxios 的 HEAD 请求HEAD 请求是一个没有消息体的 GET 请求。 const axios = require(\"axios\"); async function makeHeadRequest() { let response = await axios.head(\"http://www.baidu.com\"); console.log(`status: ${response.status}`); console.log(`server : ${response.headers.server}`); console.log(response.headers); } makeHeadRequest(); Axios 有两个基本的 API： axios(config) axios(url, config) const axios = require(\"axios\"); async function makeRequest() { const config = { method: \"get\", }; const url = \"http://httpbin.org/get\"; let response = await axios(url, config); console.log(response.data); } makeRequest(); ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:4:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\rAxios 自定义头部 const axios = require(\"axios\"); async function makeRequest() { const config = { method: \"get\", url: \"http://www.baidu.com\", headers: { \"User-Agent\": \"5.js\" }, }; let response = await axios(config); console.log(response.request._header); } makeRequest(); 这里我们自定义了一个请求头部： const config = { method: \"get\", url: \"http://www.baidu.com\", headers: { \"User-Agent\": \"5.js\" }, }; ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:5:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\rAxios 的 POST 请求 const axios = require(\"axios\"); async function makePostRequest() { let response = await axios.post(\"https://httpbin.org/post\"); console.log(response.data); } makePostRequest(); ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:6:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\r下载图片 const axios = require(\"axios\"); const fs = require(\"fs\"); async function getImage(url) { const config = { responseType: \"stream\", }; let response = await axios.get(url, config); response.data.pipe(fs.createWriteStream(\"./image.png\")); } getImage( \"https://himg.bdimg.com/sys/portraitn/item/856f6c656f73636f74743936f939\" ); 我们在 config 对象中指明返回类型。 ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:7:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\r多个请求我们可以用 Axios 一次性创建多个请求。 const axios = require(\"axios\"); async function makeRequests() { let [response1, response2] = await Promise.all([ axios.get(\"https://api.github.com/users/andyfree96\"), axios.get(\"https://api.github.com/users/google\"), ]); console.log(response1.data.created_at); console.log(response2.data.created_at); } makeRequests(); ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:8:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\rJSON ServerJSON Server 是一个很棒的工具，可以让我们轻松地伪造 REST API。 我们先安装json-server: npm i -g json-server 创建一个名为 employees.json 的文件，添加如下内容： { \"employees\": [ { \"id\": 1, \"first_name\": \"Sebastian\", \"last_name\": \"Eschweiler\", \"email\": \"sebastian@codingthesmartway.com\" }, { \"id\": 2, \"first_name\": \"Steve\", \"last_name\": \"Palmer\", \"email\": \"steve@codingthesmartway.com\" }, { \"id\": 3, \"first_name\": \"Ann\", \"last_name\": \"Smith\", \"email\": \"ann@codingthesmartway.com\" } ] } 关于 JSON Server 创建 REST API 可以看下文。 Create A REST API With JSON Server: https://medium.com/codingthesmartway-com-blog/create-a-rest-api-with-json-server-36da8680136d 接下来我们可以启动 JSON Server， json-server --watch employees.json 访问http://localhost:3000/employees可以看到： 接下来我们可以使用 Axios 添加员工， const axios = require(\"axios\"); async function makePostRequest() { const params = { id: 4, first_name: \"Andy\", last_name: \"Scott\", email: \"andyfree96@126.com\", }; let response = await axios.post(\"http://localhost:3000/employees/\", params); console.log(response.data); } makePostRequest(); 获取员工, const axios = require(\"axios\"); async function makeRequest() { let response = await axios.get(\"http://localhost:3000/employees\"); console.log(response.data); } makeRequest(); 删除员工, const axios = require(\"axios\"); async function makeDeleteRequest() { let response = axios.delete(\"http://localhost:3000/employees/4/\"); console.log(response.data); } makeDeleteRequest(); ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:9:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\r参考Axios tutorial: http://zetcode.com/javascript/axios/ ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:10:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"}]