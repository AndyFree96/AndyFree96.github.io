[{"categories":["源码剖析"],"content":"在阅读 Vite 源码的过程中，我注意到一个有趣的依赖 —— launch-editor。起初只是随手点开，结果却发现它正是支撑起「浏览器报错信息 → 一键跳转到编辑器」这一开发体验的核心工具。其实，我们在使用 Vite、Vue CLI 等工具的时候，不止一次用过这个功能：报错时点击链接，代码编辑器立刻打开到对应的文件和行号。背后的关键实现，正是 launch-editor。 注意\rVite 提交号为: 3676da5bc5b2b69b28619b8521fca94d30468fe5。launch-editor-middleware版本为2.10.0，launch-editor版本为2.10.0。\rvite项目的vite/packages/vite/src/node/server/index.ts文件中有这么一句： // open in editor support middlewares.use('/__open-in-editor', launchEditorMiddleware()); 也就是使用了launch-editor-middleware中间件，它会监听/__open-in-editor路径，并将请求转发给launch-editor模块。启动了 vite 应用后，我们在浏览器中如下访问： http://locahost:5173/__open-in-editor?file=package.json:9 launch-editor-middleware模块的源码位于vite/packages/vite/node_modules/launch-editor-middleware/index.js，它主要做了两件事： 解析请求参数，获取报错文件路径和行号 调用launch-editor模块，打开编辑器并跳转到相应的文件和行号 ","date":"2025-09-11","objectID":"/launch-editor%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:0:0","tags":["Node.js","launch-editor"],"title":"launch-editor源码剖析：快速打卡编辑器的实现原理","uri":"/launch-editor%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["JavaScript"],"content":"在前端开发的进化历程中，模块化 一直是一个核心问题。早期我们用全局变量、命名空间、立即执行函数（IIFE）来组织代码，但都存在依赖管理复杂、命名冲突等问题。 直到 ES6（ECMAScript 2015） 正式引入了 模块化语法，才为 JavaScript 带来了原生的模块方案。 为什么要使用模块？\r避免全局污染：每个模块都有自己的作用域。 方便维护：模块化让代码按功能拆分，结构更清晰。 可复用性：一次定义，多处引入。 按需加载：结合现代打包工具，可实现 Tree Shaking，减小体积。 基本语法\r1. 导出（export）\r在一个文件中，可以导出函数、变量、类等。 export const PI = 3.14159; export function add(x, y) { return x + y; } export class Calculator { multiply(a, b) { return a * b; } } 2. 导入（import）\r在另一个文件中引用： import { PI, add, Calculator } from './math.js'; console.log(PI); // 3.14159 console.log(add(2, 3)); // 5 console.log(new Calculator().multiply(2, 4)); // 8 默认导出（default export）\r每个模块可以有一个默认导出，常用于导出“模块的主要功能”。 export default function log(message) { console.log(`[Log]: ${message}`); } 导入时可自定义名称： import log from './logger.js'; log('Hello ES6 Modules!'); 导出与导入的别名（alias）\r使用as关键字可以给导入或导出改名： export { add as sum, PI as piValue }; import { sum, piValue } from './math.js'; 模块聚合（Re-export）\r当有多个模块时，可以通过 “中转站” 来统一导出。 export _ from './math.js'; export _ from './logger.js'; 这样使用者只需要： import { add, PI, default as log } from './index.js'; 动态导入（import()）\rES2020 引入了 动态导入，返回一个 Promise，适合按需加载。 async function loadModule() { const { add } = await import('./math.js'); console.log(add(10, 20)); } loadModule(); 与 CommonJS 的区别\r特点 ES6 模块 CommonJS 语法 import / export require / module.exports 加载方式 静态（编译时解析） 动态（运行时加载） 是否异步 支持异步加载 同步加载 适用场景 浏览器、Node.js(ESM) Node.js 传统环境 提示\r提示：在 Node.js 中使用 ES6 模块，需要在 package.json 中设置\"type\": \"module\"。\r最佳实践\r一个文件一个模块，职责单一。 默认导出用于主要功能，命名导出用于辅助功能。 避免循环依赖，拆分公共逻辑。 在生产项目中，配合 Webpack / Rollup / Vite 等打包工具使用，享受 Tree Shaking。 总结\rES6 模块化给 JavaScript 带来了真正的“官方标准”，彻底摆脱了依赖混乱的问题。掌握 export、import、default、动态导入 等语法后，你的前端项目将更清晰、更高效。 ","date":"2025-08-31","objectID":"/es6%E6%A8%A1%E5%9D%97%E6%95%99%E7%A8%8B/:0:0","tags":["ES6","模块化","前端"],"title":"ES6模块教程","uri":"/es6%E6%A8%A1%E5%9D%97%E6%95%99%E7%A8%8B/"},{"categories":["LeetCode"],"content":"Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. Return k after placing the final result in the first k slots of nums. Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory. Custom Judge: The judge will test your solution with the following code: int[] nums = […]; // Input array int[] expectedNums = […]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i \u003c k; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted. Example 1: Input: nums = [1,1,1,2,2,3] Output: 5, nums = [1,1,2,2,3,_] Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2: Input: nums = [0,0,1,1,1,1,2,3,3] Output: 7, nums = [0,0,1,1,2,3,3,,] Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.It does not matter what you leave beyond the returned k (hence they are underscores). 原题链接: https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/ 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回删除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成删除操作。 示例 1\r// 给定nums=[1,1,1,2,2,3] // 函数应该返回新长度length=5, 并且原数组的前五个元素被修改为1,1,2,2,3 // 你不需要考虑数组中超出新长度后面的元素 示例 2\r// 给定nums=[0,0,1,1,1,1,2,3,3] // 函数应该返回新长度length=7, 并且原数组的前五个元素被修改为0,0,1,1,2,3,3 // 你不需要考虑数组中超出新长度后面的元素 这个问题怎么解决呢？ 我们需要注意到的是：给定的数组是已经排好序的。可以确定的是需要一个变量i用于遍历数组，意思就是就算是比计算机聪明许多的人来处理这个问题，我们也要至少从左往右看一遍数组。还需要一个变量j用于存储删除重复出现元素后的数组长度(准确的说应该是长度减 1)。 初始情况下，i的值为2，j的值为1 因为如果数组长度小于 3 的话，直接返回数组长度即可。 将重复元素按要求删除后，结果应该如下所示 我们通过上图其实可以观察到，下标\u003c=j的元素就是最终数组中该有的元素，而下标\u003ci并且\u003ej的元素就是那些重复的元素。下一步的操作就是A[++j]=A[i]，然后i=i+1(以保持下标\u003c=j的元素就是最终数组中该有的元素，而下标\u003ci并且\u003ej的元素就是那些重复的元素这个性质)。 什么时候会有A[++j]=A[i]这个操作呢？答案是A[j-1]!=A[i]时。由于我们的数组是有序的，对于合法的下标j-1,j,i，元素之间的关系应该是A[j-1]\u003c=A[j]\u003c=A[i]。如果A[j-1]==A[i]那么就意味着A[j-1]==A[j]==A[i]，此时只需要i=i+1。如果A[j-1]!=A[i]，这三个元素之间的情况可能有如下三种情况： 第一种 若出现上图所示的情况，我们可以推断出中间省略号部分其实省略的是a值(参考之前提到的性质)，下一步的操作自然是A[++j]=A[i]。 第二种 如果出现上图所示的情况，我们可以推断出省略号部分因应该是没有值的，也就是说j+1==i，此时A[++j]=A[i]，也是没有问题的。 第三种 如果省略号部分省略是没有值的，那么下一步进行A[++j]=A[i]自然是没有问题的。如果省略号部分是有值的，那必定是已经移动到下标\u003c=j保存下来的值，也就是说下标\u003ej并且\u003ci的元素都是处理好被弃用的值，此时进行A[++j]=A[i]也是没有问题的。 综上所述，当A[j-1]!=A[i]时，我们可以放心地进行A[++j]=A[i]这个操作。 接下来就可以实现上述思路： class Solution { public static int removeDuplicates(int[] nums) { int j = 1; if (nums.length \u003c 3) { return nums.length; } for (int i = 2; i \u003c nums.length; i++) { if (nums[j - 1] != nums[i]) { nums[++j] = nums[i]; } } return j + 1; } } ","date":"2025-08-20","objectID":"/remove-duplicates-from-sorted-array-ii/:0:0","tags":["LeetCode","Array","数据结构","算法"],"title":"80. Remove Duplicates From Sorted Array II","uri":"/remove-duplicates-from-sorted-array-ii/"},{"categories":["Node.js"],"content":"在日常 Node.js 开发中，你有没有遇到过这样一个错误： Error: EMFILE: too many open files 该错误通常出现在：批量文件操作、递归复制、日志处理等场景中。为什么会出现该错误？其实是因为在操作系统中每个进程最多可以同时打开一定数量的文件或 Socket, 而当打开的文件或 Socket 超过了这个限制时，就会出现“打开文件过多”的错误，导致程序突然崩溃。这种“打开文件过多”的问题看 似简单，但如果不加处理，尤其是在批量文件处理场景下，会让我们的 Node.js 程序非常脆弱。 错误示例\r以下是一个简单示例： import fs from 'fs'; import path from 'path'; import { fileURLToPath } from 'url'; const __dirname = path.dirname(fileURLToPath(import.meta.url)); const filePath = path.join(__dirname, 'test.txt'); for (let i = 0; i \u003c 1000000; i++) { fs.open(filePath, 'r', (err, fd) =\u003e { if (err) { console.error(err); } else { console.log(`${i} 处理文件 ${filePath}`); fs.close(fd, (err) =\u003e { if (err) console.error(`关闭文件 ${filePath} 错误:`, err.code); }); } }); } 当我们node emfile.mjs运行这个脚本时，会出现EMFILE错误： 解决方案 1: 限制并发数\r解决该错误的方法有很多。比如，我们可以限制每个进程同时打开的文件数量，或者限制单个文件打开的数量。 import fs from 'fs'; import path from 'path'; import { fileURLToPath } from 'url'; const __dirname = path.dirname(fileURLToPath(import.meta.url)); const filePath = path.join(__dirname, 'test.txt'); const MAX_CONCURRENT = 5; const TIMES = 1000000; let running = 0; let index = 0; function processFile(filePath) { if (index \u003e= TIMES \u0026\u0026 running === 0) { console.log('所有文件处理完成'); return; } while (running \u003c MAX_CONCURRENT \u0026\u0026 index \u003c TIMES) { index++; running++; fs.open(filePath, 'r', (err, fd) =\u003e { running--; if (err) { console.error(`打开文件 ${filePath} 错误:`, err.code); } else { console.log(`${index} 处理文件 ${filePath}`); fs.close(fd, (err) =\u003e { if (err) console.error(`关闭文件 ${filePath} 错误:`, err.code); }); } processFile(filePath); }); } } processFile(filePath); 解决方案 2: fs-extra\r我们也可以选择三方库node-fs-extra解决这个问题。 import path from 'path'; import { fileURLToPath } from 'url'; import fs from 'fs-extra'; const __dirname = path.dirname(fileURLToPath(import.meta.url)); const filePath = path.join(__dirname, 'test.txt'); async function processFile(filePath) { for (let i = 0; i \u003c 1000000; i++) { try { const fd = await fs.open(filePath, 'r'); console.log(`${i} 处理文件 ${filePath}`); await fs.close(fd); } catch (err) { console.error(`文件 ${filePath} 错误:`, err.code); } } console.log('所有文件处理完成'); } processFile(filePath); 解决方案 3: fs-extra + p-limit\r使用await fs.open和await fs.close 保证每个文件处理完就释放资源。上面的for循环是串行执行，天然避免一次性打开太多文件。如果想要提高效率，也可以用p-limit限制并发数，结合fs-extra更安全、高效。 import fs from 'fs-extra'; import path from 'path'; import { fileURLToPath } from 'url'; import pLimit from 'p-limit'; const __dirname = path.dirname(fileURLToPath(import.meta.url)); const filePath = path.join(__dirname, 'test.txt'); const TIMES = 1000000; const MAX_CONCURRENT = 5; const limit = pLimit(MAX_CONCURRENT); async function processFile(filePath, index = 1) { try { const fd = await fs.open(filePath, 'r'); console.log(`${index} 处理文件 ${filePath}`); await fs.close(fd); } catch (err) { console.error(`文件 ${filePath} 错误:`, err.code); } } async function processFiles(filePath) { const tasks = Array.from({ length: TIMES }, (_, index) =\u003e limit(() =\u003e processFile(filePath, index)) ); await Promise.all(tasks); console.log('所有文件处理完成'); } processFiles(filePath); 总结\rNode.js 开发中，打开文件过多的问题是常见的，解决的方法也有很多。比如，限制并发数、使用三方库fs-extra等。在实际项目中，还需要根据具体场景选择合适的解决方案。 ","date":"2025-08-17","objectID":"/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-node.js-%E4%B8%AD%E7%9A%84-emfile-%E9%94%99%E8%AF%AF/:0:0","tags":null,"title":"如何解决 Node.js 中的 EMFILE 错误","uri":"/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-node.js-%E4%B8%AD%E7%9A%84-emfile-%E9%94%99%E8%AF%AF/"},{"categories":["LeetCode"],"content":"Given an integer array nums, rotate the array to the right by k steps, where k is non-negative. Example 1: Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2: Input: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] 原题链接: https://leetcode.com/problems/rotate-array/description/ 给定一个数组，将其旋转的意思是：将数组左端移出的元素补充到数组右端。我们希望编写一个函数rotate(arr,k,n)，传入数组arr，数组长度n，旋转元素个数k，就可以得到数组旋转后的结果。 假设原始数组是： 调用rotate(arr,2,7)后，就应该得到： Juggling Algorithm\r解决这个问题有很多种方法，下面要介绍的是一个名为“Juggling Algorithm”的算法。 它主要的思路分为 3 部分： 将整个数组进行分为几个小组 把小组内的每个元素向左移动 k 个位置 处理下一个小组并重复第(2)步 具体来说，假设arr=[1,2,3,4,5,6], n=6, k=2， 我们从index=0的元素开始处理（也就是 1），并把它的值存到变量temp中 接下来，我们找到要把值移动到index=0的元素，其实就是index=2的元素，因为它距离index=0正好为 2（k=2） 之后，我们把index=4的元素移动到index=2处 继续往后处理，此时我们应该处理index=4处的元素 找到与它距离为 2 的元素，也就是index=0的元素，但这个元素一开始我们就处理过了，这标志着我们已经处理完了这个小组内的元素。 此时应该把存储在temp变量中的值赋给index=4的元素。 现在，我们知道了第一个小组内的元素下标为{0,2,4}。 接下来就是要按照思路(3)中谈到的，处理下一个小组， 和处理第一个小组一样，我们可以类似处理好第二个小组 可以看到，整个处理过程包含两层循环： 外部循环用于遍历小组 内部循环用于将小组内的元素向左移动 k 个位置 那么问题来了： 小组数是怎么确定的？ 小组内的元素怎么向左移动 k 个位置？ 什么时候处理下一个小组？ 首先回答第 3 个问题 什么时候处理下一个小组? 根据上述的例子我们可以发现，当前处理小组的元素的下一个元素的下标如果等于小组的起始下标的时候，就意味着我们可以处理下一组了。 然后回答第 1 个问题 小组数是怎么确定的? 答案是GCD(n,k)，也就是n和k的最大公约数。这个结论是怎么得到的呢？根据第 3 个问题的回答，我们可以知道要处理到下一个小组(假设当前小组的起始下标为s)，经过的元素个数必然是n的倍数。拿上述的例子来说就是：当s=0 时，处理好当前小组进入下一个小组经过的元素为 6（$0 \\to 2 \\to 4 \\to 0$）。当然，也可以重复这个过程，如$0 \\to 2 \\to 4 \\to 0 \\to 2 \\to 4$。同时，我们也可以知道经过的元素个数必然是k的倍数。所以，经过的元素个数最少应该为LCM(n,k)，也就是n和k的最小公倍数。每一个小组包含的元素个数为：$\\frac{LCM(n,k)}{k}$，那么，小组数应该为： $$ \\frac{n}{\\frac{LCM(n,k)}{k}} = \\frac{n * k}{LCM(n,k)} = GCD(n,k) $$ 最后，为了回答第 2 个问题，我们看一个具体的例子，此时n=9,k=3 外部循环:i=0 to i \u003c GCD(n,k) 内部循环:A[j]=A[(j+k)%n]，通过这样的方式向左移动 k 个位置。为了方便起见，可以让d=(j+k)%n。当d等于i时，处理下一组(也就是i自增 1)。 整个过程如下表所示： 代码实现\rdef gcd(a, b): if b == 0: return a return gcd(b, a % b) def rotate(arr, k, n): for i in range(gcd(k, n)): j = i temp = arr[i] while True: d = (j + k) % n if d == i: break arr[j] = arr[d] j = d arr[j] = temp 参考\rhttps://www.youtube.com/watch?v=utE_1ppU5DY https://www.geeksforgeeks.org/array-rotation/ ","date":"2025-08-12","objectID":"/rotate-array/:0:0","tags":["LeetCode","Array","数据结构","算法"],"title":"189. Rotate Array","uri":"/rotate-array/"},{"categories":["数据科学"],"content":"在数据可视化中，气泡地图（Bubble Map）是一种直观表现地理信息的方法，既能展示地理位置，也能通过气泡的大小和颜色体现数据的数量和类别。本文将带你用 R 语言 + ggplot2 从零开始绘制一张漂亮的气泡地图。 气泡地图以一个地图轮廓为背景，用附着在地图上的气泡来反映数据的大小。气泡地图可以直观地反应国家或地区的相关数据指标大小和分布情况。 气泡地图的输入通常包含两部分： 国家或地区的坐标（经度和纬度） 表明气泡大小和颜色的数值变量 获取地图数据\r我们使用maps包加载每个国家的边界数据。 library(tidyverse) library(maps) UK \u003c- map_data(\"world\") %\u003e% filter(region==\"UK\") 加载英国每个城市的数据： data \u003c- world.cities %\u003e% filter(country.etc==\"UK\") 绘制散点地图\r加载完所需数据后，我们可以绘制散点地图。用geom_polygon绘制地图，用geom_point绘制散点。 ggplot() + geom_polygon(data = UK, aes(x = long, y = lat, group = group), fill = \"grey\", alpha=0.3) + geom_point(data = data, aes(x = long, y = lat)) + theme_void() + ylim(50, 59) + coord_map() 接下来，我们绘制人口量最大的 10 个城市： library(ggrepel) ggplot() + geom_polygon(data = UK, aes(x = long, y = lat, group = group), fill = \"grey\", alpha=0.3) + geom_point(data = data, aes(x = long, y = lat, alpha = pop)) + geom_text_repel(data = data %\u003e% arrange(pop) %\u003e% tail(10), aes(x = long, y = lat, label = name), size = 5) + geom_point(data = data %\u003e% arrange(pop) %\u003e% tail(10), aes(x = long, y = lat), color=\"red\", size=3) + theme_void() + ylim(50, 59) + coord_map() + theme(legend.position = \"none\") 这里使用ggrepel库来避免城市名重叠。 绘制气泡地图\r现在我们想让每个城市的人口数与气泡的颜色和大小对应。城市的绘制顺序很重要，建议将最重要的信息显示在顶部。这可以通过在绘制图之前对数据集进行排序解决。 library(viridis) data %\u003e% arrange(pop) %\u003e% mutate(name=factor(name,unique(name))) %\u003e% ggplot() + geom_polygon(data = UK, aes(x=long, y = lat, group = group), fill=\"grey\", alpha=0.3) + geom_point( aes(x=long, y=lat, size=pop, color=pop), alpha=0.9) + scale_size_continuous(range=c(1,12)) + scale_color_viridis(trans=\"log\") + theme_void() + ylim(50,59) + coord_map() + theme(legend.position=\"none\") 自定义气泡地图\r我们可以自定义气泡地图来得到更好的效果。 # Create breaks for the color scale mybreaks \u003c- c(0.02, 0.04, 0.08, 1, 7) # Reorder data to show biggest cities on top data \u003c- data %\u003e% arrange(pop) %\u003e% mutate( name=factor(name, unique(name))) %\u003e% mutate(pop=pop/1000000) # Build the map data %\u003e% ggplot() + geom_polygon(data = UK, aes(x=long, y = lat, group = group), fill=\"grey\", alpha=0.3) + geom_point( aes(x=long, y=lat, size=pop, color=pop, alpha=pop), shape=20, stroke=FALSE) + scale_size_continuous(name=\"Population (in M)\", trans=\"log\", range=c(1,12), breaks=mybreaks) + scale_alpha_continuous(name=\"Population (in M)\", trans=\"log\", range=c(0.1, .9), breaks=mybreaks) + scale_color_viridis(option=\"magma\", trans=\"log\", breaks=mybreaks, name=\"Population (in M)\" ) + theme_void() + ylim(50,59) + coord_map() + guides( colour = guide_legend()) + ggtitle(\"The 1000 biggest cities in the UK\") + theme( legend.position = c(0.85, 0.8), text = element_text(color = \"#22211d\"), plot.background = element_rect(fill = \"#f5f5f2\", color = NA), panel.background = element_rect(fill = \"#f5f5f2\", color = NA), legend.background = element_rect(fill = \"#f5f5f2\", color = NA), plot.title = element_text(size= 16, hjust=0.1, color = \"#4e4d47\", margin = margin(b = -0.1, t = 0.4, l = 2, unit = \"cm\")), ) 交互式气泡地图\r最后，我们用plotly包绘制交互式气泡地图。 # Load the plotly package library(plotly) # Reorder data + Add a new column with tooltip text data \u003c- data %\u003e% arrange(pop) %\u003e% mutate(name = factor(name, unique(name))) %\u003e% mutate(mytext = paste( \"City:\",name,\"\\n\",\"Population:\", pop, sep = \"\" )) # Make the map (static) p \u003c- data %\u003e% ggplot() + geom_polygon(data = UK, aes(x=long, y = lat, group = group), fill=\"grey\", alpha=0.3) + geom_point(aes(x=long, y=lat, size=pop, color=pop, text=mytext, alpha=pop) ) + scale_size_continuous(range=c(1,15)) + scale_color_viridis(option=\"inferno\", trans=\"log\" ) + scale_alpha_continuous(trans=\"log\") + theme_void() + ylim(50,59) + coord_map() + theme(legend.position = \"none\") p \u003c- ggplotly(p, tooltip=\"text\") p 小结\r本文我们用 ggplot2 成功绘制了带有气泡的世界地图。通过改变气泡的大小、颜色和透明度，可以轻松地传达地理空间分布与数量差异。气泡地图在人口统计、销售分布、地理分析等领域都非常实用。 参考\rhttps://help.aliyun.com/document_detail/55644.html https://www.r-graph-gallery.com/330-bubble-map-with-ggplot2.html ","date":"2025-08-12","objectID":"/r%E8%AF%AD%E8%A8%80ggplot2%E6%B0%94%E6%B3%A1%E5%9C%B0%E5%9B%BE%E5%AE%9E%E6%88%98/:0:0","tags":["数据科学","数据可视化","R","ggplot2"],"title":"R语言ggplot2气泡地图实战","uri":"/r%E8%AF%AD%E8%A8%80ggplot2%E6%B0%94%E6%B3%A1%E5%9C%B0%E5%9B%BE%E5%AE%9E%E6%88%98/"},{"categories":["PowerShell"],"content":"在使用 PowerShell 进行脚本开发或系统运维时，知道当前环境的 PowerShell 版本是非常有必要的。不同的版本在功能和兼容性上存在差异，有些模块或命令在旧版本中可能无法使用，甚至语法支持也会有变化。 本文将介绍多种查看 PowerShell 版本的方法，无论你是在使用 Windows PowerShell 5.1 还是跨平台的 PowerShell 7，都能轻松查到当前版本信息。 为什么要查看 PowerShell 版本\r以下几种情况你可能会用到 PowerShell 版本号: 判断是否支持某些特性（如ConvertTo-CliXml命令） 判断是否需要升级到 PowerSHell 7.x 在多平台上调试脚本时确认运行环境 排查脚本执行错误是否因版本不兼容 方法一：使用$PSVersionTable变量\r$PSVersionTable 输出如下: PSVersion字段表示当前 PowerShell 的版本号，PSEdition字段表示当前 PowerShell 的版本类型。 方法二：使用Get-Host命令\r另一种方法是使用Get-Host命令，它会返回当前 PowerShell 宿主环境的相关信息，其中包括版本号。 Get-Host Version字段表示当前 PowerShell 的版本号。 方法三：使用$HOST变量\r当打开 PowerShell 时，$HOST变量会自动赋值为当前 PowerShell 宿主环境的相关信息，其中包括版本号。 $HOST Version字段表示当前 PowerShell 的版本号。 PowerShell 各版本简述\r版本 平台 特点 Windows PowerShell 5.1 Windows 最后一个 Windows PowerShell 版本，内置于 Windows PowerShell 6.x Windows、Linux、macOS 引入 .NET Core，支持 Linux/macOS PowerShell 7.x Windows、Linux、macOS 性能更好，兼容性更强 若你还在使用 5.1，强烈建议试试 PowerShell 7，或许有不一样的体验。 常见问题\rQ1：我在 Windows 上用的是 PowerShell 还是 PowerShell Core？\r运行$PSVersionTable.PSEdition命令，如果返回的是Desktop，则说明你正在使用 Windows PowerShell 5.1；如果返回的是Core，则说明你正在使用 PowerShell Core。 Q2：是否可以同时安装 PowerShell 5.1 和 PowerShell 7？\r可以，两者互不冲突。PowerShell 7 安装后使用pwsh命令启动，PowerShell 5.1 安装后使用powershell命令启动。 Q3：如何升级 PowerShell？\r去Github PowerShell 仓库下载最新版安装包安装即可。 推荐\rDifferences between Windows PowerShell 5.1 and PowerShell 7.x Overview of what’s new in PowerShell ","date":"2025-08-06","objectID":"/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8Bpowershell%E7%9A%84%E7%89%88%E6%9C%AC/:0:0","tags":["PowerShell","版本","命令行"],"title":"如何查看PowerShell的版本","uri":"/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8Bpowershell%E7%9A%84%E7%89%88%E6%9C%AC/"},{"categories":["源码剖析"],"content":"在前端开发中，构建一套完整的后端接口往往耗时费力，而 json-server正是为了解决这一痛点而生。只需一个 JSON 文件，它就能快速生成一个 REST API 服务，被广泛用于前端开发、原型验证、接口测试等场景。本文将深入剖析 json-server的源码，一起理解它是如何工作的，并从中学习一些开发技巧。 注意\r剖析的json-server版本为v1.0.0-beta.3。\r一个简单但不完整的实现\r由于有一些 Express 的使用经验，在阅读了json-server的 README.md 介绍后，我的初始想法是将db.json文件加载然后遍历对象，将key作为路由的 Endpoint 即可，由于有了以下代码： import dbJson from './fixtures/db.json'; import express from 'express'; import { json } from 'milliparsec'; import crypto from 'crypto'; import chalk from 'chalk'; import { Eta } from 'eta'; import { fileURLToPath } from 'url'; import { dirname, join } from 'path'; const PORT = 3001; const app = new express(); const __filename = fileURLToPath(import.meta.url); const __dirname = dirname(__filename); const eta = new Eta({ views: join(__dirname, 'views'), cache: true, }); app.use(json()); const kaomojis = ['(˶ᵔ ᵕ ᵔ˶)', '(˶ˆᗜˆ˵)', '(˶˃ ᵕ ˂˶)', '( ∩´͈ ᐜ `͈∩)']; function randomEmoji() { return kaomojis[Math.floor(Math.random() * kaomojis.length)]; } const routes = []; const baseUrl = `http://localhost:${PORT}`; console.log(chalk.bold(`JSON Server started on port ${PORT}`)); console.log(chalk.magenta(randomEmoji())); for (const key in dbJson) { routes.push(`${key}`); app.get(`/${key}`, (_, res) =\u003e { res.json(dbJson[key]); }); app.get(`/${key}/:id`, (req, res) =\u003e { const { id } = req.params; let findById = []; if (Array.isArray(dbJson[key])) { findById = res.json(dbJson[key].find((item) =\u003e item.id === id)); } res.json(findById); }); app.post(`/${key}`, (req, res) =\u003e { const { body } = req; if (!body.id) { body.id = crypto.randomUUID(); } if (Array.isArray(dbJson[key])) { dbJson[key].push(body); } else { dbJson[key] = body; } res.json(body); }); app.put(`/${key}/:id`, (req, res) =\u003e { const { id } = req.params; const { body } = req; const index = dbJson[key].findIndex((item) =\u003e item.id === id); if (index !== -1) { dbJson[key][index] = body; res.json(body); } else { res.status(404).json({ error: 'Not found' }); } }); app.delete(`/${key}/:id`, (req, res) =\u003e { const { id } = req.params; const index = dbJson[key].findIndex((item) =\u003e item.id === id); if (index !== -1) { dbJson[key].splice(index, 1); res.json({ message: 'Deleted' }); } else { res.status(404).json({ error: 'Not found' }); } }); } app.get('/', (_, res) =\u003e { const renderedData = { data: dbJson, }; const renderedTemplate = eta.render('index.html', renderedData); res.send(renderedTemplate); }); console.log('\\n'); console.log(chalk.bold('Endpoints:')); console.log( routes .map((route) =\u003e `${chalk.gray(baseUrl)}/${chalk.blue(route)}`) .join('\\n') ); app.listen(PORT); npx tsx ./tiny.mjs启动程序终端输出如下： 访问上述 Endpoint 能够正常获取到数据，并支持POST、DELETE、PUT等操作，初步看起来颇有点json-server的味道。然而，实际使用中仍然存在以下几个问题： 问题 1：启动方式不便\r当前的启动方式是通过 npx tsx ./tiny.mjs，显然这并不方便作为一个 CLI 工具来使用。理想状态下，我们希望它能像 vite 那样，安装后通过一个命令（如 tiny-server）即可启动服务。 问题 2：数据无法持久化\r虽然可以对资源执行 POST、PUT、DELETE 操作，但这些变更不会被持久化保存。应用一旦重启，所有数据都会恢复为初始状态。 问题 3：热更新缺失\r修改 db.json 文件后，当前服务不会感知到变更，也无法实时更新数据内容。这意味着我们需要手动重启服务，才能看到修改结果。 幸运的是，json-server在这几个方面都有成熟的实现。那么它是如何做到的？下面我们就带着这三个问题，一步步剖析json-server的源码，看看它是如何实现这些特性的。 命令行工具化：如何实现像vite一样的 CLI 启动？\r当前是通过npx tsx ./tiny.mjs启动服务，这种方式不适合作为常规 CLI 工具发布与使用。我们希望能通过tiny-server这样一个命令来直接运行项目，像vite一样方便。 json-server是如何做到的？查看package.json文件，可以看到这段配置： \"bin\": { \"json-server\": \"lib/bin.js\" } 这段配置的意思是：当用户安装json-server时（例如npm install -g json-server）,npm 会自动在系统的PATH中注册一个名为json-server的可执行命令，并将其映射到项目目录下的lib/bin.js脚本。 然而，Clone 下来的源码中并没有lib/bin.js文件。查看package.json文件，可以看到这段配置： \"scripts\": { \"build\": \"rm -rf lib \u0026\u0026 tsc\", } 当运行npm run build时，npm 会执行对应的脚本命令： rm -rf lib \u0026\u0026 tsc rm -rf lib会删除lib目录及其所有内容（如果存在）。\u0026\u0026是一个 Bash 连接符，表示其哪一个命令成功后再执行后一个。tsc会根据tsconfig.json把src目录中的.ts文件编译成.js文件，输出到lib目录（或者在tsconfig中设置的目录）。 执行npm run build生成lib目录中包含了bin.js文件。 bin.js顶部有以下Shebang： #!/usr/bin/env node 这段代码让脚本可以在终端中直接作为命令运行，而不需要再手动用node或npx启动。bin.js由src/bin.ts编译生成（观察得到 😁）。根据前面的说明，当我们安装好json-server，执行npx json-server db.json命令时，其实就是在运行src/bin.ts文件。为了方便调试src/bin.ts文件，参考VS Code debugging进行配置，在项目根目录下.vscode下创建launch.json文件，粘贴如下内容： { // Use IntelliSense to learn abou","date":"2025-07-31","objectID":"/json-server%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:0:0","tags":["Node.js","TypeScript","RESTful API","JSON Server"],"title":"json-server源码剖析：快速构建REST API背后的原理","uri":"/json-server%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["PowerShell"],"content":"PowerShell 是一个功能强大的自动化脚本平台，不仅可以管理系统和服务，还可以轻松高效地处理各种文件操作。无论你是系统管理员、开发者，还是数据分析师，掌握 PowerShell 的文件处理能力都能让你的工作事半功倍。本文将带你系统性地了解如何用 PowerShell 玩转文件处理，从基础操作到进阶技巧，让你轻松驾驭文件的读取、修改、管理与批处理任务。 注意\r文中用到的示例文件可在Github下载\r快速查看与读取文件内容\r查看文件内容\rGet-Content .\\1.txt 支持按行读取文本文件，适合日志查看、配置文件处理等。 读取特定行数\r读取前 2 行： Get-Content .\\1.txt -TotalCount 2 读取最后 2 行： Get-Content .\\1.txt -Tail 2 按关键字过滤内容\r列出文件中包含关键字 “summer” 的行： Get-Content .\\1.txt | Select-String -Pattern \"summer\" 或者 Get-Content .\\1.txt | Select-String -Pattern \"summer\" 创建与写入文件\r创建文件\rNew-Item .\\newfile.txt 写入内容\rSet-Content .\\newfile.txt \"Hello, PowerShell!\" 追加内容\rAdd-Content .\\newfile.txt \"Awesome!!!\" 复制、移动与重命名文件\r复制文件\r复制newfile.txt文件到helloworld.txt： Copy-Item .\\newfile.txt .\\helloworld.txt 移动文件\r将helloworld.txt移动到archive目录： move-item .\\helloworld.txt .\\archive\\ 重命名文件\r将newfile.txt重命名为newfile2.txt： Rename-Item .\\newfile.txt .\\newfile2.txt 删除文件与目录\r删除文件\r删除newfile2.txt文件： Remove-Item .\\newfile2.txt 删除目录\r删除archive目录： Remove-Item .\\archive\\ -Recurse 批量处理文件\r我们先创建 10 个文件，并写入一些内容： 1..10 | ForEach-Object { $fileName = \"demo$_.log\" \"This is log file number $_\" | Set-Content -Path $fileName } 获取所有.log文件\rGet-ChildItem -Path .\\ -Filter *.log 批量重命名文件\r将所有.log文件名中的demo替换为access_log_： Get-ChildItem -Path .\\ -Filter *.log | ForEach-Object { Rename-Item $_ -NewName $_.Name.Replace(\"demo\", \"access_log_\") } 按修改时间排序\rGet-ChildItem | Sort-Object LastWriteTime -Descending 合并多个文件为一个\rGet-ChildItem -Path .\\ -Filter *.log | Sort-Object LastAccessTime | ForEach-Object {Get-Content $_} | Set-Content access_log.log 压缩与解压文件\r压缩为 ZIP 文件\rCompress-Archive -Path .\\*.log -DestinationPath .\\log.zip 解压 ZIP 文件\rExpand-Archive -Path .\\log.zip -DestinationPath .\\unzipped_logs 按文件内容查找文件\r查找文件内容中包含关键字\"summer\"文件名： Get-ChildItem -Path .\\ -Filter *.txt | Where-Object { Select-String -Path $_.FullName -Pattern \"summer\"} 如果需要显示行内容和行号，可以使用如下命令： Get-ChildItem -Path .\\ -Filter *.txt | ForEach-Object { Select-String -Path $_.FullName -Pattern \"summer\" } PowerShell 是处理文件的利器，无论是自动化任务、系统维护，还是数据处理，只需几行脚本就能完成复杂的操作。掌握以上这些技巧，不仅能提升你的工作效率，也能让你更加得心应手地管理系统资源。 如果你还没有开始使用 PowerShell，现在就是最好的时机。动手试试吧——你会发现，文件操作原来也可以这么有趣！ ","date":"2025-07-28","objectID":"/%E7%94%A8powershell%E7%8E%A9%E8%BD%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/:0:0","tags":["PowerShell","文件处理","命令行"],"title":"用PowerShell玩转文件处理","uri":"/%E7%94%A8powershell%E7%8E%A9%E8%BD%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"categories":["源码剖析"],"content":"我们经常说，Python 是一门解释型语言，但你知道它的解释器 CPython 究竟是如何工作的么？Python 的内存管理、字节码执行、垃圾回收……这些幕后英雄是如何协作的？在这篇文章中，我们将通过剖析 CPython 源码，一起探索 Python 的运行本质。 为什么阅读 CPython 源码？\r理由很简单！ 注意\r只是想看看成功且优秀的代码是什么样的。\r严谨的代码结构：CPython 是由全球顶尖开发者共同维护的开源项目，其代码结构极为清晰。模块划分合理，功能边界明确，适合学习如何设计大规模软件系统。通过阅读，能学会如何平衡代码的灵活性和可维护性。 注释和文档的典范：CPython 源码中的注释和文档量非常丰富，代码可读性极高。尤其是核心部分的实现，几乎每个模块和关键函数都有注释，解释其意图、设计思路和限制条件。这是“写给人看的代码”应该具备的标准。 简洁而高效的实现：尽管实现的是复杂的功能，但 CPython 的代码常常让人感叹“原来还能这么简洁优雅”。它展示了如何用最小的复杂度完成既定任务，同时保持代码的直观性。 一致的风格：优秀代码的重要特征之一是风格统一。CPython 的开发者严格遵循 PEP（Python Enhancement Proposals）中的规范，代码风格干净利落且一致，值得作为日常开发中的代码书写范例。 精妙的性能优化：CPython 在追求易读性和高性能之间做出了巧妙的平衡。例如：内存管理的实现（如引用计数）、对象模型的优化、以及对关键代码路径的 C 语言加速。这些地方让人看到“优秀代码”不仅是可读的，还能高效运行。 经典设计模式的应用：CPython 源码中，很多地方使用了经典的设计模式，例如工厂模式（用于对象创建）、适配器模式（处理不同平台的系统调用）、策略模式（优化特定的算法执行）。它是学习设计模式实际应用的最佳实践。 跨平台的实现技巧：作为一个需要在多种操作系统上运行的解释器，CPython 的代码展示了如何编写兼容性良好的跨平台代码，同时又能利用特定平台的优势。它的解决方案体现了顶级工程师的智慧。 迭代与社区合作的典范：CPython 是经过二十多年迭代的成熟项目，许多代码并非一蹴而就，而是在社区的协作中不断打磨。这种“演化式”代码开发过程本身就是一种学习：代码如何从朴素走向优雅，从复杂趋于简洁。 阅读 CPython 源码，不仅能感受到编程艺术的美感，还能学到如何写出让别人（包括未来的自己）一看就懂的代码。作为一个开发者，我始终相信手里得有倚天剑或者屠龙刀，CPython 源码无疑就是这把神兵利器的锻造场！ 参考\rhttps://flaggo.github.io/python3-source-code-analysis/ 《Python 源码剖析》陈儒 ","date":"2024-11-27","objectID":"/cpython%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:0:0","tags":["Python","CPython","源码剖析"],"title":"CPython 源码剖析：Python 运行的奥秘","uri":"/cpython%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":" 纸上得来终觉浅，绝知此事要躬行。——陆游《冬夜读书示子聿》 csv2是一个轻量级 C++ 库，用于将 CSV 文件解析为 C++ 中的 STL 容器。该库的主要功能是高效地处理 CSV 数据，简化了处理 CSV 文件的代码编写过程。以下是它的主要特性： 简单易用：通过使用 STL 容器（如 std::vector 和 std::tuple），使得开发者能够轻松将 CSV 文件的内容转换为标准 C++ 数据结构。 依赖少：该库只有 C++17 标准库的依赖，因此不需要额外的第三方库。 高效解析：该库采用高效的解析机制，支持处理大型 CSV 文件。 轻量级：代码库很小，适用于嵌入式或对依赖库要求较高的项目。 准备\r项目源代码地址为p-ranav/csv2 v1.0。 阅读工具为 CLion。 剖析\r整个项目包含 4 个文件，分别是: reader.hpp、mio.hpp、writer.hpp和parameters.hpp。 .c vs .cc vs. .cpp vs .hpp vs .h vs .cxx: 由于历史渊源，造成头文件和源代码文件有些不同的命名方式，但本质而言没有什么区别。 reader.hpp\rreader.hpp 文件中主要定义了一个名为Reader的类。数据部分主要有: 紧接着定义了两个方法: mmap和parse，分别从文件和字符串内容解析内容。 从文件中解析内容: #include \"csv2/reader.hpp\" #include \u003cstring\u003e using namespace std; int main(){ csv2::Reader\u003ccsv2::delimiter\u003c','\u003e, csv2::quote_character\u003c'\"'\u003e, csv2::first_row_is_header\u003ctrue\u003e, csv2::trim_policy::trim_whitespace\u003e csv; std::string content = \"Name, Age\\nPeter, 12\\nLucy, 78\"; if(csv.parse(content)){ const auto header = csv.header(); for (const auto row: csv) { for (const auto cell: row) { // Do something with cell value std::string value; cell.read_value(value); cout \u003c\u003c value \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; } } } 从字符串中解析内容: #include \"csv2/reader.hpp\" #include \u003cstring\u003e using namespace std; int main(){ csv2::Reader\u003ccsv2::delimiter\u003c','\u003e, csv2::quote_character\u003c'\"'\u003e, csv2::first_row_is_header\u003ctrue\u003e, csv2::trim_policy::trim_whitespace\u003e csv; if(csv.mmap(\"demo.csv\")){ const auto header = csv.header(); for (const auto row: csv) { for (const auto cell: row) { // Do something with cell value std::string value; cell.read_value(value); cout \u003c\u003c value \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; } } } parse方法中使用了知识点 10。 reader.hpp 中还定义了Cell、Row、RowIterator等类。 为了方便在之后的类中使用 RowIterator、Row 和 CellIterator，文件中加了 forward-declaration，如上图所示。 Cell\rCell 类的数据部分定义如下: 其中的buffer_指向 memory-mapped buffer，可参考知识点 4，我们可以简单的将其理解为指向数据内容的一个指针。 主要包括两个方法: read_raw_value和read_value，两个方法稍有区别，前者处理无转义字符，后者处理有转义字符。 Row\rRow 类的数据部分定义如下: 和 Cell 类的定义大同小异。Row 类中还定义了另一个类 CellIterator: class CellIterator { friend class Row; const char *buffer_; size_t buffer_size_; size_t start_; size_t current_; size_t end_; public: CellIterator(const char *buffer, size_t buffer_size, size_t start, size_t end) : buffer_(buffer), buffer_size_(buffer_size), start_(start), current_(start_), end_(end) { } CellIterator \u0026operator++() { current_ += 1; return *this; } Cell operator*() { bool escaped{false}; class Cell cell; cell.buffer_ = buffer_; cell.start_ = current_; cell.end_ = end_; size_t last_quote_location = 0; bool quote_opened = false; for (auto i = current_; i \u003c end_; i++) { current_ = i; if (buffer_[i] == delimiter::value \u0026\u0026 !quote_opened) { // actual delimiter // end of cell cell.end_ = current_; cell.escaped_ = escaped; return cell; } else { if (buffer_[i] == quote_character::value) { if (!quote_opened) { // first quote for this cell quote_opened = true; last_quote_location = i; } else { escaped = (last_quote_location == i - 1); last_quote_location += (i - last_quote_location) * size_t(!escaped); quote_opened = escaped || (buffer_[i + 1] != delimiter::value); } } } } cell.end_ = current_ + 1; return cell; } bool operator!=(const CellIterator \u0026rhs) { return current_ != rhs.current_; } }; CellIterator 中定义了自增操作符、取值操作符和不等操作符。Iterator 必须实现这三个操作符: #include \u003ciostream\u003e using namespace std; // forward-declaration to allow use in Iter class IntVector; class Iter { public: Iter (const IntVector* p_vec, int pos) : _pos( pos ) , _p_vec( p_vec ) { } // these three methods form the basis of an iterator for use with // a range-based for loop bool operator!= (const Iter\u0026 other) const { return _pos != other._pos; } // this method must be defined after the definition of IntVector // since it needs to use it int operator* () const; const Iter\u0026 operator++ () { ++_pos; // although not strictly necessary for a range-based for loop // following the normal convention of returning a value from // operator++ is a good idea. return *this; } private: int _pos; const IntVector *_p_vec; }; class IntVector { public: IntVector () { } int get (int col) const { r","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:0:0","tags":["CSV","C++","源码剖析"],"title":"csv2 源码剖析：轻量级 CSV 处理的高效之道","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["数据科学"],"content":"在当今数据驱动的世界中，从大规模数据分析到精准预测模型，数据科学正在塑造我们的决策方式。而在众多数据科学工具中，R 凭借其强大的统计分析能力和丰富的社区资源，成为数据科学家和分析师的首选之一。那么，如何利用 R 优雅地解锁数据的潜力？让我们从基础开始，逐步探索 R 的神奇之处。 数据框和 Tibble\r数据框\r在 R 语言中，对于不同的列可以包含不同数据类型的数据，我们可以用data.frame()函数创建数据框： data \u003c- data.frame(col1, col2, col3,...) 其中的列向量col1、col2、col3等可为任何类型，比如字符型，数值型或逻辑型。每一列的名称可由函数names()指定。 我们来看一个例子： patientID \u003c- c(1:4) age \u003c- c(25, 34, 28, 52) status \u003c- c(\"Poor\", \"Improved\", \"Excellent\", \"Poor\") diabetes \u003c- c(\"Type1\", \"Type2\", \"Type1\", \"Type1\") patientData \u003c- data.frame(patientID, age, diabetes, status) 如果要选取某些列数据，我们可以如下几种方式： patientData[1] ## 选取第1列数据 patientData[1:3] ## 选取第1,2,3列数据 patientData[c(1,3)] ## 选取第1,3列数据 patientData[\"age\"] ## 选取age列数据 patientData[c(\"age\", \"patientID\")] ## 选取age列和patientID列数据 patientData$age ## 选取age列数据 创建 tibble\rtibble 是一种简单数据框，它对传统的数据框的功能进行了修改，以便让其更易于使用。tibble 是 tidyverse 的标准功能之一，由于多数其他 R 包使用的是标准数据框，因此可能需要将数据框转换为 tibble，为此我们可以使用as_tibble()函数来进行转换： as_tibble(patientData) 可以通过tibble()函数使用一个向量来创建新 tibble。tibble()会自动重复长度为 1 的输入，并且可以使用刚创建的变量，如下所示： tibble( x = 1:5, y = 1, z = x ^ 2 + y ## 使用刚创建的变量x ) 创建 tibble 的另一种方法是使用tribble()函数，tribble 是 transposed tibble 的缩写，其对数据按行进行编码，列标题由公式（以~开头）定义，数据条目以逗号分隔。 tribble(~x, ~y, ~z, \"a\", 1, 7, \"b\", 2, 3 ) tibble 和数据框对比\rtibble 和传统的数据框的使用方法主要有两处不同：打印和取子集。 打印\rtibble 的打印方法进行了优化，只显示前 10 行结果，并且列也是适合屏幕的，这种方式非常适合大数据集。除了打印列命，tibble 还会打印出列的数据类型。 在打印大数据框时，tibble 的这种设计避免了输出占满整个控制台。但有时需要比默认显示更多的输出，这时可以设置几个选项。 可以明确使用print()函数来打印数据框，并控制打印的行数（n）和显示的宽度（width）。width = Inf可以显示出所有列： nycflights13::flights %\u003e% print(n = 10, width = Inf) 还可以设置以下选项来控制默认的打印方式。 options(tibble.print_min = Inf)总是打印所有行。 options(tibble.width = Inf)总是打印所有列。 取子集\r如果我们想提取单个变量，我们可以使用$和[[]]，[[]]可以按名称或位置提取变量，而$只能按名称提取。 df \u003c- tibble( x = runif(5), y = rnorm(5) ) ## 按名称提取 df$x df[[\"x\"]] ## 按位置提取 df[[1]] 要想在管道中使用这些提取操作，需要使用特殊的占位符.： df %\u003e% .$x df %\u003e% .[[\"x\"]] 与data.frame相比，tibble 更严格：它不能进行部分匹配，如果想要访问的列不存在，会产生一条警告信息。 有些比较旧的函数不支持 tibble，此时我们可以使用as.data.frame()函数将 tibble 转换为data.frame。 探索性数据分析\r统计学家将使用可视化方法和数据转换来系统化地探索数据称为探索性数据分析（exploratory data analysis, EDA）。 EDA 期间的目标是获取对数据的理解。将问题作为指导调查研究的工具是进行 EDA 的最简单方式。 该提出什么样的问题来指导我们对数据的研究并没有确定的规则。但总有两类问题总是有助于我们理解数据，这两类问题大致如下： 变量本身会发生哪种变化？ 不同变量之间会发生哪种相关变化？ 本文中用到的数据集为如上所示的表格结构，每列是每个变量的值，每行称为一个观测或者样本，一个观测会包含多个值，每个值关联到不同变量，有时也将观测称为数据点。 上图为Diamonds数据集，其中： carat表示克拉重量 cut表示切割（Levels: Fair \u003c Good \u003c Very Good \u003c Premium \u003c Ideal） color表示成色（Levels: D \u003c E \u003c F \u003c G \u003c H \u003c I \u003c J） clarity表示净度（Levels: I1 \u003c SI2 \u003c SI1 \u003c VS2 \u003c VS1 \u003c VVS2 \u003c VVS1 \u003c IF） depth表示深度 table表示台面 price表示价格 x，y和z和含义如下图所示： 更多关于钻石的知识请参考：https://www.bluenile.com/cn/education/diamonds 每个变量的值都会有各自的变化模式，可以揭示一些有趣的信息。理解这种模式的最好方法就是对变量值的分布进行可视化分表示。 单个变量\r分类变量\r对变量值的分布进行可视化表示取决于变量是分类变量还是连续变量。如果一个变量的值仅在较小的集合内取值，那么这个变量就是分类变量。要想表示分类变量的分布，我们可以使用条形图： library(ggplot2) ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut)) 结果如下： 条形的高度表示每个x值观测的数量，可以用dplyr::count()手动计算出这些值： 连续变量\r如果一个变量可以在无限大的有序集合中任意取值，那么这个变量就是连续变量。数值型和日期时间型变量就是连续变量的两个例子。要想表示连续变量的分布，可以使用直方图： ggplot(data = diamonds) + geom_histogram(mapping = aes(x = carat), binwidth = 0.5) 我们也可以使用dplyr::count()和ggplot2::cut_width()函数的组合来手动计算结果： 直方图对 x 轴进行等宽分箱，然后使用条形的高度表示落入每个分箱的观测的数量。我们可以用binwidth参数来设定直方图中间隔的宽度，该参数用 x 轴变量的单位来度量的。不同的分箱宽度可以揭示不同的模式。比如，如果只考虑重量小于 3 克拉的钻石，并选择一个更小的分箱宽度，结果如下： diamonds %\u003e% filter(carat \u003c 3) %\u003e% ggplot(mapping = aes(x = carat)) + geom_histogram(binwidth = 0.1) 若想在一张图中叠加多个直方图，那么我们可以用geom_freqploy()函数来代替geom_histogram()函数，该函数使用的是折线图，相比一下更加容易理解： diamonds %\u003e% filter(carat \u003c 3) %\u003e% ggplot(mapping = aes(x = carat, color = cut)) + geom_freqpoly(binwidth = 0.1) 典型值\r条形图和直方图都用比较高的条形表示变量中的常见值，而用比较矮的条形表示变量中不常见的值，没有条形的位置表示数据中没有这样的值。 针对这些信息，我们提出一些问题，比如： 哪些值是最常见的？为什么？ 哪些值是很罕见的？为什么？符合预期吗？ 有什么异常的模式吗？如何解释？ diamonds %\u003e% filter(carat \u003c 3) %\u003e% ggplot(mapping = aes(x = carat)) + geom_histogram(binwidth = 0.01) 异常值\r异常值是与众不同的观测或是模式之外的数据点。有时异常值是由于数据录入错误而产生的。若数据量比较大，有时很难在直方图上发现异常值。查看Diamonds数据集中 y 轴变量的分布，唯一能表示存在异常值的证据是 y 轴的取值范围出奇的宽： ggplot(data = diamonds) + geom_histogram(mapping = aes(x = y), binwidth = 0.5) 由于正常值分箱中的观测值太多，以至于包括异常值的分箱高度太低，导致我们根本看不见。为了更容易发现异常值，我们可以使用coord_cartesian()","date":"2024-08-26","objectID":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/:0:0","tags":["R","数据科学","数据可视化","数据分析"],"title":"R数据科学","uri":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"},{"categories":["源码剖析"],"content":"Node.js 的诞生，让 JavaScript 从浏览器的专属语言，跃升为构建高性能服务器的利器。凭借事件驱动的架构和非阻塞 I/O 特性，Node.js 成为现代网络应用开发中的重要基石。然而，当你写下 http.createServer时，是否好奇过这些简单的 API 背后究竟发生了什么？ 本篇文章将带你深入 Node.js 的源码世界，揭开其核心模块、事件循环、异步模型和底层实现的神秘面纱。从 libuv 的非阻塞 I/O，到 V8 引擎对 JavaScript 的极速解析，我们将从代码的视角探索 Node.js 是如何在性能与灵活性之间找到绝佳平衡的。 无论你是想提升对 Node.js 的理解，还是希望从源码中汲取工程设计的智慧，这都将是一次充满收获的技术旅程。准备好了吗？让我们从入口文件开始，走进 Node.js 的源码迷宫！ 参考\rNode.js 源码剖析 《深入浅出 Node.js》朴灵 ","date":"2024-06-27","objectID":"/node.js%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:0:0","tags":["Node.js","运行时","非阻塞","异步","事件驱动","源码剖析"],"title":"Node.js 源码剖析：非阻塞世界的引擎密码","uri":"/node.js%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["Vue"],"content":"在开发 Vue 应用的过程中，调试是确保项目稳定性和高效性的关键步骤。无论是开发环境中的小问题，还是生产环境中的复杂 bug，合理的调试方法都能大大提升开发效率并减少错误发生的概率。本文将深入探讨 Vue 项目调试的常见技巧与工具，从基础的调试方法到进阶的技术方案，为开发者提供一个系统化的调试框架。通过合理的调试策略，开发者能够快速定位问题，并对症下药，确保项目的顺利进行。 调试准备\r相关环境 编辑器: VSCode Node 版本: 20.10.0 包管理器: cnpm 9.2.0 创建项目\r参考Vue 官方文档，使用cnpm快速创建项目: cnpm create vue@latest 运行项目\r在终端运行如下命令，启动项目: npm run dev 此时我们可以使用 Vue DevTools 工具进行调试，或者配置 VSCode 进行调试。 VSCode 调试\r创建调试配置文件.vscode/launch.json，添加一个调试配置: .vscode/launch.json内容如下: { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"chrome\", \"request\": \"launch\", \"name\": \"Launch Chrome against localhost\", \"url\": \"http://localhost:5173\", \"webRoot\": \"${workspaceFolder}\" } ] } 点击调试按钮，即可启动调试。 推荐\r如何优雅的调试 Vue 项目？ Debugging Magic with Vue Devtools Decoding 14 Vue.js errors: A Vue.js debugging guide ","date":"2024-03-02","objectID":"/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95vue%E9%A1%B9%E7%9B%AE/:0:0","tags":["Vue","前端开发","调试"],"title":"如何调试Vue项目","uri":"/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95vue%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":" 这里汇集了各个领域中整理的优质学习资源和实用工具，不论是编程与技术，还是人文与艺术，你都能在这里找到适合自己的内容。不论你是初学者，还是在追求多元知识的探索者，我都希望这些资源能为你的学习旅程带来启发和帮助。从深度教程到精选书单，从实用工具到开源项目。希望这些内容能助你高效学习，发现更多有趣的知识世界！✨ 计算机科学导论\r计算机科学速成课 - Crash Course Computer Science 哈佛大学公开课：计算机科学 cs50 计算机组成\r陆俊林 计算机组成 CSE 351: The Hardware/Software Interface 操作系统\r向勇 操作系统 6.828: Operating System Engineering os-tutorial: How to create an OS from scratch 李治军 操作系统 哈工大操作系统实验手册 实验楼 操作系统原理与实践 数据库\r6.830/6.814: Database Systems SQL Tutorial for Beginners with MySQL 分布式系统\rDistributed Systems 6.824: Distributed Systems 计算机网络\rComputer Networking Tutorial: The Ultimate Guide 编译器\r华保健 编译原理 Compilers B 站观看 Compiler Design Implementing a Regular Expression Engine 自己动手写编译器: 本书将介绍一个非常简单的编译器（ TinyC 编译器）的实现，用简单和易于实现的实例来描述基本的编译原理及过程，希望能为学习编译原理的读者提供一些参考。 密码学\rChristof Paar - Introduction to Cryptography Frontend\rTop 10 Frontend Frameworks of 2018 前端开发学习路线 C\r翁恺 C 语言程序设计 Practical Programming in C Introduction to C Memory Management and C++ Object-Oriented Programming Let’s Build a Simple Database Tinyhttpd: Tinyhttpd 是 J. David Blackstone 在 1999 年写的一个不到 500 行的超轻量型 Http Server，用来学习非常不错，可以帮助我们真正理解服务器程序的本质。 json-tutorial: 从零开始的 JSON 库教程。 project-based-tutorials-in-c: A curated list of project-based tutorials in C awesome-c: A curated list of awesome C frameworks, libraries, resources and other shiny things. Inspired by all the other awesome-… projects out there. awesome-c: Continuing the development of awesome-c list on GitHub C++\r郑莉 C++语言程序设计基础 和 C++语言程序设计进阶 CS106X: Programming Abstractions in C++ CS106B: Programming Abstractions in C++ B 站观看 muduo: Event-driven network library for multi-threaded Linux server in C++11. MyTinySTL: Achieve a tiny STL in C++11. musikcube: a cross-platform, terminal-based music player, audio engine, metadata indexer, and server in c++. C++ 跟侯捷学 C++: 系统学习 C++知识体系。 sudoku: C++实现的跨平台数独游戏，命令行操作易上手，可以在开发间隙用来放松身心。数百行代码，初学者也可以轻松掌握。 LearnCpp.com: LearnCpp.com is a free website devoted to teaching you how to program in C++. Whether you’ve had any prior programming experience or not, the tutorials on this site will walk you through all the steps to write, compile, and debug your C++ programs, all with plenty of examples. Learn OpenGL: Welcome to the online book for learning OpenGL! Whether you are trying to learn OpenGL for academic purposes, to pursue a career or simply looking for a hobby, this book will teach you the basics, the intermediate, and all the advanced knowledge using modern (core-profile) OpenGL. The aim of LearnOpenGL is to show you all there is to modern OpenGL in an easy-to-understand fashion with clear examples, while also providing a useful reference for later studies. awesome-modern-cpp: A collection of resources on modern C++ Awesome C++: A curated list of awesome C++ (or C) frameworks, libraries, resources, and shiny things. Inspired by awesome-… stuff. C#\rLearn C# by Building a Simple RPG: If you want to write a Role Playing Game, but don’t know how to program, or just want to learn how to program in C#, then you’re at right the place. Python\rc9-python-getting-started: Sample code for Channel 9 Python for Beginners course 计算机科学和 Python 编程导论 CS 61A: Structure and Interpretation of Computer Programs Python 教程 Let’s Build A Simple Interpreter httpstat: httpstat 美化了 curl 的结果，使得结果更加可读。 reddit: reddit 网站的源码。 500lines: 500 Lines or Less. you-get: ⏬ Dumb downloader that scrapes the web scrapydweb: Web app for Scrapyd cluster management, Scrapy log analysis \u0026 visualization, Auto packaging, Timer tasks, Monitor \u0026 Alert, and Mobile UI. manim: Animation engine for explanatory math videos scylla: Intelligent proxy pool for Humans™ wttr.in: ⛅️ The right way to check the weather https://wttr.in spug: 开源运维平台：面向中小型企业设计的轻量级无 Agent 的自动化运维平台，整合了主机管理、主机批量执行、主机在线终端、文件在线上传下载、应用发布部署、在线任务计划、配置中心、监控、报警等一系列功能。 learn_python3_spider: python 爬虫教程系列、从 0 到 1 学习 python 爬虫，包括浏览器抓包，手机 APP 抓包，如 fiddler、mitmproxy，各种爬虫涉及的模块的使用，如：requests、beautifulSoup、selenium、appium、scrapy 等，以及 IP 代理，验证码识别，Mysql，MongoDB 数据库的 python 使用，多线程多进程爬","date":"2024-02-26","objectID":"/resource/:0:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":" 🎓 公开课集散地\r汇集来自全球各大平台的优质公开课 🌍，涵盖编程 💻、数据科学 📊、人工智能 🤖、人文社科 📖 等多个领域。无论你是想提升技能 🔧，拓展视野 🌈，还是发现新兴趣 ✨，都能在这里找到合适的课程。这些课程多数免费开放，让你随时随地学习 📅。希望你能在这里收获知识的快乐 🎉，不断成长 🌱！ awesomeCsCourses: 国内外优秀的计算机软件专业在线课程推荐 awesome-cs-courses-zh: 计算机公开课推荐 CS 自学指南 🌈 课程清单\r2024\rStanford CS107 Programming Paradigms 编程范式 清华大学 经济学原理 耶鲁大学 聆听音乐 哈尔滨工业大学 操作系统 Machine Learning 2022 Spring Deep Learning for Human Language Processing 2020 Spring 6.824 Schedule: Spring 2022 计算机网络 2015 CMU 15-213 CSAPP 深入理解计算机系统 2025\rGAMES101 现代计算机图形学入门 闫令琪 MIT 6.824: Distributed System 清华大学 数据挖掘：理论与算法 国立台湾大学 頑想學概率 国立阳明交通大学 统计学（一）基础统计 国立阳明交通大学 统计学（二）进阶统计 哈佛大学 积极心理学 北京师范大学 普通心理学 耶鲁大学 哲学-死亡 中国人民公安大学 犯罪心理解析 耶鲁大学 博弈论 南政法大学 法律基础 ","date":"2024-02-25","objectID":"/opencourse/:0:0","tags":null,"title":"公开课","uri":"/opencourse/"},{"categories":null,"content":" 引用\r书籍是人类进步的阶梯。—— 高尔基\r🎉 书籍集散地\r无论是技术领域的深度探索，还是生活智慧的启迪，每一本书都是一扇通往新世界的窗。希望这些精选书单能激发你对知识的渴望，帮助你在个人成长和职业发展中不断迈上新台阶。 我的编程之路 程序员最应该读的图书（原版） 程序员最应该读的图书（中译版） 交互设计，并不仅仅是设计 ⋯⋯ 『只读经典』思维改变生活（原“心理学改变生活”） Hack 的技术与艺术 机器学习与人工智能 耶鲁大学部分公开课教科书与参考书目录 心智黑客 豆瓣 9 分以上计算机图书 computer-book-list: 一个综合了豆瓣，goodreads 综合评分的计算机书籍书单 有哪些值得推荐的豆友的豆列？ 🌟 阅读清单\r在这里，将与大家分享那些改变我思维、提升我能力的书籍。 {\"legend\":{\"data\":[\"计算机\",\"文学\",\"传记\",\"经济\",\"饮食\",\"写作\",\"哲学\",\"政治\",\"电影\",\"历史\",\"理财\",\"数学\"]},\"series\":[{\"barGap\":0,\"data\":[10,9],\"emphasis\":{\"focus\":\"series\"},\"label\":{\"align\":\"left\",\"distance\":15,\"fontSize\":12,\"formatter\":\"{c} {name|{a}}\",\"position\":\"insideBottom\",\"rich\":{\"name\":{}},\"rotate\":90,\"show\":true,\"verticalAlign\":\"middle\"},\"name\":\"计算机\",\"type\":\"bar\"},{\"barGap\":0,\"data\":[2,0],\"emphasis\":{\"focus\":\"series\"},\"label\":{\"align\":\"left\",\"distance\":15,\"fontSize\":12,\"formatter\":\"{c} {name|{a}}\",\"position\":\"insideBottom\",\"rich\":{\"name\":{}},\"rotate\":90,\"show\":true,\"verticalAlign\":\"middle\"},\"name\":\"文学\",\"type\":\"bar\"},{\"barGap\":0,\"data\":[2,0],\"emphasis\":{\"focus\":\"series\"},\"label\":{\"align\":\"left\",\"distance\":15,\"fontSize\":12,\"formatter\":\"{c} {name|{a}}\",\"position\":\"insideBottom\",\"rich\":{\"name\":{}},\"rotate\":90,\"show\":true,\"verticalAlign\":\"middle\"},\"name\":\"传记\",\"type\":\"bar\"},{\"barGap\":0,\"data\":[2,0],\"emphasis\":{\"focus\":\"series\"},\"label\":{\"align\":\"left\",\"distance\":15,\"fontSize\":12,\"formatter\":\"{c} {name|{a}}\",\"position\":\"insideBottom\",\"rich\":{\"name\":{}},\"rotate\":90,\"show\":true,\"verticalAlign\":\"middle\"},\"name\":\"经济\",\"type\":\"bar\"},{\"barGap\":0,\"data\":[1,0],\"emphasis\":{\"focus\":\"series\"},\"label\":{\"align\":\"left\",\"distance\":15,\"fontSize\":12,\"formatter\":\"{c} {name|{a}}\",\"position\":\"insideBottom\",\"rich\":{\"name\":{}},\"rotate\":90,\"show\":true,\"verticalAlign\":\"middle\"},\"name\":\"饮食\",\"type\":\"bar\"},{\"barGap\":0,\"data\":[1,0],\"emphasis\":{\"focus\":\"series\"},\"label\":{\"align\":\"left\",\"distance\":15,\"fontSize\":12,\"formatter\":\"{c} {name|{a}}\",\"position\":\"insideBottom\",\"rich\":{\"name\":{}},\"rotate\":90,\"show\":true,\"verticalAlign\":\"middle\"},\"name\":\"写作\",\"type\":\"bar\"},{\"barGap\":0,\"data\":[3,0],\"emphasis\":{\"focus\":\"series\"},\"label\":{\"align\":\"left\",\"distance\":15,\"fontSize\":12,\"formatter\":\"{c} {name|{a}}\",\"position\":\"insideBottom\",\"rich\":{\"name\":{}},\"rotate\":90,\"show\":true,\"verticalAlign\":\"middle\"},\"name\":\"哲学\",\"type\":\"bar\"},{\"barGap\":0,\"data\":[1,0],\"emphasis\":{\"focus\":\"series\"},\"label\":{\"align\":\"left\",\"distance\":15,\"fontSize\":12,\"formatter\":\"{c} {name|{a}}\",\"position\":\"insideBottom\",\"rich\":{\"name\":{}},\"rotate\":90,\"show\":true,\"verticalAlign\":\"middle\"},\"name\":\"政治\",\"type\":\"bar\"},{\"barGap\":0,\"data\":[1,0],\"emphasis\":{\"focus\":\"series\"},\"label\":{\"align\":\"left\",\"distance\":15,\"fontSize\":12,\"formatter\":\"{c} {name|{a}}\",\"position\":\"insideBottom\",\"rich\":{\"name\":{}},\"rotate\":90,\"show\":true,\"verticalAlign\":\"middle\"},\"name\":\"电影\",\"type\":\"bar\"},{\"barGap\":0,\"data\":[2,0],\"emphasis\":{\"focus\":\"series\"},\"label\":{\"align\":\"left\",\"distance\":15,\"fontSize\":12,\"formatter\":\"{c} {name|{a}}\",\"position\":\"insideBottom\",\"rich\":{\"name\":{}},\"rotate\":90,\"show\":true,\"verticalAlign\":\"middle\"},\"name\":\"历史\",\"type\":\"bar\"},{\"barGap\":0,\"data\":[1,2],\"emphasis\":{\"focus\":\"series\"},\"label\":{\"align\":\"left\",\"distance\":15,\"fontSize\":12,\"formatter\":\"{c} {name|{a}}\",\"position\":\"insideBottom\",\"rich\":{\"name\":{}},\"rotate\":90,\"show\":true,\"verticalAlign\":\"middle\"},\"name\":\"理财\",\"type\":\"bar\"},{\"barGap\":0,\"data\":[0,4],\"emphasis\":{\"focus\":\"series\"},\"label\":{\"align\":\"left\",\"distance\":15,\"fontSize\":12,\"formatter\":\"{c} {name|{a}}\",\"position\":\"insideBottom\",\"rich\":{\"name\":{}},\"rotate\":90,\"show\":true,\"verticalAlign\":\"middle\"},\"name\":\"数学\",\"type\":\"bar\"}],\"title\":{\"text\":\"统计\"},\"toolbox\":{\"feature\":{\"dataView\":{\"readOnly\":false,\"show\":true},\"magicType\":{\"show\":true,\"type\":[\"line\",\"bar\",\"stack\"]},\"mark\":{\"show\":true},\"restore\":{\"show\":true},\"saveAsImage\":{\"show\":true}},\"left\":\"right\",\"orient\":\"vertical\",\"show\":true,\"top\":\"center\"},\"tooltip\":{\"axisPointer\":{\"type\":\"shadow\"},\"trigger\":\"axis\"},\"xAxis\":[{\"axisTick\":{\"show\":false},\"data\":[\"2024\",\"2025\"],\"type\":\"category\"}],\"yAxis\":[{\"type\":\"value\"}]} 2024\r计算机\rJavaScript 高级程","date":"2024-02-25","objectID":"/book/:0:0","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":" 🚀 论文集散地\r要成长为一个高手，论文是你一定要读的。下面是一些非常不错的计算机方面的论文集散地。 2 Minute Papers ，这是一个 YouTube 的频道，其会给出一些非常不错的和计算机相关的论文介绍，让你了解目前最有意思的一些科学突破，每次两分钟左右。 Best Paper Awards in Computer Science ，从 1996 年以来，获奖的计算机科学方面的论文收集。 Google Scholar ，Google 学术搜索（英语：Google Scholar）是一个可以免费搜索学术文章的网络搜索引擎，由计算机专家阿努拉格·阿查里雅（Anurag Acharya）开发。2004 年 11 月，Google 第一次发布了 Google 学术搜索的试用版。该项索引包括了世界上绝大部分出版的学术期刊。 Facebook ，Facebook 公司的论文。 Research at Google ，Google 发布一些论文。 Microsoft Research ，微软发布的论文。 MIT’s Artificial Intelligence Lab Publications ，MIT 和人工智能相关的论文。 MIT’s Distributed System’s Reading Group ，MIT 和分布式系统相关的论文。 arXiv Paper Repository ，arXiv 是一个收集物理学、数学、计算机科学与生物学的论文预印本的网站，始于 1991 年 8 月 14 日。截至 2008 年 10 月，arXiv.org 已收集超过 50 万篇预印本。至 2014 年底，藏量达到 1 百万篇。 在 2014 年时，约以每月 8000 篇的速度增加。arXiv 的存在是造就科学出版业中所谓开放获取运动的因素之一。现今的一些数学家及科学家习惯先将其论文上传至 arXiv.org，再提交予专业的学术期刊。这个趋势对传统学术期刊的经营模式造成了可观的冲击。 SciRate ，arXiv 上的论文太多，所以，SciRate 索引了 arXiv 上的一些好评的论文，并供大家评论和打分。（开源代码。） cat-v.org ，这个网站，不只有论文，还有技术手册或是一些有意思的文章，包括一些历史资料什么的。 Usenix: Best Papers ，Usenix 上推荐的最佳论文。 The Morning Paper ，该博客会每天推送一篇论文，特别棒。 Lobste.rs tagged as PDF ，Lobsters 是一个聚焦于技术的社区，主要是链接聚合和对话题进行讨论。其中的 PDF 分类可以认为也是一个论文的集散地。 Papers We Love ，GitHub 上的一个近 3 万颗星的计算机科学方面的论文社区。 注意\r以上内容摘抄自左耳朵耗子《左耳听风》专栏“技术资源集散地”一文\r✨ 阅读清单\r2024\r# 标题 年份 论文 代码 状态 1 You Only Look Once: Unified, Real-Time Object Detection 2015 Link Link ❎ 2 YOLOv4: Optimal Speed and Accuracy of Object Detection 2020 Link Link ❎ 3 A Neural Algorithm of Artistic Style 2015 Link Link ❎ 2025\r# 标题 年份 论文 代码 状态 1 The Google File System 2003 Link 无 ❎ 2 What Every Programmer Should Know About Memory 2007 Link 无 ❎ 3 Bigtable: A Distributed Storage System for Structured Data 2006 Link 无 ❎ 4 Why Functional Programming Matters 1990 Link 无 ❎ ","date":"2024-02-25","objectID":"/paper/:0:0","tags":null,"title":"论文","uri":"/paper/"},{"categories":null,"content":" 大家好！我是东东东尼君，一个热爱学习和分享的技术探索者。在编程的世界里，我专注于 JavaScript、Node.js、C/C++ 和 Python，并且不断扩展自己的技能边界，从前端到后端，从数据分析到机器学习，力求通过技术创造更大的价值。 📚 目前正在学习\r为了持续提升自己的技术能力，我目前正在学习： 并发编程：深入理解多线程编程模型及并发控制技术，提高系统性能与效率。 操作系统原理：研究操作系统的核心概念，如进程管理、内存管理、文件系统等，以更好地理解底层系统架构。 ✍️ 博客与分享内容\r我热衷于分享我的开发旅程，在博客和各大技术社区中输出原创内容，包括但不限于： 技术文章：深入探讨前后端开发、系统架构、数据库优化、机器学习等主题。 开源项目：分享我的项目经验和代码库，包括实际案例中的技术挑战和解决方案。 学习笔记：记录学习新技术的过程，如 C++ 并发编程 和 操作系统原理。 行业观察：关于前沿技术、开发者工具和行业趋势的分析与个人见解 读书笔记：总结技术书籍、经典书籍的阅读收获和思考。 📢 社交媒体 \u0026 开源社区\r我坚信技术的力量源于分享和协作，期待与更多的技术爱好者交流碰撞灵感！欢迎关注我的社交媒体账号，一起探索无限可能： GitHub: AndyFree96 Twitter: @IRONAnthony96 知乎: IRONAnthony Facebook: anthonyfree96 不定期更新开源项目，分享前沿技术动态与个人思考，技术答疑与知识分享。 🚀 推荐的博主\r在这个信息爆炸的时代，找到一些有价值的博主，能够为我们提供深刻的见解与启发，是一种难得的幸运。以下是一些我一直关注的博主，他们的内容不仅拓宽了我的视野，也让我在不同领域中受益匪浅。如果你也对这些话题感兴趣，欢迎一起探索他们的精彩世界。 陈硕的 Blog 酷 壳 – CoolShell 阮一峰的网络日志 张鑫旭 数据库内核月报 Glow 技术团队博客 美团技术团队 廖雪峰的官方网站 谢乾坤 | Kingname 云风的 BLOG Barret 李靖 我爱自然语言处理 Netflix Tech Blog Google Research Blog Skywind（林伟） 囧克斯 勾三股四 Reimu’s blog weirane’s blog Beyond the Void MacTalk-池建强的随想录 凹凸实验室 web.dev DIYgod Lil’Log ruder.io Machine Learning Mastery PyImageSearch Stack Abuse Real Python JavaScript Today Meeting C++ Fluent{C++} C++ Stories Sutterʼs Mill Modernes C++ C++ Tips of the Week C++ Team Blog Scott Brady’s Blog Code with Steve Dev To CSS-Tricks Smashing Magazine overreacted Speckyboy CODROPS ultimatecourses ","date":"2024-02-25","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":["细读经典"],"content":" 2024/1/17 更新: 增加进程间通信 第 1 章 理解网络编程和套接字\r理解网络编程和套接字\r网络编程中接受连接请求的套接字创建过程如下: 调用socket函数创建套接字（购买电话机） 调用bind函数分配 IP 地址和端口号（分配电话号码） 调用listen函数转为可接收请求和状态（连接电话线） 调用accpet函数受理连接请求（接听电话） 客户端程序只有“调用 socket 函数创建套接字”和“调用 connect 函数向服务器发送连接请求”两个步骤。 基于 Linux 的文件操作\r对 Linux 而言，socket 操作与文件操作没有区别，socket 被认为是文件的一种，因此在网络数据传输过程中自然可以使用文件 I/O 的相关函数。Windows 和 Linux 不同，区分二者。 文件描述符只不过是为了方便称呼操作系统创建的文件或套接字而赋予的数而已。文件描述符有时也称为句柄，但“句柄”主要是 Windows 中的术语。 在项目中，为了给基本数据类型赋予别名，一般会添加大量的typedef声明。为了与程序员定义的新数据类型加以区分，操作系统定义的数据类型会添加后缀_t，例如size_t、ssize_t等。 文件描述符从 3 开始由小到大顺序编号，因为 0、1、2 分配给标准 I/O 的描述符。 在 Linux 下我们使用read和write函数对 socket 进行读取和写入。 基于 Windows 平台的实现\rWindows 套接字（简称 Winsock）大部分是参考 BSD 系列的 UNIX 套接字设计的。 为了在 Windows 基础上开发网络程序，需要做如下准备。 导入头文件winsock2.h 链接ws2_32.lib库 Winsock 编程时必须首先调用WSAStartup函数，设置程序中用到的 Winsock 版本，并初始化相应版本的库。 注销该库使用如下函数: ##include \u003ciostream\u003e ##include \u003cWinSock2.h\u003e int main() { WSADATA wsaData; if (WSAStartup(MAKEWORD(2, 2), \u0026wsaData) != 0) { std::cout \u003c\u003c \"WSAStartup ERROR!\" \u003c\u003c std::endl; } WSACleanup(); return 0; } 在 Windows 中使用send和recv函数进行发送和收取。 第 2 章 套接字类型与协议设置\r协议是计算机对话使用的通信规则。简而言之，协议就是为了完成数据交换而定好的约定。 ##include \u003csys/socket.h\u003e int socket(int domain, int type, int protocol); // 成功返回文件描述符，失败时返回-1 domain套接字使用的协议族信息 type套接字数据传输类型信息 protocol计算机间通信中使用的协议信息 协议族\r套接字通信中的协议有一些分类，通过socket函数的第一个参数传递套接字中使用的协议分类信息。 套接字类型\r套接字类型指的是套接字的数据传输方式，通过socket函数的第二个参数传递，只有这样才能决定创建的套接字的数据传输方式。为什么通过第一个参数传递了协议族信息，还要决定数据传输方式？这是因为决定了协议族并不能同时决定数据传输方式，换而言之，socket函数第一个参数PF_INET协议族中也存在多种数据传输方式。 面向连接的套接字（SOCK_STREAM）\r上图的数据（糖果）传输方式特征整理如下： 传输过程中数据不会消失 按序传输数据 传输的数据不存在数据边界（Boundary）（比如，集满 100 个才打包一次） 存在数据边界意味着接收数据的次数应和传输次数相同。 传输端和接收端各有 1 名工人，意味着套接字连接必须一一对应。 可靠的、按序传递的、基于字节的面向连接的数据传输方式的套接字。（传送带传输，收和发套接字都有缓存，多次write可能只需要一次read，即二者的次数可以不等，传输的数据不存在数据边界） 面向消息的套接字（SOCK_DGRAM）\r上图中摩托车快递包括（数据）传输方式如下： 强调快速传输而非传输顺序 传输的顺序可能丢失也可能损毁 传输的数据有数据边界 限制每次传输的数据大小 不可靠的、不按序传递的、以数据的高速传递为目的的套接字（摩托车传输，发一次得收一次，传输的数据存在数据边界）。 协议的最终选择\rsocket函数的前两个参数传递了协议族的信息和套接字数据传输方式，这些信息还不足以决定采用的协议吗？为什么还需要传递第 3 个参数？ 前两个参数即可创建所需套接字。所以大部分情况下可以向第三个参数传递 0，除非遇到以下情况: 同一个协议族中存在多个传输方式相同的协议 数据传输方式相同，但协议不同。此时需要通过第三个参数具体指定协议信息。 比如，创建“IPv4 协议族面向连接的套接字”。 参数PF_INET指 IPv4 网络协议族，SOCK_STREAM是面向连接的数据传输。满足这两个条的协议只有IPPROTO_TCP，这种套接字称为 TCP 套接字。 int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); 再比如，创建“IPv4 协议族面向消息的套接字”。 满足上述条件的协议只有IPPROTO_UDP，这种套接字称为 UDP 套接字。 int udp_socket = socket(PF_INET, SOCKET_STREAM, IPPROTO_UDP); 第 3 章 地址族与数据序列\r分配给套接字的 IP 地址和端口号\rIP 是 Internet Protocol（网络协议）的简写，是为收发网络数据而分配给计算机的值。端口号并非赋予计算机的值，而是为区分程序中创建的套接字而分配给套接字的序号。 网络地址（Internet Address）\r为让计算机连接到网络并收发数据，需向其分配 IP 地址。IP 地址分为两类。 IPv4（Internet Protocol version 4） 4 字节地址族 IPv6（Internet Protocol version 6） 16 字节地址族 网络地址（网络 ID）是为区分网络而设置的一部分 IP 地址。传输数据时，并非一开始就浏览所有 4 字节 IP 地址，进而找到目标主机；而是仅浏览 4 字节 IP 地址的网络地址，向把数据传到网络。网络（构成网络的路由器（Router）或交换机（Switch））接到数据后，浏览传输数据的主机地址（主机 ID）并将数据传给目标计算机。 构建网络需要一种物理设备完成外网与本网主机之间的数据交换，这种设备便是路由器或交换机。它们也是一种计算机，只不过为了特殊目的而设计运行的，因而有了别名。我们可在自己的计算机中安装适当的软件，也可以将其作为交换机。交换机的功能比路由器简单一些，实际差别不大。 网络地址分类与主机地址边界\r只需通过 IP 地址的第一个字节即可判断网络地址占用的字节数: 用于区分套接字的端口号\r计算机中一般配有 NIC（Network Interface Card，网络接口卡）数据传输设备。通过 NIC 向计算机内部传输数据时会用到 IP。操作系统负责把传递到内部的数据适当分配给套接字，这时就要利用端口号。也就是说，通过 NIC 收到的数据内有端口号，操作系统参考此端口号把数据传输给相应端口的套接字。 端口号是在同意操作系统内为区分不同套接字而设置的，因此无法将一个端口号分配给不同套接字。端口号由 16 位构成，可分配的端口号范围是 065535。但 01023 是知名端口号（Wll-known PORT），一般分配给特定应用程序。TCP 套接字和 UDP 套接字不会公用端口号，所以允许重复。 数据传输目标地址同时包含 IP 地址和端口号，只有这样，数据才会被传输到最终的目的应用程序（应用程序套接字）。 地址信息的表示\r表示 IPv4 地址的结构体\rstruct sockaddr_in { sa_family_t sin_family; // 地址族(Address Family) uint16_t sin_port; // 16位TCP/UDP端口号 struct in_addr sin_addr; // 32位IP地址 char sin_zero[8]; // 不使用 } in_addr定义如下: struct in_addr { In_addr_t s_addr; // 32位IPv4地址 }; 网络字节序与地址转换\r字节序（Order）与网络字节序\rCPU 向内存保存数据的方式有两种: 大端序（Big Endian）: 高位字节放到低位地址 小端序（Little Endian）: 高位字节放到高位地址 主流的 Intel 系列 CPU 以小端序方式保存数据。 在通过网络传输数据时约定统一的方式，称为网络字节序（Network Byte Order），非常简单——统一为大端序。即，先把数据数组转化为大端序格式再进行网络传输。 字节序转换（Endian Conversions）\r#include \u003cstdio.h\u003e #include \u003carpa/inet.h\u003e int main(int argc, char *argv[]){ unsigned short host_port = 0x1234; unsigned short net_port; unsigned long host_addr = 0x1234567","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:0:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"在计算机科学领域，数据结构和算法是开发高效程序的核心工具。无论你是初学者还是经验丰富的开发者，掌握这些概念都能帮助你构建更快、更稳定的应用程序。我们日常使用的软件，从搜索引擎到社交媒体，再到购物网站，无不依赖数据结构和算法的强大支持。一个好的数据结构可以优化存储和访问数据的方式，而高效的算法则可以显著提升任务的执行速度。 数组\r几乎所有的编程语言都原生支持数组类型，因为数组是最简单的内存数据结构。数组存储一系列同一种数据类型的值，但在 JavaScript 中，数组中可以保存不同类型的值。大多数语言没有这个能力，因此本节中我们尽量避免这么做。 创建和初始化数组\r在 JavaScript 声明、创建和初始化数组十分简单，就像下面这样。 let daysOfWeek = new Array(); // {1} daysOfWeek = new Array(7); // {2} daysOfWeek = new Array( 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ); // {3} 使用new关键字就能声明并初始化一个数组（行{1}）。用这种方式，还可以创建一个指定长度的数组（行{2}）。此外，我们也可以将数组元素作为参数传递给它的构造器（行{3}）。 也可以只用中括号[]创建数组： let daysOfWeek = []; daysOfWeek = [ 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', ]; 若想知道数组存储了多少个元素，可以使用数组的length属性。 访问元素和迭代数组\r要访问数组中特定位置的元素，可以用中括号传递数值位置，得到想知道的值或者赋新的值。若想输出数组daysOfWeek中所有的元素，可以通过循环迭代数组、打印元素，如下所示： for (let i = 0; i \u003c daysOfWeek.length; i++) { console.log(daysOfWeek[i]); } 添加元素\r假如有一个初始化为 0 到 9 个数组numbers。 let numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; 在数组末尾插入元素\r在 JavaScript 中，数组是一个可以修改的对象。若添加元素，它会自动动态增长。若想在数组末尾插入元素，只要把值赋给数组中最后一个空位上的元素即可。 numbers[numbers.length] = 10; 当然，也可以赋给下标为numbers.length+2的元素，那么下标为numbers.length和numbers.length+1就会为空： numbers[numbers.length + 2] = 10; 通过push方法也可以将元素添加到数组的末尾。push方法能让我们添加任意个元素。 numbers.push(11); numbers.push(12, 13); 在数组开头插入元素\r如果我们希望在数组中插入一个新元素（例如-1）到开头。为了实现这个需求，首先要腾出数组第一个元素的位置，把所有的元素向右移动一位。我们可以将其写成一个函数，甚至将方法直接添加到Array的原型上，使所有数组的实例都可以访问到该方法。 Array.prototype.insertFirstPosition = function (value) { for (let i = this.length; i \u003e= 0; i--) { this[i] = this[i - 1]; } this[0] = value; }; numbers.insertFirstPosition(-1); 下图描述了整个过程。 在 JavaScript 中，数组有一个名为unshift的方法可以直接将值插入数组的开头（背后逻辑和insertFirstPosition一样）。 numbers.unshift(-2); numbers.unshift(-4, -3); 删除元素\r从数组末尾删除元素\r要从数组末尾删除元素，可以用pop方法。 numbers.pop(); 从数组开头删除元素\r要删除数组的第一个元素，可以用shift方法。 numbers.shift(); 在任意位置添加或删除元素\r使用splice方法，指定位置就可以删除相应位置上指定数量的元素。 numbers.splice(5, 3); 现在，我们想把数 2、3、4 插入数组中，放到之前删除元素的位置上，可以再次使用splice方法。 numbers.splice(5, 0, 2, 3, 4); splice方法的第一个参数表示想要删除或插入的元素的索引值，第二个参数是删除元素的个数。第三个参数往后是要添加到数组中的值。 数组方法参考\rJavaScript 中的数组有很多好用的方法，如下表所示： 类型数组\r类型数组用于存储单一类型的数据。其语法为let myArray = new TypedArray(length)，其中TypedArray需替换为下表所列。 let int16 = new Int16Array(16); for (let i = 0; i \u003c int16.length; i++) { int16[i] = i + 1; } 栈\r数组允许我们在任意位置上删除或添加元素。然而，有时候需要一种能在添加或删除元素时进行更多控制的数据结构。有两种类似于数组的数据结构在添加和删除元素时更为可控，它们就是栈和队列。 栈数据结构\r栈是一种遵从后进先出（Last In First Out，LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称为栈顶，另一端称为栈底。 在栈中，新元素靠近栈顶，旧元素靠近栈底。栈被用在很多地方，例如编译器和内存中保存变量、方法调用等，也被用于浏览器历史记录（浏览器的返回按钮）。 基于数组的栈\r我们创建一个表示栈的类，它主要包含 6 个方法。 方法名 作用 push(element) 添加一个新元素到栈顶 size() 返回栈中元素的个数 pop() 移除栈顶元素，同时返回被移除的元素 peek() 返回栈顶元素，不对栈做任何修改 isEmpty() 如果栈为空就返回true，否则返回false clear() 移除栈中所有的元素 代码实现如下： class Stack { constructor() { this.items = []; } push(element) { this.items.push(element); } pop() { return this.items.pop(); } peek() { return this.items[this.items.length - 1]; } isEmpty() { return this.items.length === 0; } clear() { this.items = []; } size() { return this.items.length; } } 基于 JavaScript 对象的栈\r我们也可以使用一个 JavaScript 对象来存储所有的栈元素，其中包含一个count属性来记录栈的大小。 class Stack { constructor() { this.count = 0; this.items = {}; } push(element) { this.items[this.count] = element; this.count++; } size() { return this.count; } isEmpty() { return this.count === 0; } pop() { if (this.isEmpty()) { return undefined; } this.count--; const result = this.items[this.count]; delete this.items[this.count]; return result; } peek() { if (this.isEmpty()) { return undefined; } return this.items[this.count - 1]; } clear() { this.items = {}; this.count = 0; } } 保护数据结构内部元素\r在创建别的开发者也可以使用的数据结构或对象时，我们希望保护内部的元素，只有我们暴露的方法才能修改内部结构。对于Stack类来说，要确保元素只会被添加到栈顶，而不是栈底或其他位置（如栈的中间）。我们在Stack类中声明的items和count属性并没有得到保护，因为 JavaScript 的类就是这样工作的。 执行下面代码。 const stack = new Stack(); console.log(Object.getOwnPropertyNames(stack)); // {1} console.log(Object.keys(stack)); // {2} console.log(stack.items); // {3} 行{1}和行{2}的输出结果都是[\"count\", \"items\"]。这表示count和items属性是公开的，我们可以像行{3}那样直接访问它们，并且可以对这两个属性赋予新的值。Stack类基于 ES6（ES","date":"2023-12-13","objectID":"/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:0:0","tags":["数据结构","算法","JavaScript","学习笔记"],"title":"学习JavaScript数据结构与算法","uri":"/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":["细读经典"],"content":"\r2023/11/23 更新: 增加 4 个练习项目——Parallax scroll animation、Voyage Slider、App Menu With Lock Screen 和 Old Film Effect 2023/12/13 更新: 增加练习项目——Polaroid Camera 2024/10/08 更新: 选择器增加来自@Shefali__J的选择器速查表 准备\r随书代码: https://github.com/CSSInDepth/css-in-depth Node.js: https://nodejs.org/en/ Visual Studio Code: https://code.visualstudio.com/ Git: https://git-scm.com/ 层叠、优先级和继承\r层叠\r当声明冲突时，层叠会依据三种条件解决冲突。 样式表的来源: 样式是从哪里来的，包括你的样式和浏览器默认样式。 选择器优先级: 哪些选择器比另一些选择器更重要。 源码顺序: 样式在样式表里的声明顺序。 选择器和声明块一起构成了规则集（ruleset）。一个规则集也简称一个规则。 @规则（at-rules）是指用@符号开头的语法，比如@import规则或者@media查询。 样式表的来源\r自己的样式表属于作者样式表，除此之外还有用户代理样式表，即浏览器默认样式。用户代理样式表优先级低，自己的样式会覆盖它们。 标记了!important的声明会被当作更高优先级的来源，因此总体的优先级按照由高到低排列如下所示: 作者的!important 作者 用户代理 理解优先级\r如果无法用来源解决冲突声明，浏览器会尝试检查它们的优先级。 浏览器将优先级分为两部分: HTML 的行内样式和选择器样式。 优先级的规则如下： 如果选择器的 ID 数量更多，则它会胜出。 如果 ID 数量一致，那么拥有更多类的选择器胜出。 如果以上两次比较都一致，那么拥有最多标签名的选择器胜出。 伪类选择器（如:hover）和属性选择器（如[type=\"input\"]）与一个类选择器的优先级相同。通用选择器（*）和组合器（\u003e、+、~）对优先级没有影响。 我们可以用优先级标记来比较不同选择器的优先级: 通常最好让优先级尽可能低，这样当需要覆盖一些样式时，才能有选择空间。 源码顺序\r如果两个声明的来源和优先级相同，其中一个声明在样式表中出现比较晚，或者位于页面较晚引入的样式表中，则该声明胜出。 两条经验法则\r在选择器中不要使用 ID。就算只用一个 ID，也会大幅度提升优先级。但需要覆盖整个选择器时，通常找不到另一个有意义的 ID，于是就会复制原来的选择器，然后加上另一个类，以区别想要覆盖的选择器。 不要使用!important。它比 ID 更难覆盖，一旦用了它，想要覆盖原先的声明，就需要加上一个!important，而且依然要处理优先级的问题。 继承\r只有特定的属性能被继承，通常是我们希望被继承的那些。它们主要是跟文本相关的属性: color font font-family font-size font-weight font-variant font-style line-height letter-spacing text-align text-indent text-transform white-space word-spacing 列表属性也可以被继承: list-style list-style-type list-style-position list-style-image 活用开发者工具了解具体情况: 特殊值\r有两个特殊值可以赋给任意属性，用户控制层叠: inherit和initial。 简写属性\rhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Shorthand_properties 相对单位\r相对单位会根据外部因素发生变化。例如，2em的具体值会更具它作用到的元素（有时甚至是根据属性）而变化。 相对单位的好处\r响应式: 能够根据浏览器窗口的大小有不同的“响应”。 em 和 rem\r在 CSS 中，1em等于当前元素的字号，其准确值取决于作用的元素。 浏览器会根据相对单位的值计算出绝对值，称作计算值（computed value）。 使用 em 定义字号\r如果声明font-size: 1.2em，这个font-size是根据继承的字号来计算的。 body { font-size: 16px; } .slogan { font-size: 1.2em; /* 19.2px */ padding: 1.2em; /* 23.04px */ } 字体缩小问题 body { font-size: 16px; } ul { font-size: .8em; } 会导致嵌套的列表字体越来越小。纠正方法如下: ul { font-size: .8em; } ul ul { font-size: 1em; } 使用 rem 设置字号\r根节点有一个伪类选择器（:root），可以用来选中它自己。这等价于类型选择器html，但html的优先级相当于一个类名，而不是标签。 rem是 root em 的缩写。rem 不是相当于当前元素，而是相对于根元素的单位。 :root { font-size: 1em; /* 使用浏览器的默认字号(16px) */ } ul { font-size: .8rem; /* 12.8px */ } 提示: 拿不准的时候，用 rem 设置字号，用 px 设置边框，用 em 设置其他大部分属性。 通过这种策略，可以轻松构建响应式面板: .panel { padding: 1em; border-radius: 0.5em; border: 1px solid #999; } .panel \u003e h2 { margin-top: 0; font-size: 0.8rem; font-weight: bold; text-transform: uppercase; } 使用媒体查询改变根元素的字号。这样就可以基于不同用户的屏幕尺寸，渲染出不同大小的面板。 :root { font-size: 0.75em; } @media (min-width: 800px) { /* 宽度800px以上 */ :root { font-size: 0.875em; } } @media (min-width: 1200px) { /* 宽度1200px以上 */ :root { font-size: 1em; } } 充分体现了使用em的优势。 视口的相对单位\r视口: 浏览器窗口中网页可见部分的边框区域。不包括浏览器的地址栏、工具栏、状态栏。 vh: 视口高度的 1/100 vw: 视口宽度的 1/100 vmin: 视口宽、高中较小一方的 1/100 vmax: 视口宽、高中较大一方的 1/100 使用 vw 定义字号\r给一个元素加上font-size: 2vw在一个 1200px 的显示器上计算值为 24px。在一个 768px 宽的平板上，计算值约为 15px。这样做的好处在于元素能够在这两种大小之间平滑地过渡， 这意味着不会在某个断点突然开始改变。当视口大小改变时，元素会逐渐过渡。 使用 calc()定义字号\rcalc()函数内可以对两个及其以上的值进行基本运算。支持的运算包括加减乘除。 :root { font-size: calc(0.5em + 1vw); } https://gist.github.com/basham/2175a16ab7c60ce8e001 自定义属性(即 CSS 变量)\r定义一个自定义属性: :root { --main-font: Helvetica, Arial, sans-serif; } p { font-family: var(--main-font); } 变量名用两个连字符用来和 CSS 属性区分。 变量必须在一个声明块内声明。这里用了:root选择器，所以可以在整个网页使用。 var()函数接受第二个参数，它指定了备用值。如果第一个参数指定的变量未定义，那么就会使用第二个值。 若 var()函数算出来的是一个非法值，对应的属性就会设置为其初始值。 动态改变自定义属性\r自定义属性的声明能够层叠和继承：可以再多个选择器中定义相同的变量，这个变量在网页的不同地方有不同的值。 如下所示: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003e导航\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"style.css\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003cheader class=\"page-header\"\u003e \u003ch1 class=\"title\" id=\"page-title\"\u003eWombat Coffe Roasters\u003c/h1\u003e \u003cnav\u003e \u003cul class=\"nav\" class=\"main-nav\"\u003e \u003cli\u003e\u003ca href=\"/\"\u003eHome\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/coffees\"\u003e","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:0:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["JavaScript"],"content":"在用 JavaScript 编程时，我们会经常用到数组对象，本文我们就来盘点一下那些好用的数组方法吧！😁 为了方便演示，我们先创建两个数组： const a = ['JavaScript', 'Php', 'Python', 'Ruby', 'C++', 'Node.js', 'Java', 'C++']; const b = [1, 3, 8, 16, 32, 48, 5]; every()\r首先，我们想知道数组a中的所有元素长度都是大于 4 的吗？对于这个数组的而言，结果是显然的。我们可以用如下的for循环得到问题的答案， let result = true; for (let i = 0; i \u003c a.length; i++\u003e){ if (a[i].length \u003c= 4){ result = false; break } } console.log(result); 结果如下： 但用for循环的方式多少显得有些麻烦，我们可以更加简洁地得到结果，那就是使用every()方法。 a.every(word =\u003e word.length \u003e 4); 通过传入一个箭头函数，就将问题解决啦，而且代码变得简洁清晰多了 😉。 some()\r接下来，我们想知道数组b中是否有大于 10 的元素呢？看起来这问题似乎有点傻，但…… 如果数组b中有 1 万个元素呢？ 我们同样可以使用for循环得到问题的答案： let result = false; for (let i = 0; i \u003c b.length; i++){ if (b[i] \u003e 10){ result = true; break; } } console.log(result); 我们还可以用some()方法， b.some(elem =\u003e elem \u003e 10); 如上所示，我们总是可以通过every()方法检测数组中所有元素都满足某种要求，而通过some()方法检测数组中是否有某个元素满足某种要求。 filter()\r我们已经知道数组a中并不是所有元素的长度都是大于 4 的，那么具体是哪些元素的长度大于 4 呢？有没有什么办法可以把它们都找到呢？ 老规矩，我们依旧可以用for循环。 let words = []; for (let i = 0; i \u003c a.length; i++){ if (a[i].length \u003e 4){ words.push(a[i]); } } console.log(words); 但我们还是推荐更加简短的filter()方法， a.filter(word =\u003e word.length \u003e 4); 结果如下： map()\r接下来，我们来做另外一件事，那就是给数组a中的每个元素后追加一个字符串“ is awesome!”，我们可以怎么做呢？——用map()方法。 a.map(word =\u003e word + \" is awesome!\"); forEach()\r如果我们想将数组a中长度大于 4 的元素每每追加一个字符串“ is awesome!”并依次打印输出怎么做？ 首先我们可以用filter()方法进行筛选，然后用map()方法进行追加，最后用forEach()方法进行迭代打印输出。 a.filter(word =\u003e word.length \u003e 4).map(word =\u003e word + \" is awesome!\").forEach(word =\u003e console.log(word)); 现在你可能发现了map()和filter()方法返回一个数组的好处了吧！😋 reduce()\r如果想将数组b进行求和运算该怎么做呢？——用reduce()方法。 reduce()方法的原型如下： array.reduce(reducer [, initialValue]) reducer为一个回调函数，以及可选初始化参数initialValue。reduce()方法会在每个数组元素上调用reducer()函数，reducer()函数返回一个累积的值，这个值在下一次调用reducer()函数时作为参数传入。 reducer()函数的原型如下： function reducer(accumulator, currentValue, currentIndex, array){} 回到给数组b进行求和的问题，代码如下： b.reduce((accu, curr) =\u003e accu + curr); includes()\r假如我们想知道数组中是否包含某个元素怎么整？比如，数组a包含Julia吗？ 当然，我们可以用之前学到过的some()方法， a.some(word =\u003e word === 'Julia'); 但还是推荐使用includes()方法： a.includes('Julia'); 无它，简明而已！ find()\rfilter()可以帮我们找到数组b中所有大于 8 的元素，但有时候我们要的不是所有，而是第一个。此时我们可以用find()方法。 b.find(elem =\u003e elem \u003e 8); findIndex()\r如果你对第一个元素（详见find()方法）不感兴趣，而是迫切想知道满足某条件的第一个元素的下标，那么可以用findIndex()方法。 b.findIndex(elem =\u003e elem \u003e 8); 总结\r本文介绍了 9 个能让我们代码更加简洁的数组方法，分别是every()，some()，filter()，map()，forEach()，reduce()，includes()，find()和findIndex()，希望能让给你带来一点启发。 推荐\r最后，推荐几个网站！ JavaScript Tutorial: https://www.javascripttutorial.net/ MDN Web Docs: https://developer.mozilla.org/en-US/ 感兴趣的同学可以去瞅瞅 😍。 参考\rhttps://www.w3schools.com/jsref/jsref_obj_array.asp ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:0:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"Axios是一个基于 Promise 的 HTTP 客户端，我们可以在浏览器和 Node.js 中使用它。Axios 使向 REST 端点发送异步 HTTP 请求和执行 CRUD 操作变得更加容易。它可以在纯 JavaScript 中使用，也可以在 Vue 或者 React 之类的库中使用。 先看一个在浏览器中使用 Axios 的例子，我们发送一个请求到https://api.github.com/users/USERNAME，以获取到用户的一些信息。 新建一个名为 1.html 的文件，代码如下： \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e\u003c/head\u003e \u003ctitle\u003eAxios\u003c/title\u003e \u003cbody\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"main.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e main.js 代码如下： axios.get(\"https://api.github.com/users/andyfree96\").then(response =\u003e { console.log(response.data); }).catch(error =\u003e { console.log(\"ERROR!\"); }); 启动服务器， 如果您没有安装http-server的话，请自行安装一下。 打开浏览器，就可以看到： 成功获取到用户信息。 之后的教程将在 Node.js 中使用 Axios，而不是在浏览器。 安装 Axios\r本文使用的 Node.js 版本是： 初始化一个 Node.js 应用， npm init -y 在命令行中输入npm i axios安装即可。 Axios 的响应对象\r当我们发送一个请求给服务器后，它会返回一个响应。Axios 的响应对象包含如下内容： data - 服务器返回的响应主体数据 status - 服务器返回的响应状态码 statusText - 返回的状态信息 headers - 返回的头部信息 config - 请求的配置信息 request - 请求对象 Axios 的 GET 请求\r我们以回调函数或者 async/await 的方式发送 Get 请求。 回调函数： const axios = require('axios'); axios.get('https://api.github.com/users/andyfree96').then((response) =\u003e { console.log(response.status); console.log(response.statusText); console.log(response.data); }); 结果如下： async/await： const axios = require('axios'); async function makeGetRequest() { let response = await axios.get('https://httpbin.org/get'); let data = response.data; console.log(data); console.log(response.request._header); } makeGetRequest(); 结果如下： Axios 的 HEAD 请求\rHEAD 请求是一个没有消息体的 GET 请求。 const axios = require('axios'); async function makeHeadRequest() { let response = await axios.head('http://www.baidu.com'); console.log(`status: ${response.status}`); console.log(`server : ${response.headers.server}`); console.log(response.headers); } makeHeadRequest(); Axios 有两个基本的 API： axios(config) axios(url, config) const axios = require('axios'); async function makeRequest() { const config = { method: 'get', }; const url = 'http://httpbin.org/get'; let response = await axios(url, config); console.log(response.data); } makeRequest(); Axios 自定义头部\rconst axios = require('axios'); async function makeRequest() { const config = { method: 'get', url: 'http://www.baidu.com', headers: { 'User-Agent': '5.js' }, }; let response = await axios(config); console.log(response.request._header); } makeRequest(); 这里我们自定义了一个请求头部： const config = { method: 'get', url: 'http://www.baidu.com', headers: { 'User-Agent': '5.js' }, }; Axios 的 POST 请求\rconst axios = require('axios'); async function makePostRequest() { let response = await axios.post('https://httpbin.org/post'); console.log(response.data); } makePostRequest(); 下载图片\rconst axios = require('axios'); const fs = require('fs'); async function getImage(url) { const config = { responseType: 'stream', }; let response = await axios.get(url, config); response.data.pipe(fs.createWriteStream('./image.png')); } getImage( 'https://himg.bdimg.com/sys/portraitn/item/856f6c656f73636f74743936f939' ); 我们在 config 对象中指明返回类型。 多个请求\r我们可以用 Axios 一次性创建多个请求。 const axios = require('axios'); async function makeRequests() { let [response1, response2] = await Promise.all([ axios.get('https://api.github.com/users/andyfree96'), axios.get('https://api.github.com/users/google'), ]); console.log(response1.data.created_at); console.log(response2.data.created_at); } makeRequests(); JSON Server\rJSON Server 是一个很棒的工具，可以让我们轻松地伪造 REST API。 我们先安装json-server: npm i -g json-server 创建一个名为 employees.json 的文件，添加如下内容： { \"employees\": [ { \"id\": 1, \"first_name\": \"Sebastian\", \"last_name\": \"Eschweiler\", \"email\": \"sebastian@codingthesmartway.com\" }, { \"id\": 2, \"first_name\": \"Steve\", \"last_name\": \"Palmer\", \"email\": \"steve@codingthesmartway.com\" }, { \"id\": 3, \"first_name\": \"Ann\", \"last_name\": \"Smith\", \"email\": \"ann@codingthesmartway.com\" } ] } 关于 JSON Server 创建 REST API 可以看下文。 Create A REST API With JSON Server: https://medium.com/codingthesmartway-com-blog/create-a-rest-api-with-json-server-36da8680136d 接下来我们可以启动 JSON Server， json-server --watch employees.json 访问http://","date":"2022-12-24","objectID":"/axios%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:0","tags":["JavaScript","Axios"],"title":"Axios简明教程","uri":"/axios%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["命令行"],"content":" 2024/11/12 更新: 推荐增加CLI tools you won’t be able to live without 🔧和40 个超有趣的 Linux 命令行彩蛋和游戏 在现代操作系统中，图形用户界面 (GUI) 让我们与计算机的交互变得直观和简单。然而，对于许多开发者、系统管理员和技术爱好者而言，Linux 命令行仍然是最为强大且不可替代的工具。通过它，我们能够精准地控制系统资源、自动化复杂任务，并快速处理各种系统操作。与 GUI 不同，命令行的操作不依赖于鼠标或其他外部设备，只需键入一行命令，便可在数秒内完成从文件管理到网络配置、从进程控制到系统监控等一系列操作。正因为其高效、灵活和可扩展性，Linux 命令行成为了技术专家首选的工作方式之一。本文，我们将逐步探索 Linux 命令行的基础知识，了解一些常用的命令，以及如何利用这些命令高效管理系统。无论你是新手还是经验丰富的用户，掌握这些命令都会让你在 Linux 世界中如鱼得水。 1. 文件管理\rfind\r语法\rfind [-H] [-L] [-P] [-Olevel] [-D debugopts] [path...] [expression] 列出当前目录\r使用不带参数和选项的find会列出当前目录下的所有文件及目录： find 搜索特定目录\r通过指定目录可以让find命令特定目录。 find ~/work 在指定目录中搜索特定文件\r有时，我们会想在某个指定目录下搜索特定文件名，例如： sudo find /etc -name \"ssh_config\" 模糊搜索\r如果想搜索系统中所有以.config为文件名结尾的文件的话，我们可以使用*通配符进行模糊搜索。 sudo find / -name \"*.config\" 指定搜索深度\r通过-maxdepth和-mindepth选项可以分别指定搜索时的最大和最小深度。 sudo find / -maxdepth 2 -name \"*.config\" 或操作符\r通过使用或操作符可以组合搜索结果，该操作符如下例中所示，用-o或-or选项表示。 sudo find / -maxdepth 2 -name \"*.config\" -o -name \"ssh\" 指定搜索类型\r通过-type选项，我们可以指定搜索文件类型，例如-type f搜索文件，-type d搜索目录： 指定搜索文件大小\r通过-size选项，我们可以指定搜索文件大小。比如，-size 10k表示搜索大小为10k的文件，-size +10k表示搜索大小超过10k的文件，-size -10k表示搜索大小少于10k的文件。 https://man7.org/linux/man-pages/man1/find.1.html 2. 文档编辑\rgrep\rgrep 是Global Regular Expression Print 的缩写，用于在指定文件中搜索字符串，它会打印匹配到的行。 语法\r使用语法如下： grep [OPTION]... PATTERN [FILE]... PATTERN表示搜索模式。 单个文件搜索\r如果我们想在log1文件中搜索andy这个模式，可以使用如下命令： grep andy log1 多个文件搜索\r若想在多个文件进行模式搜索，可以使用如下命令： grep andy log1 log2 搜索整个目录\rwork目录中只有两个文件，如果有成百上千个文件，显然不能上例一样指明目录下所有的文件名，此时我们可以使用*通配符来搜索整个当前目录： grep andy * 按单词搜索\r以上的例子没有把andy当作整个单词搜索，只要单词中匹配到andy这部分就会被搜索到。若想按单词搜索，使用-w选项即可。 grep -w andy * 忽略大小写\r使用-i选项可以让grep命令忽略大小写对模式进行搜索。 grep -iw andy * 反转搜索\r若想查看没有匹配到的行，我们可以使用-v选项： grep -iwv andy * 按行搜索\r通过-x选项可以让grep按行进行搜索： grep -xi andy * 搜索子目录\r目录中可能包含子目录，若想进一步在子目录进行搜索，可以使用-r选项： grep -rwi andy * 统计匹配数\r通过使用-c选项可以统计每个文件的匹配数。 grep -ci andy * https://man7.org/linux/man-pages/man1/grep.1.html How To Use grep Command In Linux/UNIX: https://phoenixnap.com/kb/grep-command-linux-unix-examples 3. 文件传输\r4. 磁盘管理\r5. 磁盘维护\r6. 网络通讯\rcurl\rcurl是一个用于与远端服务器进行信息交换的命令行工具。通过curl命令，可以十分方便地上传或者下载数据。本文我们将介绍如何在 Ubuntu 18.04.4 LTS 上使用curl命令。 安装\r在终端中输入： sudo apt update sudo apt install curl 即可安装。 语法\rcurl命令的语法如下： curl [options...] \u003curl\u003e \u003curl\u003e表示 URL 是必须的，而[options...]表示选项可以有多个或者零个。如果不带任何选项，对应 URL 的资源数据会在标准输出设备中输出。例如： curl http://www.baidu.com 如上所示，百度主页的源代码正常在屏幕上打印输出了。 保存输出至文件\r通常我们需要将请求的数据保存到文件中，此时可以使用-O或者-o选项。 curl -O https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js -O选项会使用远端服务器上的文件名作为保存到本地文本的文本名。如不希望这样的话，可以-o选项自定义本地文件的文件名。 curl -o andy.js https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js 下载多个文件\r有时，我们会需要多个文件，除了不断运行curl -O url1，curl -O url2……命令外，我们也可以使用如下方式： curl -O https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js -O https://cdn.jsdelivr.net/npm/async@3.2.0/dist/async.min.js 设置请求 User-Agent 字段\rHTTP 请求报文中有一个 User-Agent 头部字段，我们可以通过使用-A选项对其进行设置： curl -A \"andyfree\" 获取 HTTP 响应头\r通过-I选项，我们可以获取到 HTTP 响应报文的头部信息。 curl -I https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js 使用代理\r为了能顺利访问到资源，有时我们需要用到代理，使用-x选项即可： curl -x 127.0.0.1:8100 http://httpbin.org/ip 恢复下载\r在下载大文件时，由于持续时间会比较长，网络可能会因为某些原因断开，此时我们可以用-C选项恢复下载而不用从头下载。 curl -C - -O https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/20.10/ubuntu-20.10-desktop-amd64.iso https://curl.se/docs/manual.html 7. 系统管理\rps\rps命令是进程状态（Process Status）的缩写，能显示 Linux 系统当前运行进程的相关信息。 语法\rps命令的语法如下： ps [options] 当前 shell 运行的进程\r不带任何选项的ps命令会显示当前 shell 运行的进程： ps PID指的是进程号 TTY指的是用户登录的终端类型 TIME指的是进程运行的时间 CMD指的是启动进程的命令 列出所有进程\r使用-A或-e选项可以列出所有进程： ps -A ps -e 列出与特定用户相关的进程\r如果想列出与特定用户相关的进程，可以使用-u选项。 ps -u user 例如： ps -u ubuntu 显示所选列\r通过-o选项后指定的参数可以选择想要显示的列。 搜索进程\r配合grep命令，我们可以十分方便的对进程进行搜索。 ps -ef | grep python https://man7.org/linux/man-pages/man1/ps.1.html https://www.journaldev.com/24613/linux-ps-command https://www.geeksforgeeks.org/ps-command-in-linux-with-examples/ uname\r本节我们将介绍uname命令，该命令非常实用，可以打印输出系统相关信息。 语法\runame [OPTION]... 可选选项如下： -s, (--kernel-name)：打印输出内核名称 -n, (--nodename)：打印输出主机名（在网络中使用），此时输出和hostname命令一样 -r, (--kernel-release)：打印输出内核版本 -v, (--kernel-v","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:0:0","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["网络爬虫"],"content":"BeautifulSoup是啥？它是一个可以从 HTML 或 XML 文件中提取数据的 Python 库。它能通过我们喜欢的转换器实现文档导航，查找和修改。 安装 BeautifulSoup\r可以通过pip来安装，包的名字的是beautifulsoup4。 pip install -i https://pypi.douban.com/simple beautifulsoup4 安装解析器\rBeautifulSoup除了支持 Python 标准库中的 HTML 解析器之外，还支持一些第三方的解析器，比如lxml。可以按下列方式来安装 lxml： pip install -i https://pypi.douban.com/simple lxml 另一个可供选择的解析器是纯 Python 实现的html5lib，可以按下列方式来安装 html5lib： pip install -i https://pypi.douban.com/simple html5lib 下表列出了主要的解析器以及它们的优缺点： 如何使用\r将一段文档传入BeautifulSoup的构造方法就能得到一个文档对象，可以传入一段字符串或一个文件句柄。 from bs4 import BeautifulSoup soup = BeautifulSoup(open(\"index.html\")) suop = BeautifulSoup(\"\u003chtml\u003edata\u003c/html\u003e\") 如果手动指定解析器的话，BeautifulSoup会选择指定的解析器来解析文档。 对象的种类\rBeautifulSoup将复杂的 HTML 文档转换成一个复杂的树形结构，每个节点都是 Python 对象，所有对象可以归纳为 4 中：Tag，NavigableString，BeautifulSoup，Comment。 Tag\rTag对象与 XML 或 HTML 文档中的 tag 相同： from bs4 import BeautifulSoup soup = BeautifulSoup('\u003cb class=\"boldest\"\u003eExtremely bold\u003c/b\u003e') tag = soup.b type(tag) # \u003cclass 'bs4.element.Tag'\u003e Tag有很多方法和属性，比如遍历文档树和搜索文档树。现在介绍一下 tag 中最重要的属性：name和attributes。 Name\r每个 tag 都有自己的名字，通过.name来获取： tag.name # 'b' 如果改变 tag 的 name 将会影响所有通过当前BeautifulSoup对象生成的 HTML 文档： tag.name = \"blockquote\" tag # \u003cblockquote class=\"boldest\"\u003eExtremely bold\u003c/blockquote\u003e tag.name = \"ironman\" tag # \u003cironman class=\"boldest\"\u003eExtremely bold\u003c/ironman\u003e Attributes\r一个 tag 可能有很多个属性。tag \u003cb class=\"boldest\"\u003e有一个名为class的属性，值为boldest。tag 的属性的操作方法与字典相同： tag['class'] # ['boldest'] 也可以直接.取属性，比如：.attrs： tag.attrs # {'class': ['boldest']} tag 的属性可以被添加，删除或修改，和字典一样。 In [13]: tag['class'] Out[13]: ['boldest'] In [14]: tag['class'] = 'verybold' In [15]: tag['id'] = 1 In [16]: tag Out[16]: \u003cironman class=\"verybold\" id=\"1\"\u003eExtremely bold\u003c/ironman\u003e In [17]: del tag['class'] In [18]: del tag['id'] In [19]: tag Out[19]: \u003cironman\u003eExtremely bold\u003c/ironman\u003e In [20]: tag['class'] KeyError In [21]: tag.get('class') 多值属性\rHTML 定义了一系列可以包含多个值的属性。最常见的多值属性是class（一个 tag 可以有多个 CSS 的class）。在BeautifulSoup中多值属性的返回类型是 list： In [22]: css_soup = BeautifulSoup('\u003cp class=\"body strikeout\"\u003e\u003c/p\u003e') In [23]: css_soup.p['class'] Out[23]: ['body', 'strikeout'] 如果某个属性看起来好像有多个值，但在任何版本的 HTML 定义中都没有被定义为多值属性，那么BeautifulSoup会将这个属性作为字符串返回 In [25]: id_soup = BeautifulSoup('\u003cp id=\"my id\"\u003e\u003c/p\u003e') In [26]: id_soup.p['id'] Out[26]: 'my id' NavigableString\r字符串常被包含在 tag 内。BeautifulSoup用NavigableString类来包装 tag 中的字符串： In [27]: tag Out[27]: \u003cironman\u003eExtremely bold\u003c/ironman\u003e In [28]: tag.string Out[28]: 'Extremely bold' In [29]: type(tag.string) Out[29]: bs4.element.NavigableString NavigableString 对象支持遍历文档树和搜索文档树中定义的大部分属性, 并非全部。 BeautifulSoup\rBeautifulSoup对象表示的是整个文档的内容。大部分时候，可以把它当作Tag对象，它支持遍历文档树和搜索文档树中定义的大部分方法。 Comment\rTag，NavigableString，BeautifulSoup几乎覆盖了 html 和 xml 中的所有内容，但是还有一些特殊对象。 In [30]: markup = \"\u003cb\u003e\u003c!--Hey, buddy. Want to buy a used parser?--\u003e\u003c/b\u003e\" In [31]: soup = BeautifulSoup(markup, 'lxml') In [32]: comment = soup.b.string In [34]: type(comment) Out[34]: bs4.element.Comment Comment对象是一个特殊类型的NavigableString对象。 soup = BeautifulSoup(markup, 'lxml')中的lxml用于指定解析器。 搜索文档树\rBeautifulSoup定义了很多搜索方法，这里着重介绍 2 个：find_all()和select()。 以“爱丽丝”文档作为例子： In [40]: html_doc = \"\"\" ...: \u003chtml\u003e\u003chead\u003e\u003ctitle\u003eThe Dormouse's story\u003c/title\u003e\u003c/head\u003e ...: ...: \u003cp class=\"title\"\u003e\u003cb\u003eThe Dormouse's story\u003c/b\u003e\u003c/p\u003e ...: ...: \u003cp class=\"story\"\u003eOnce upon a time there were three little sisters; and their names were ...: \u003ca href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"\u003eElsie\u003c/a\u003e, ...: \u003ca href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"\u003eLacie\u003c/a\u003e and ...: \u003ca href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"\u003eTillie\u003c/a\u003e; ...: and they lived at the bottom of a well.\u003c/p\u003e ...: ...: \u003cp class=\"story\"\u003e...\u003c/p\u003e ...: \"\"\" In [41]: from bs4 import BeautifulSoup In [42]: soup = BeautifulSoup(html_doc, 'lxml') 使用find_all()类似的方法可以查找到想要查找的文档内容。 过滤器\r在介绍find_all()方法之前，先介绍一下过滤器的类型，这些过滤器贯穿整个搜索的 API。过滤器可以被用在 tag 的 name 中，节点的属性中，字符串中或它们的混合中。 字符串\r最简单的过滤器是字符串。在搜索方法中传入也给字符串参数，BeautifulSoup会查找与字符串完整匹配的内容，下面的例子用于查找文档中所有\u003cb\u003e标签： In [43]: soup.find_all('b') Out[43]: [\u003cb\u003eThe Dormouse's story\u003c/b\u003e] 正则表达式\r如果传入正则表达式作为参数，","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:0:0","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":" 2024/11/06 更新: 修改JSON 响应内容、定制请求头、POST 请求中的代码以及图片 我们可以使用 Python 内置的 urllib 包来请求网络资源。它用起来比较麻烦，而且缺少很多实用的高级功能。本文我们将会介绍一个更加方便的 Python 第三方库——Requests 的使用。 安装 Requests\r要安装Requests，只要在终端中运行这个简单命令即可： pip install -i https://pypi.douban.com/simple requests 安装好Requests后，就可以开始尝试使用它啦！ 发送请求\r使用Requests发送网络请求非常简单。导入Requests模块： import requests 然后获取某个网页。我们来获取 Github 的公共时间线： r = requests.get('https://api.github.com/events') 现在，有了一个名为r的Response的对象。我们可以从这个对象中获取所有我们想要的信息。 传递 URL 参数\r我们可能会想用 URL 的查询字符串传递某种数据。如果是手动构建 URL，那么数据会以键值对的形式置于 URL 中，跟在一个问号的后面。例如，http://httpbin.org/get?key=val。Requests允许我们使用params关键字参数，以一个字符串字典来提供这些参数。举例来说，如果想传递key1=value1和key2=value2到http://httpbin.org/get，那么可以使用如下代码： import requests payload = {'name':'anthony', 'cat':'ruby'} r = requests.get('http://httpbin.org/get', params=payload) 打印输出该 URL，能看到 URL 已被正确编码： print(r.url) # http://httpbin.org/get?name=anthony\u0026cat=ruby 响应内容\r我们能读取服务器响应内容。举个例子： import requests r = requests.get(\"http://httpbin.org/get\") print(r.text) 输出内容如下： Requests会自动节码来自服务器的内容。大多数 unicode 字符集都能被无缝地解码。 请求发出后，Requests会基于 HTTP 头部对响应的编码作出有根据的推测。当访问r.text时，Requests会使用其推测的文本编码。我们可以找出Requests使用了什么编码，并且能够使用r.encoding属性来改变它： import requests r = requests.get(\"http://httpbin.org/get\") print(r.encoding) r.encoding = 'utf-8' print(r.encoding) 如果改变了编码，每当访问r.text，Requests都将会使用r.encoding的新值。 二进制响应内容\r对于非文本请求，也能以字节的方式访问请求响应体。例如，以请求返回的二进制数据创建一张图片，可以使用如下代码： import requests from PIL import Image from io import BytesIO r = requests.get(\"https://github.com/fluidicon.png\") im = Image.open(BytesIO(r.content)) im.show() JSON 响应内容\rRequests中有一个内置的 JSON 解码器，帮助我们处理 JSON 数据： import requests from pprint import pprint payload = {'name':\"anthony\", 'cat':'ruby'} r = requests.get(\"http://httpbin.org/get\", params=payload) pprint(r.json()) 定制请求头\r如果想为请求添加 HTTP 头部，只要简单地传递一个dict给headers参数就可。 import requests from pprint import pprint headers = {'User-Agent': 'anthony-agent'} r = requests.get(\"http://httpbin.org/get\", headers=headers) pprint(r.json()) 如下图所示，User-Agent字段的值已被更改为anthony-agent。 POST 请求\r通常，我们会想要发送一些编码为表单形式的数据——非常像一个 HTML 表单。要实现这个，只需要简单地传递一个字典给data参数。字典数据在发出请求时会自动编码为表单形式： import requests payload = {\"name\":\"anthony\", \"actor\":\"peter\"} r = requests.post(\"http://httpbin.org/post\", data=payload) print(r.text) 还可以给data参数传入一个元组列表。在表单中多个元素使用同一 key 的时候，这种方式很有用： import requests payload = [(\"name\",\"anthony\"), (\"actor\",\"peter\"),(\"actor\",'marry')] r = requests.post(\"http://httpbin.org/post\", data=payload) print(r.text) 响应状态码\r我们可以查看响应状态码： import requests r = requests.get(\"http://httpbin.org/get\") print(r.status_code) # 200 为了方便使用，Requests附带了也给内置的状态码查询对象： r.status_code == requests.codes.ok # True 如果发送了一个错误请求(一个 4XX 客户端错误，或 5XX 服务器错误响应)，我们可以通过Response.raise_for_status()来抛出异常： In [1]: import requests In [2]: bad_r = requests.get('http://httpbin.org/status/404') In [3]: bad_r.status_code Out[3]: 404 In [4]: bad_r.raise_for_status() --------------------------------------------------------------------------- HTTPError Traceback (most recent call last) \u003cipython-input-4-cdf6910f7d4c\u003e in \u003cmodule\u003e() ----\u003e 1 bad_r.raise_for_status() c:\\python\\lib\\site-packages\\requests\\models.py in raise_for_status(self) 927 928 if http_error_msg: --\u003e 929 raise HTTPError(http_error_msg, response=self) 930 931 def close(self): HTTPError: 404 Client Error: NOT FOUND for url: http://httpbin.org/status/404 但由于我们的例子中r的status_code是 200，当我们调用raise_for_status()时，得到的是： In [6]: r.raise_for_status() # None 响应头\r我们可以查看以字典形式的服务器响应头： In [7]: r.headers Out[7]: {'Access-Control-Allow-Credentials': 'true', 'Access-Control-Allow-Origin': '*', 'Content-Encoding': 'gzip', 'Content-Type': 'application/json', 'Date': 'Thu, 03 Oct 2019 07:11:16 GMT', 'Referrer-Policy': 'no-referrer-when-downgrade', 'Server': 'nginx', 'X-Content-Type-Options': 'nosniff', 'X-Frame-Options': 'DENY', 'X-XSS-Protection': '1; mode=block', 'Content-Length': '184', 'Connection': 'keep-alive'} Cookie\r如果某个响应中包含一些 cookie，可以快速访问它们： In [19]: r = requests.get('https://www.baidu.com') In [20]: r.cookies Out[20]: \u003cRequestsCookieJar[Cookie","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:0:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["数据科学"],"content":"在数据科学和分析领域，图表不仅是展示数据的工具，更是讲故事的语言。Matplotlib 是 Python 中历史最悠久且功能最全面的绘图库。无论你是想画一个简单的折线图，还是需要定制复杂的多图布局，Matplotlib 都能满足你的需求。这篇文章将带你快速上手，学会用代码画出数据的价值。 创建图与图表是很多分析项目中的一个重要步骤，它通常是项目开始时探索性数据分析（EDA）的一部分，或者在项目报告阶段向其他人介绍你的数据分析结果时使用。 matplotlib 是一个绘图库，创建的图形可达到出版的质量要求。它可以创建常用的统计图，包括条形图、箱线图、折线图、散点图和直方图等等图形。matplotlib 提供了对图形各个部分进行定制的功能。例如，它可以设置图形的形状和大小、x 轴与 y 轴的范围和标度、x 轴和 y 轴的刻度线和标签、图例以及图形的标题。更多关于定制图形的信息请查看：https://matplotlib.org/users/beginner.html 。 下面，我们就开始学习一些常见图形的绘制，使用的数据来自The Complete Pokemon Dataset。 先将数据导入， import numpy as np import pandas as pd import matplotlib.pyplot as plt plt.style.use('ggplot') %matplotlib inline data = pd.read_csv('../../Datasets/pokemon.csv') data.head() 数据每一列的含义如下， 条形图\r假如我们想查看一下每一代 Pokemon 的数量，并用条形图显示出来，该怎么办呢？ generation = data['generation'].value_counts() plt.bar(generation.index, generation.values) 可以看到如下结果： 如果我们想添加轴标签和标题的话，加上如下内容即可： plt.xlabel('generation') plt.ylabel('count') plt.title('Generation and Count') 为了方便起见，我们也可以为每个条加上数值标签， for x,y in enumerate(generation.values): plt.text(x+1,y,'%s' % y,ha='center') matplotlib.pyplot.bar函数详情： matplotlib.pyplot.bar(x, height, width=0.8, bottom=None, *, align='center', data=None, **kwargs) x: 指定图形横轴坐标 height: 指定条形图的高度 width: 指定条形图的宽度 color: 指定条形图前景色 edgecolor: 设置条形图边界颜色 linewidth: 设置条形图边界宽度 更多内容请查看：https://matplotlib.org/api/_as_gen/matplotlib.pyplot.bar.html 知道了上述参数的含义之后，我们就可以对之前的图形进行小小的改动啦！ generation = data['generation'].value_counts() plt.bar(generation.index, generation.values, facecolor='orange',edgecolor='green', linewidth=2) plt.xlabel('generation') plt.ylabel('count') plt.title('Generation and Count') for x,y in enumerate(generation.values): plt.text(x+1,y,'%s' % y,ha='center') 箱线图\r箱线图一般用来展示数据的分布（如上下四分位数、中位数等），同时，也可以用来反映数据的异常情况。 box = data[['defense','attack','hp']] plt.boxplot(box.values) plt.setp(plt.gca(),xticklabels=['defense','attack','hp']) matplotlib.pyplot.boxplot函数详情： matplotlib.pyplot.boxplot(x, notch=None, sym=None, vert=None, whis=None, positions=None, widths=None, patch_artist=None, bootstrap=None, usermedians=None, conf_intervals=None, meanline=None, showmeans=None, showcaps=None, showbox=None, showfliers=None, boxprops=None, labels=None, flierprops=None, medianprops=None, meanprops=None, capprops=None, whiskerprops=None, manage_xticks=True, autorange=False, zorder=None) x: 指定绘图的数据 notch: 是否是凹口的形式展示箱线图，默认为非凹口 sym: 指定异常点的形状 vert: 是否需要将图形垂直摆放，默认为垂直摆放 whis: 指定上下须与上下四分位数的距离，默认为 1.5 倍的四分位差 positions: 指定图形的位置，默认为[0,1,2……] widths: 指定图形的宽度，默认为 0.5 patch_artist: 是否填充箱体的颜色 meanline: 是否用线表示均值，默认用点表示 showmeans: 是否显示均值，默认不显示 showcaps: 是否显示图形顶端和末端的两条线，默认显示 showbox: 是否显示图形的箱体，默认显示 showfliers: 是否显示异常值，默认显示 boxprops: 设置箱体的属性，如边框色、填充色等 labels: 指定箱线图的标签 filerprops: 设置异常值的属性，如异常点的形状、大小等 medianprops: 设置中位数的属性，如线的类型、粗细等 meanprops: 设置均值的属性，如点的大小、颜色等 capprops: 设置图形顶端和末端线条的属性，如颜色、粗细等 whiskerprops: 设置须得属性，如颜色、粗细等 更多内容请查看：https://matplotlib.org/api/_as_gen/matplotlib.pyplot.boxplot.html 折线图\r我们不妨查看一下每一代 Pokemon 攻击力的走势， generation_attack = data.pivot('name', 'generation', 'attack').fillna(0) for col in generation_attack.columns: gene = generation_attack[generation_attack[col] \u003e 0][col].sort_values() plt.plot(range(gene.shape[0]),gene.values,label=col) plt.legend() plt.ylabel('Attack') matplotlib.pyplot.plot函数详情： matplotlib.pyplot.plot(*args, scalex=True, scaley=True, data=None, **kwargs) x: x 轴数据 y: y 轴数据 fmt: 格式化字符串 更多内容请查看：https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html 散点图\r将防御力和攻击力用散点图绘制出来， plt.scatter(data['attack'], data['defense']) plt.xlabel('attck') plt.ylabel('defense') matplotlib.pyplot.scatter函数详情： matplotlib.pyplot.scatter(x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, verts=None, edgecolors=None) x: 指定数据横坐标 y: 指定数据纵坐标 s: 指定标记大小 c: 指定标记颜色 marker: 设置标记样式 alpha: 设置透明度 linewidths: 设置标记边缘的线宽 edgecolors: 设置标记边缘的颜色 更多内容请查看：https://matplotlib.org/api/_as_gen/matplotlib.pyplot.scatter.html 直方图\r将防御力的分布用直方图绘制， plt.hist(data['defense'],bins=25) plt.xlabel('Defense') plt.ylabel('Frequency') matp","date":"2021-04-27","objectID":"/matplotlib%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:0","tags":["Python","Matplotlib","数据分析","数据可视化","数据科学"],"title":"Matplotlib简明教程","uri":"/matplotlib%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"众所周知，Pandas 是最受欢迎的 Python 数据科学与分析库。Numpy 用于较低级别的科学计算。Pandas 构建于 Numpy 之上，专为实际数据分析而设计。本文总结了一些常见、方便的功能。话不多说，让我们开始吧！ 数据集\r数据是数据科学与分析的“命根子”，我们需要从数据中寻找答案，从数据中发现模式……如果没有数据的话，就无从谈起。数据获取的方式有很多种，这里分享一些提供数据的平台。 pandas-videos：https://github.com/justmarkham/pandas-videos UCI Machine Learning Reposity：https://archive.ics.uci.edu/datasets 导入数据\r任何的数据分析工作都是从导入数据开始，Pandas提供了很多导入数据的方法。 pd.read_csv(filename) # From a CSV file pd.read_table(filename) # From a delimited text file (like TSV) pd.read_excel(filename) # From an Excel file pd.read_sql(query, connection_object) # Reads from a SQL table/database pd.read_json(json_string) # Reads from a JSON formatted string, URL or file pd.read_html(url) # Parses an html URL, string or file and extract tables to a list of dataframes pd.read_clipboard() # Takes the contents of your clipboard and passes it to read_table() pd.DataFrame(dict) # From a dict, keys for columns names, values for data as lists 不妨举个例子，我们想分析一下 IMDB 高分电影，经过一番搜索，发现 https://raw.githubusercontent.com/justmarkham/pandas-videos/master/data/imdb_1000.csv 上的数据就不错， 若想把它导入，使用pd.read_csv方法就行啦！ 具体来说，就是： dataURL = 'https://raw.githubusercontent.com/justmarkham/pandas-videos/master/data/imdb_1000.csv' df = pd.read_csv(dataURL) df.head() # Prints first 5 rows of the DataFrame 关于上述导入数据方法的更多详细内容，请查看IO Tools。 探索数据\r一旦将数据导入到 DataFrame 中之后，就可以用以下方法来了解数据的情况。 df.index # Index Description df.columns # Columns in the DataFrame df.shape # Prints number of row and columns in DataFrame df.head(n) # Prints first n rows of the DataFrame df.tail(n) # Prints last n rows of the DataFrame df.info() # Index, DataType and Memory information df.describe() # Summary statistics for numerical columns s.value_counts(dropna=False) # Views unique values and counts df.apply(pd.Series.value_counts) # Unique value and counts for all columns df.mean() # Returns the mean of all columns df.corr() # Returns the correlation between columns in a DataFrame df.count() # Returns the number of non-null values in each DataFrame column df.max() # Returns the highest value in each column df.min() # Returns the lowest value in each column df.median() # Returns the median of each column df.std() # Returns the standard deviation of each column df.idxmax() # Index of the lowest value df.idxmin() # Index of the highest value 举个例子，在导入 IMDB 高分电影数据后统计一下每种电影类型的频数，我们就可以用: df['genre'].value_counts() 选择\r通常，我们可能需要选择单个元素或者数据的某个子集来进行深入分析。那么，这些方法就会大显身手： df[col] # Returns column with label col as Series df[[col1, col2]] # Returns columns as a new DataFrame s.iloc[0] # Selection by position (selects first element) s.loc[0] # Selection by index (selects element as index 0) df.iloc[0, :] # First row df.iloc[0, 0] # First element of first column df.iat[0, 0] # First element of first column. Access a single value for row/column pair by integer position df.at[row_label, col_label] # Access a single value for row/column label pair 更多内容，请查看Indexing and Selecting Data。 数据清理\r实际上，我们拿到数据后，往往需要清理它。以下就是一些非常有用的方法： df.columns = ['a', 'b', 'c'] # Renames columns pd.isnull() # Checks for null values, return Boolean Array pd.notnull() # Opposite of pd.isnull() df.dropna() # Drops all rows that contain null values df.dropna(axis=1) # Drops all columns that contain null values df.dropna(axis=1, thresh=n) # Drops all rows hava less than non null values df.fillna(x) # Replaces all null values with x s.fillna(s.mean()) # Replaces all null values with the mean s.astype(float) # Converts the datatype of the series to float s.replace(1, 'one') # Replaces all values equal to 1 with 'one' s.replace([1, 3], ['one', 'three']) # Replace all 1 with 'one' and 3 with 'three' df.rename(columns=lambda x: x + 1) # Mass renaming of columns df.rename(columns={'old_name': 'new_name'}) # Selective renaming df.set_index('column_one') # Changes the index df.rename(index=lambda x: x + 1) # Mass renaming of index df.drop(labels) # Drop specified labels from rows or columns df.drop_duplicates(subset) # Return DataFrame with duplicate rows removed, optio","date":"2021-01-27","objectID":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:0","tags":["Python","Pandas","数据分析","数据科学"],"title":"Pandas简明教程","uri":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["OpenCV"],"content":"在人工智能飞速发展的时代，计算机视觉已成为一门热门技术，而 OpenCV（Open Source Computer Vision Library）则是实现这一技术的重要工具。作为一个开源的跨平台计算机视觉与机器学习软件库，OpenCV 拥有丰富的功能，涵盖从基础的图像处理到复杂的视觉算法实现。本文将带你一步步探索 OpenCV 的世界：从简单的图像操作入门，到实现高效的计算机视觉应用，无论你是初学者还是有经验的开发者，都能找到适合你的内容。准备好了吗？让我们一起开启 OpenCV 的奇妙旅程！ 环境搭建\r如何在 Visual Studio 项目中使用 OpenCV？本文将作完整介绍。 本文使用的环境是： Windows 10 Visual Studio Community 2019 下载并解压预构建的库\r截至到 2021 年 1 月 9 日的最新版本是 4.5.1 (opencv-4.5.1-vc14_vc15.exe)，该版本的 exe 文件可以在https://github.com/opencv/opencv/releases/下载，本文使用的是之前下载的4.5.0版本。 当下载完成后，运行下载的.exe 文件以解压缩存档。 提取结束后可以看到 F 盘下新增了一个 opencv 目录： 添加环境变量\r将F:\\opencv\\build\\x64\\vc15\\bin目录添加到环境变量中， 创建项目\r在 Visual Studio 中创建一个新项目： 这里选择的是Console App。 然后，将平台目标设置为 x64。因为预构建的二进制文件是为 x64 Windows 平台构建的。 之后，选择菜单栏【Project】下的【项目名 Properties】： 然后，找到【VC++ Directories】这一项，将其中的【Include Directories】和【Library Directories】两项的进行对应的添加。 具体添加操作如下： 最后，找到【Linker】下的【Input】这一项，将其中的【Additional Dependencies】添加(具体操作如上图所示)opencv_world450d.lib。 opencv_world450d.lib文件我们可以在F:\\opencv\\build\\x64\\vc15\\lib目录找到。 预备工作到此就结束了，接下来我们可以编写代码啦！😂 示例\r这里我们做一个简单的示例，将一张本地的图片在窗口上显示出来，代码如下： #include \u003ciostream\u003e #include \u003copencv2/core/core.hpp\u003e #include \u003copencv2/highgui/highgui.hpp\u003e #include \u003copencv2/imgproc.hpp\u003e using namespace std; using namespace cv; int main() { Mat image = imread(\"F:/avatar.jpeg\"); if (image.empty()) { cout \u003c\u003c \"Could not open or find the image\" \u003c\u003c endl; system(\"pause\"); return -1; } String windowName = \"My Window\"; imshow(windowName, image); waitKey(0); return 0; } 编译运行结果如下： 想了解更多关于 OpenCV 的内容的话，请移步OpenCV Tutorials OpenCV 库分为多个模块：opencv_core 模块包含库的核心功能，opencv_imgproc 模块包含主要的图像处理函数，opencv_highgui 模块提供读写图像和视频的函数以及一些用户交互函数，等等。在使用某个模块时，需要包含该模块对应的头文件。例如： #include \u003copencv2/core.hpp\u003e #include \u003copencv2/imgproc.hpp\u003e #include \u003copencv2/highgui.hpp\u003e OpenCV 是用来处理图像的，接下来演示一下如何从文件中加载图像、在窗口中显示图像、使用处理函数再保存输出的图像。 加载、显示和存储图像\r首先在 Visual Studio 中创建一个可以使用 OpenCV 的项目，具体可以参考在 Visual Studio 项目中使用 OpenCV一文。 加载、显示图像的示例如下： #include \u003copencv2/core.hpp\u003e #include \u003copencv2/highgui.hpp\u003e #include \u003copencv2/imgproc.hpp\u003e #include \u003ciostream\u003e int main() { cv::Mat image; std::cout \u003c\u003c \"Image shape is : \" \u003c\u003c image.rows \u003c\u003c \" x \" \u003c\u003c image.cols \u003c\u003c std::endl; image = cv::imread(\"F:/avatar.jpeg\"); if (image.empty()) { std::cout \u003c\u003c \"Could not open or find the image\" \u003c\u003c std::endl; return -1; } std::cout \u003c\u003c \"Image shape is : \" \u003c\u003c image.rows \u003c\u003c \" x \" \u003c\u003c image.cols \u003c\u003c std::endl; cv::namedWindow(\"Window 1\"); cv::imshow(\"Window 2\", image); cv::waitKey(0); return 0; } 在 OpenCV 的 C++ API 中，所有类和函数都在命名空间 cv 内定义。我们创建了一个Mat对象 image，其初始化尺寸为cols=0, rows=0，可以通过访问 image 对象的cols和rows属性来了解其尺寸。 通过调用imread()函数，传入图像路径字符串，该函数会读入一个图像，解码分别配内存并返回一个Mat对象。 现在可以使用这副图像了，但是要先检查一下图像的读取是否正确（如果找不到文件、文件被破坏或者文件格式无法识别，就会发生错误）。可以使用Mat对象的empty()方法，如果没有分配图像数据该方法会返回true。 接下来将该图像显示出来，可以用 highgui 模块的函数来实现。首先定义显示图像的窗口，然后让图像在指定的窗口中显示出来。namedWindow(\"Window 1\")函数会创建一个名为Window 1的窗口。imshow(\"Window 2\", image)会创建一个名为Window 2的窗口，并将image对象在其中显示。 因为是控制台程序，main()函数结束时会关闭，所以我们使用了一个额外的highgui函数，待用户按键后再结束程序。waitKey(0)函数传入正数表示等待的毫秒数，0 表示永远地等待按键。 运行结果如下： 可以使用flip()函数将图像翻转，我们用一个新的矩阵存放翻转输出结果。 cv::Mat result; cv::flip(image, result, 1); // 0上下翻转; 正数左右翻转; 负数上下和左右翻转 绘制函数\rOpenCV 提供了几个用于在图像上绘制形状和写入文本的函数。基本的形状绘制函数有circle，ellipse，line和rectangle。 我们来看一个绘制圆形的例子： cv::circle(image, cv::Point(image.cols / 2, image.rows / 2), 65, 0, 3); 该函数的原型如下： 又或者绘制一个矩形： cv::rectangle(image, cv::Rect(10, 10, 25, 35), 0, 3); 该函数的原型如下： cv::Mat\rcv::Mat类是用来存放图像（以及其他矩阵数据）的数据结构。在所有 OpenCV 类和函数中，这个数据结构占据核心地位。 cv::Mat有两个组成部分：一个头部和一个数据块。头部包含了矩阵的所有相关信息（大小、通道数、数据类型），我们可以通过如cols、rows和channels等属性访问头部信息。数据块包含了图像所有的像素值。头部有一个指向数据块的指针，即data属性。cv::Mat有一个很重要的属性，即只有明确要求时，内存块才会被复制。 新创建的cv::Mat对象默认大小为 0，但也可以指定初始大小，例如： cv::Mat image1(240, 320, CV_8U, 100); 需要指定每个矩阵元素的类型，这里用的是CV_8U，表示每个像素对应 1 字节（灰度图像），字母U表示无符号数；也可以用S表示有符号数。对于彩色图像，该用三通道类型CV_8UC3，也可以定义 16 位和 32 位的整数（有符号或无符号），例如CV_16SC3。 图像（或矩阵）的每个元素都可以包含多个值（例如彩色图像中的三个通道），因此 OpenCV 引入了一个简单的数据结构cv::Scaler，用于在调用函数时传递像素值。 例如创建一个彩色图像并用红色像素初始化： // 创建一个红色图像 // 通道次序是BGR cv::Mat image2(240, 320, CV_8UC3, cv::Scaler(0, 0, 255)); 更多创建方式： // 创建灰度图像 cv::Mat image3(240, 320, CV_8U, cv::S","date":"2020-12-12","objectID":"/opencv%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/:0:0","tags":["OpenCV","C++"],"title":"OpenCV从入门到实战","uri":"/opencv%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"},{"categories":["工具使用"],"content":"在当今互联网环境中，保护网络隐私和确保数据安全变得尤为重要。ShadowsocksR（SSR）作为一种高效的代理工具，凭借其出色的加密性能和灵活的配置，成为了许多人突破网络限制、保护隐私的首选工具。本文将详细介绍如何在亚马逊云（AWS）平台上配置 ShadowsocksR，帮助你轻松搭建一个稳定的代理服务，以便在全球范围内实现安全的网络访问。 创建实例\r要使用亚马逊云服务，需要注册一个账号。去亚马逊云官网：https://amazonaws-china.com/cn 进行注册。 注册成功后，再次访问上述网站 选择 AWS 管理控制台，输入账号、密码进行登录。 登录后，右上角选择一个合适的地区 然后，在左上角的服务中选择 EC2 新打开的页面中，有一个启动实例的选项 点击启动实例，进入到 Amazon 系统映像选择，这里我选择的是Ubuntu Server 16.04 LTS（记得选免费套餐）。 点击选择选项，进入到选择实例类型选项，仍然选择免费套餐 点击审核和启动。接下来是核查实例启动，直接点击启动即可。 然后会出现一个，选择现有密钥对或创建新密钥对的弹窗。这里我选择创建新密钥对 之后点击下载密码对，会下载一个扩展名为pem的文件，这里我的密钥对名称是viljw，所以下载的文件名为viljw.pem。下载后，启动实例。 回到 EC2 首页，可以看到创建的实例已经启动了 点击正在运行的实例，就可以看到公有 DNS，公有 IP，实例状态等等信息。 使用 XShell 连接\r打开 Xshell，选择工具选项中的用户密钥管理者 在弹出的对话框中导入之前下载的pem文件 导入成功后，新建连接，输入名称（随便填），协议 SSH，主机（EC2 实例的公有 IP），端口 22 上述信息填完后，不要点击确定，点击用户身份验证选项 方法选择Public Key，用户名填ubuntu（根据之前的选择的 EC2 实例映像类型），点击确定即可连接成功。 修改 EC2 防火墙配置\r亚马逊云 EC2 防火墙入站配置默认只开启了 22 端口的流量，为了之后 ShadowsocksR 的使用，我们可以更改该配置，把协议和端口范围都改成全部或只开启某个特定端口。 在实例列表中，有一个安全组项，选择该选项进入防火墙配置 点击编辑 如下编辑入站规则，并保存。 安装 ShadowsocksR\r打开 Xshell 连接上亚马逊云服务器。依次输入以下命令： sudo -i wget –no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh chmod +x shadowsocks-all.sh ./shadowsocks-all.sh 2\u003e\u00261 | tee shadowsocks-all.log 选择选项 2.ShadowsocksR，输入密码和端口，其他的选项默认就好。安装脚本运行结束后，会显示如下内容 接下来，我们更改一下配置文件。输入命令： vim /etc/shadowsocks-r/config.json 按键盘上的字母i进行编辑文件。进行如下更改： \"protocol\":\"origin\" # 改为 \"protocol\":\"auth_sha1_v4\" \"obfs\":\"plain\" # 改为 \"obfs\":\"tls1.2_ticket_auth\" 按键盘左上角的Esc键，输入:wq保存更改并退出编辑。 重启 ShadowsocksR： /etc/init.d/shadowsocks-r restart 下载客户端： ShadowsocksR for Windows ShadowsocksR for Android 下载并安装好后，启动ShadowsocksR，填写好相关信息。 打开浏览器访问谷歌：https://www.google.com/ 可以正常访问说明配置成功！ 如果想了解更多 Shadowsocks 的使用，请看ShadowSocksR(SSR)功能详细介绍及使用教程。 参考\rhttps://coderschool.cn/2755.html https://greycoder.com/using-shadowsocksr-to-bypass-the-chinese-firewall/ ","date":"2020-08-01","objectID":"/%E5%9C%A8%E4%BA%9A%E9%A9%AC%E9%80%8A%E4%BA%91%E9%85%8D%E7%BD%AEshadowsocksr/:0:0","tags":["ShadowsocksR","亚马逊云"],"title":"在亚马逊云配置ShadowsocksR","uri":"/%E5%9C%A8%E4%BA%9A%E9%A9%AC%E9%80%8A%E4%BA%91%E9%85%8D%E7%BD%AEshadowsocksr/"},{"categories":["工具使用"],"content":"搜索引擎是我们日常学习工作最常使用的服务之一。你可能每天都在用它，但是却仍旧不知道“搜索”。高效地使用搜索引擎可以事半功倍，下面就盘点一下那些年我们可能错过的实用 Google 搜索技巧吧！ 使用加号(或空格)表示与\r不需要使用“+”来表示逻辑与，只要空格就可以了。什么意思呢？简单地说就是，当我们在搜索框输入A B搜索时，就是告诉 Google，我们要搜索的内容与 A 并且和 B 有关。比如说，我们想要搜索与 java 和 python 有关的内容，就可以用java python进行搜索。 使用双引号搜索短语\r如果想要搜索一些短语，比如我们想要搜索与purpose of education有关的内容，而在搜索框输入purpose of education进行搜索，这显然不是很对。因为我们知道 Google 会把它理解成三个关键字的逻辑与，而不是把三个关键字整体当成一个短语。这个时候，就有必要使用双引号，告诉 Google 需要把双引号中的内容看成一个短语。 使用星号\r星号*是常用的通配符，也可以在搜索中使用，代表任意文字。具体来说，假如有一天，突然想起了朋友们之前在谈论金庸先生的一部叫什么八部的小说，小说的名字却怎么都想不起来，只依稀记得八部两个字，这个时候我们就可以使用星号*表示所有可能的文字进行搜索。 使用减号\r我们可能想要过滤掉一些不太感兴趣的信息，这个时候就可以使用-。 我们对盗梦空间这部电影不太感兴趣，于是可以使用减号（-），将其从搜索结果中排除。 使用波浪号\r把波浪号~加在某个词前面，告诉 Google：要搜索与波浪号~后面的那个词相关的近义词。比如，我们要搜索关于大学（college）测验分数（test scores）但不是 SAT 入学分数的相关内容。 college 的近义词，比如 higher education, university 也会一起搜索出来。 列出相似网页\r有一天你发现了一个非常喜欢的网站，比如 Coursera，于是乎你想知道还有没有类似的网站。我们可以使用操作符related:来解决这件事。 搜索数字范围\r可以使用..表示数字范围。具体来说， 使用OR表示或\r用OR表示逻辑或。比如，搜索詹姆斯或科比，或者二者都有的网页。 其他指令\r操作符 用途 用法 allinanchor: 限制搜索的词是网页中链接中包含的关键字（可使用多个关键词） allinanchor:keyword1 keyword2 allintext: 限制搜索的词是网页内文包含的关键词（可使用多个关键词） allintext:keyword1 keyword2 allintitle: 限制搜索的词是网页标题中包含的关键词（可使用多个关键词） allintitle:keyword1 keyword2 allinurl: 限制搜索的词是网页网址中包含的关键词（可使用多个关键词） allinurl:keyword1 keyword2 filetype: 限制所搜索的文件一个特定的格式 filetype:extension inanchor: 限制搜索的词是网页中链接中包含的关键词 inanchor:keyword intext: 限制搜索的词是网页内文中包含的关键词 intext:keyword intitle: 限制搜索的词是网页标题中包含的关键词 intitle:keyword inurl: 限制搜索的词是网页网址中包含的关键词 inurl:keyword site: 限制所进行的搜索在指定的域名或网站中 site:domain 举个例子，假如我们要搜索在伯乐在线上的有关 Java 的文章，就可以使用site:操作符，如下所示： 番外篇\rGoogle 还包含了许多其他实用有趣的功能。比如： 查看天气\r股票报价\r单词含义\r计算器\r画函数图像\r页面旋转\r更多有趣的内容，可查看阅读下列文章。 15 fun things to type into Google 20 Really Cool Google Features You Probably Don’t Know About 8 Hidden (And Useful) Features in Google Search 参考\rTen Tips for Smarter Google Searches 15 fun things to type into Google ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:0:0","tags":["搜索方法","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["深度学习"],"content":"在深度学习领域，卷积神经网络（CNN）已成为图像识别、目标检测、语音识别等任务的核心技术之一。Keras 作为一个高层次的神经网络 API，因其简洁易用而受到广泛欢迎。通过 Keras，我们可以快速搭建、训练并部署复杂的神经网络模型，而无需关注底层实现细节。本文我们将学习使用 Keras 一步一步搭建一个卷积神经网络。具体来说，我们将使用卷积神经网络对手写数字(MNIST 数据集)进行识别，并达到 99%以上的正确率。 我们还将介绍Colaboratory——一个免费的 Jupyter notebook 环境，关键的是可以免费使用 GPU(学生党买不起呀)！ 为什么选择 Keras 呢？ 主要是因为简单方便。更多细节请看：https://keras.io/ 什么卷积神经网络？ 简单地说，卷积神经网络(CNNs)是一种多层神经网络，它可以有效地减少全连接神经网络参数量太大的问题。如果对其背后的原理感兴趣的话，斗胆推荐一些学习资料： 深度学习入门：基于 Python 的理论与实现 Neural Networks and Deep Learning CS231n: Convolutional Neural Networks for Visual Recognition 下面就直接进入主题吧！ 搭建环境\r如果想要在个人电脑上搭建的话，我们需要先安装好 Python，进入：https://www.python.org/ 下载安装就好。 之后，打开终端输入pip install -i https://pypi.douban.com/simple keras 输入以下命令可以确认正常安装： python -c \"import keras;print(keras.__version__)\" 当然，如果想直接使用Colaboratory的话，直接打开你的Google 云端硬盘 为了方便起见，新建一个名为 Keras 的文件夹，进入 Keras 文件夹，单击鼠标右键 选择Colaboratory就可新建一个 Jupyter notebok 啦！ 如果没有看到Colaboratory这一项的话，就选择关联更多应用 搜索Colaboratory，并关联即可。 导入库和模块\r我们导入Sequential模型(相当于放积木的桌子) from keras.models import Sequential 接下来，我们导入各种层(各种形状各异积木) from keras.layers import Conv2D, MaxPool2D from keras.layers import Dense, Flatten 最后，我们导入to_categorical函数，以便之后对数据进行转换 from keras.utils import to_categorical 加载数据\rMNIST 是一个非常有名的手写数字数据集，我们可以使用 Keras 轻松加载它。 from keras.datasets import mnist (x_train, y_train), (x_test, y_test) = mnist.load_data() 查看一下训练集的大小 print(x_train.shape) # (60000, 28, 28) 可以看到 60000 个样本，它们都是 28 像素 x28 像素的。 看一下这些手写数字长什么样 import matplotlib.pyplot as plt %matplotlib inline plt.imshow(x_train[0]) 预处理数据\r使用 Keras 是必须显式声明输入图像深度的尺寸。例如，具有所有 3 个 RGB 通道的全色图像的深度为 3。 我们的 MNIST 图像的深度为 1，但我们必须明确声明。 也就是说，我们希望将数据集从形状(n,rows,cols)转换为(n,rows,cols,channels)。 img_x, img_y = 28, 28 x_train = x_train.reshape(x_train.shape[0], img_x, img_y, 1) x_test = x_test.reshape(x_test.shape[0], img_x, img_y, 1) 除此之外，我们将数据标准化一下： x_train = x_train.astype('float32') x_test = x_test.astype('float32') x_train /= 255 x_test /= 255 之后，将标记值(y_train, y_test)转换为One-Hot Encode的形式，至于为什么要这么做？请查看：https://machinelearningmastery.com/why-one-hot-encode-data-in-machine-learning/ y_train = to_categorical(y_train, 10) y_test = to_categorical(y_test, 10) print(y_train.shape) # (60000, 10) 定义模型结构\r我们参照下图定义一个模型结构 代码如下： model = Sequential() model.add(Conv2D(32, kernel_size=(5,5), activation='relu', input_shape=(img_x, img_y, 1))) model.add(MaxPool2D(pool_size=(2,2), strides=(2,2))) model.add(Conv2D(64, kernel_size=(5,5), activation='relu')) model.add(MaxPool2D(pool_size=(2,2), strides=(2,2))) model.add(Flatten()) model.add(Dense(1000, activation='relu')) model.add(Dense(10, activation='softmax')) 是不是有点搭积木的既视感？ 编译\r现在，只需要编译模型，就可以开始训练了。当编译模型时，我们声明了损失函数和优化器（SGD，Adam 等）。 model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy']) Keras 有很多损失函数和优化器供你选择。 训练\r接下来，我们传入训练集进行训练 model.fit(x_train, y_train, batch_size=128, epochs=10) 以下是在Colaboratory上训练的过程 以下是在个人电脑上训练的过程 可以看到，花费的时间差别还是很大的！ 评估模型\r最后，传入测试集对模型模型进行评估 score = model.evaluate(x_test, y_test) print('acc', score[1]) # acc 0.9926 准确率达到了%99 以上！ 完整代码如下： # 2. 导入库和模块 from keras.models import Sequential from keras.layers import Conv2D, MaxPool2D from keras.layers import Dense, Flatten from keras.utils import to_categorical # 3. 加载数据 from keras.datasets import mnist (x_train, y_train), (x_test, y_test) = mnist.load_data() # 4. 数据预处理 img_x, img_y = 28, 28 x_train = x_train.reshape(x_train.shape[0], img_x, img_y, 1) x_test = x_test.reshape(x_test.shape[0], img_x, img_y, 1) x_train = x_train.astype('float32') x_test = x_test.astype('float32') x_train /= 255 x_test /= 255 y_train = to_categorical(y_train, 10) y_test = to_categorical(y_test, 10) # 5. 定义模型结构 model = Sequential() model.add(Conv2D(32, kernel_size=(5,5), activation='relu', input_shape=(img_x, img_y, 1))) model.add(MaxPool2D(pool_size=(2,2), strides=(2,2))) model.add(Conv2D(64, kernel_size=(5,5), activation='relu')) model.add(MaxPool2D(pool_size=(2,2), strides=(2,2))) model.add(Flatten()) model.add(Dense(1000, activation='relu')) model.add(Dense(10, activation='softmax')) # 6. 编译 model.co","date":"2020-02-01","objectID":"/%E7%94%A8keras%E6%90%AD%E5%BB%BA%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:0:0","tags":["Python","Keras","深度学习","卷积神经网络"],"title":"用Keras搭建卷积神经网络","uri":"/%E7%94%A8keras%E6%90%AD%E5%BB%BA%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"categories":["工具使用"],"content":"版本控制软件能够让我们拍摄处于可行状态下的项目的快照。更改项目（比如实现新功能）后，如果项目不能正常运行，可以恢复到前一个可行状态。通过版本控制软件，我们可以无顾忌地改进项目，不再需要担心项目因为自己犯了错而遭到破坏。对于大型项目而言，这显得尤为重要。对小项目来说，这也是大有益处的。 安装 Git\r要在 Windows 系统中安装 Git，访问 https://git-scm.com/downloads 点击下载安装包，然后双击安装即可。 配置 Git\rGit 会跟踪到底是谁修改了项目，哪怕参与项目开发的人只有一个。为此，Git 需要知道你的用户名和电子邮件地址。你必须提供用户名，但可以使用虚构的电子邮件地址： $ git config --global user.name \"username\" $ git config --global user.email \"username@example.com\" 如果忘记了这一步，在你首次提交时，Git 将提示你提供这些信息。 创建项目\r我们来创建一个要进行版本控制的项目。在你的系统中创建一个目录，并将其命名为learn_git。在这个目录中，创建一个简单的 Python 程序： # hello_world.py print(\"Hello Git World!\") 忽略文件\r扩展名为.pyc的文件是根据.py文件自动生成的，因此我们无需让 Git 跟踪它们。这些文件存储在__pycache__目录中。为了让 Git 忽略这个目录，创建一个名为.gitignore的特殊文件，并将下面类容添加到文件中： __pycache__/ 这让 Git 忽略目录__pycache__中的所有文件。使用.gitignore文件可以避免项目混乱。 初始化仓库\r现在的learn_git只是一个普通的目录，包含了一个Python文件和一个.gitignore文件，为了对其进行版本控制需要使用 Git 进行初始化一下。打开一个终端窗口，切换到learn_git目录，并执行如下命令： 输出表明 Git 在learn_git中初始化了一个空仓库。仓库是程序中被 Git 主动跟踪的一组文件。Git 用来管理仓库的文件都存储在隐藏的.git/中。 检查状态\r在执行其他操作前，先看一下项目的状态： 在 Git 中，分支是项目的一个版本。从这里的输出可知，我们位于分支master上（见 1）。Git 指出了项目中未被跟踪的文件（见 2），因为我们还没有告诉它要跟踪哪些文件。提交是项目在特定时间点的快照。此时，我们被告知没有将任何东西添加到当前提交中，但我们需要将未跟踪的文件加入到仓库中（见 3）。 将文件加入到仓库中\r下面将之前的两个文件加入到仓库中 $ git add . 再次检查状态： 命令git add .将项目中未被跟踪的所有文件都加入到仓库中。它不提交这些文件，而只是让 Git 开始关注它们。当我们检查项目的状态时，Git 找出了需要提交的一些修改。标签new file意味着这些文件是新添加到仓库中的。 执行提交\r接下来，我们执行第一次提交： 我们执行命令git commit -m \"message\"以拍摄项目的快照。选项-m让 Git 将接下来的消息\"Started project\"记录到项目的历史记录中。输出表明我们在分支master上，且有两个文件被修改了。现在我们检查状态时，发现我们在分支master上，且工作目录是干净的。 查看提交历史\rGit 记录所有的项目提交。下面来看一下提交历史： 每次提交时，Git 都会生成一个包含 40 字符的独一无二的引用 ID。它记录提交是谁提交的、提交的时间以及提交时指定的消息。但是，并非在任何情况下都需要所有这些信息，Git 提供了一个选项，以便能够打印提交历史条目中更简单的版本： 选项--pretty=oneline指定显示两项最重要的信息：提交的引用 ID 以及为提交记录的消息。 第二次提交\r我们在hello_world.py中再添加一行代码： # hello_world.py print(\"Hello Git World!\") print(\"Hello everyone.\") 查看项目状态，Git 注意到了这个文件发生了变化： 输出指出了我们当前所在的分支、被修改了的文件的名称，还指出了所做的修改未提交。接下来我们提交所做的修改，并再次查看状态： 我们再次执行了提交，并在执行命令git commit时指定了选项-am。选项-a让 Git 将仓库中所有修改了的文件都加入到当前提交中（如果在两次提交之间创建了新文件，可再次执行命令git add .将这些新文件加入到仓库中）。选项-m让 Git 在提交历史中记录一条消息。 我们查看项目的状态时，发现工作目录也是干净的。最后，我们发现提交历史中包含两个提交。 撤销修改\r下面来看看如何放弃所做的修改，恢复到前一个可行状态。为此，首先在hello_world.py中再加一行代码： # hello_world.py print(\"Hello Git World!\") print(\"Hello everyone.\") print(\"Oh no, I broke the project!\") 保存并查看状态： Git 注意到我们修改了hello_world.py。我们可以提交所做的修改，但这次我们不提交所做的修改，而要恢复到最后一个提交（那次提交时项目能够正常地运行）。为此，我们不对hello_world.py执行任何操作——不删除刚添加的代码行，也不使用文本编辑器的撤销功能，而在终端会话中执行如下命令： 命令git checkout让你能够恢复到以前的任何提交。命令git checkout .放弃自最后一次提交后所做的所有修改，让项目恢复到最后一次提交的状态。 如果我们回到文本编辑器，将发现hello_world.py被修改成了下面这样： 就这个项目而言，恢复到前一个状态微不足道，但如果我们开发的是大型项目，其中数十个文件都被修改了，那么恢复到前一个状态，将撤销自最后一次提交后对这些文件所有的所有修改。这个功能很有用：实现新功能时，可以根据需要做任意数量的修改，如果这些修改不可行，可以撤销它们，而不会对项目有任何影响。 检出以前的提交\r我们可以检出提交历史中的任何提交，而不仅仅是最后一次提交，为此可在命令git checkout 末尾指定该提交的引用 ID 的前 6 个字符（而不是句点）。 检出以前的提交后，将离开master分支，并进入分离头指针（detached HEAD）状态。HEAD 表示项目的当前状态，之所以说处于分离状态，是因为我们离开了一个命名分支（这里是 master）。 要回到master分支，可以检出它： 除非你要使用 Git 的高级功能，否则在检出以前的提交后，最好不要对项目做任何修改。如果只有你一个人开发项目，而你又想放弃较近的所有提交，并恢复到以前的状态，也可以将项目重置到以前的提交。为此，可以在处于master分支上执行如下命令： 我们首先查看了状态，确认我们在master分支上。查看提交历史时，我们看到了两个提交。然后，执行命令git reset --hard，并在其中指定了要永久地恢复到的提交的引用 ID 的前 6 个字符。再次查看状态，发现我们在master分支上，且没有需要提交的更改。再次查看提交历史时，发现我们处于要从它重新开始的提交中。 推荐\r最后，推荐一个网站 Learn Git Branching：https://learngitbranching.js.org/ 以闯关+可视化的形式学习 Git 相关知识。 参考\rhttps://book.douban.com/subject/26829016/ ","date":"2019-11-03","objectID":"/git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:0","tags":["版本控制","Git","开发工具","代码管理"],"title":"Git简明教程","uri":"/git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"本文我们将学习如何使用Tkinter包编写一些图形用户界面程序。Tkinter是 Python 的一个标准包，因此我们并不需要安装它。我们将从创建一个窗口开始，然后我们在其之上加入一些小组件，比如按钮，复选框等，并使用它们的一些属性。话不多说，让我们开始吧！ 创建一个窗口\r首先，我们导入Tkinter包，然后创建一个窗口，最后给这个窗口设置标题。 from tkinter import * window = Tk() window.title(\"First Window\") window.mainloop() 结果如下： 最后一行我们调用了mainloop函数，这个函数将让窗口等待用户与之交互，直到我们关闭它。如果忘记调用mainloop函数的话，将不会向用户显示任何内容（没有窗口）。 添加一个标签组件\r为了给之前的例子增加一个标签组件，我们可以使用Label类： lbl = Label(window, text=\"Hello\") 我们可以通过grid函数设置其在窗口的位置： lbl.grid(column=0, row=0) 完整代码如下所示： from tkinter import * window = Tk() window.title(\"First Window\") lbl = Label(window, text=\"Hello\") lbl.grid(column=0, row=0) window.mainloop() 结果如下： 值得注意的是lbl没有调用grid函数的话是不会显示的。 设置标签字体大小\r我们可以使用font参数设置标签字体大小： lbl = Label(window, text=\"Hello\", font=(\"Arial Bold\", 50)) font参数不光可以在标签组件中用，其他组件也可以使用呢！ 可是，现在窗口貌似太小了，连窗口的标题都看不全，如何设置窗口大小呢？ 设置窗口大小\r我们可以用geometry函数来设置窗口大小： window.geometry(\"350x200\") 以上代码将会把窗口设置成 350 个像素宽，200 个像素高。 添加一个按钮组件\r让我们给窗口增加一个按钮组件，它的创建和添加方式和标签组件差不多： btn = Button(window, text=\"Click Me\") btn.grid(column=1, row=0) 完整代码如下所示： from tkinter import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") lbl = Label(window, text=\"Hello\") lbl.grid(column=0, row=0) btn = Button(window, text=\"Click Me\") btn.grid(column=1, row=0) window.mainloop() 结果如下： 更改按钮前景和背景颜色\r我们可以用fg参数设置按钮或其他组件的前景色。 我们可以用bg参数设置按钮或其他组件的背景色。 btn = Button(window, text=\"Click Me\", bg=\"orange\", fg=\"red\") 现在，如果点击按钮，什么都不会发生，因为我们没有写处理点击事件的代码。 处理按钮点击事件\r首先，我们编写一个当按钮点击后需要执行的函数： def clicked(): lbl.configure(text=\"Button was clicked!\") 然后，我们注明一下点击时要调用的函数： btn = Button(window, text=\"Click Me\", command=clicked) 完整代码如下所示： from tkinter import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") lbl = Label(window, text=\"Hello\") lbl.grid(column=0, row=0) def clicked(): lbl.configure(text=\"Button was clicked!\") btn = Button(window, text=\"Click Me\", command=clicked) btn.grid(column=1, row=0) window.mainloop() 当我们点击按钮后，结果如下： 添加一个文本框\r在之前的例子中我们了解了如何添加一些简单组件，现在我们将通过Tkinter的Entry类获取到用户输入。我们可以这样用Entry类创建一个文本框： txt = Entry(window, width=10) 然后可以用grid函数像之前那样添加到窗口中。 from tkinter import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") lbl = Label(window, text=\"Hello\") lbl.grid(column=0, row=0) txt = Entry(window, width=10) txt.grid(column=1, row=0) def clicked(): lbl.configure(text=\"Button was clicked!\") btn = Button(window, text=\"Click Me\", command=clicked) btn.grid(column=2, row=0) window.mainloop() 此时点击按钮，标签组件内的内容没有变化，如何将文本框中输入的信息在标签组件中显示呢？ 我们可以用get函数获取到文本框中输入的信息，然后如下更改clicked函数来设置窗口大小： def clicked(): res = \"Welcome to \" + txt.get() lbl.configure(text=res) 如果我们在文本框中输入信息并点击按钮组件，标签组件将会显示Welcome to 文本框输入信息 。 以下是完整代码： from tkinter import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") lbl = Label(window, text=\"Hello\") lbl.grid(column=0, row=0) txt = Entry(window, width=10) txt.grid(column=1, row=0) def clicked(): res = \"Welcome to \" + txt.get() lbl.configure(text=res) btn = Button(window, text=\"Click Me\", command=clicked) btn.grid(column=2, row=0) window.mainloop() 运行结果为： 但每次我们运行代码后，我们都需要通过点击文本框来设置输入焦点才能输入信息，有什么办法可以自动设置输入焦点吗？ 设置输入焦点\r很简单，我们只需要调用focus函数来设置窗口大小： txt.focus() 当我们运行代码后，会发现可以直接在文本框中输入信息而不需要点击文本框。 添加一个组合框\r为了添加一个组合框，可以使用Combobox类： from tkinter.ttk import * combo = Combobox(window) 然后可以给组合框添加一些值。 from tkinter import * from tkinter.ttk import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") combo = Combobox(window) combo['values'] = (1,2,3,4,5,\"Text\") combo.current(1) combo.grid(column=0, row=0) window.mainloop() 如上所示，我们可以用元组设置组合框选项。 我们可以通过传递期望被选中选项的索引给current函数用以设置被选中的选项。 我们可以通过get函数获取到被选中的选项。 combo.get() 添加复选框\r我们可以用Checkbutton类来创建一个复选框组件： chk = Checkbutton(window, text=\"Choose\") 能通过传递值设置复选框的状态： from tkinter import * from tkinter.ttk import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") chk_state = BooleanVar() chk_state.set(True) # Set check state chk = Checkbutton(window, text=\"Choose\", var=chk_state) chk.grid(column=0, row=0) window.mainloop() 上例我们用的是BooleanVar变量用来设置复选框的状态，也可","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["OpenCV"],"content":"无论我们想要学习如何将面部识别应用于视频流，还是用深度学习构建图像分类器，或者做其他一些有关图像识别的有趣项目，可能都会需要学一些 OpenCV 的知识，本文将做简单介绍。 加载和显示图像\r保存上面的图片，打开你最爱的编辑器，输入以下代码： import cv2 image = cv2.imread('demo.jpg') cv2.imshow('Image', image) cv2.waitKey() 第 3 行，使用cv2.imread()导入图像。 第 4 行，使用cv2.imshow()显示图像。窗口会自动调整为图像大小。第一个参数是窗口的名字，然后是我们的图像。 第 5 行，使用cv2.waitKey()等待键盘输入。 运行一下，结果如下所示： 获取并修改像素值\r我们可以先查看一下图像的形状， print(image.shape) # (600,400,3) image.shape可以获取图像的形状。返回的是一个包含行数（高），列数（宽），通道数的元组。 可以根据像素的行、列坐标获取其像素值。对于 BGR 图像来说，返回值为 B，G，R 的值。对灰度图像来说，返回值为其灰度值。 B,G,R = image[320,15] print('B={}, G={}, R={}'.format(B,G,R)) # B=150, G=172, R=197 可以用类似的方式修改像素值， image[320,15] = [52,26,16] B,G,R = image[320,15] print('B={}, G={}, R={}'.format(B,G,R)) # B=52, G=26, R=16 图像 ROI\r有时我们需要对一幅图像的感兴趣的区域（Regions of Interest，ROI）进行操作。比如，我们要检测一幅图像中眼睛的位置，我们首先应该在图像中找到脸，再在脸的区域中找眼睛，而不是直接在一幅图像中搜素。ROI 也是通过索引获得，其实就相当于数组切片。 import cv2 image = cv2.imread('demo.jpg') head = image[27:124,159:260] image[200:297,299:400] = head cv2.imshow('New', image) cv2.waitKey() 结果如下： 图像缩放\rOpenCV 提供的函数cv2.resize()可以改变图像的尺寸大小。 import cv2 image = cv2.imread('demo.jpg') resized = cv2.resize(image, (200,400)) cv2.imshow('Image', resized) cv2.waitKey() 旋转图像\r对一个图像旋转角度 $\\theta$，需要用到下面形式的旋转矩阵。 OpenCV 允许我们在任意地方进行旋转，于是旋转矩阵的形式应该改为： 其中： 为了构建这个旋转矩阵，OpenCV 提供了一个函数：cv2.getRotationMatrix2D()。 以下便是在不缩放的情况下将图像旋转 90 度。 import cv2 image = cv2.imread('demo1.jpg') rows,cols,depth = image.shape M = cv2.getRotationMatrix2D((rows // 2, cols // 2), 90, 1) dst = cv2.warpAffine(image,M,(cols,rows)) cv2.imshow('Image', dst) cv2.waitKey() 第 5 行，第一个参数为旋转中心，第二个参数为旋转角度，第三个为旋转后的缩放因子。 第 6 行，第三个参数是输出图像的尺寸。 图像模糊\r在许多的图像处理过程中，我们必须模糊图像以减少高频噪声，使算法更容易检测和理解图像的实际内容。在 OpenCV 中模糊图像非常容易，有很多方法可以用。 import cv2 image = cv2.imread('demo1.jpg') blurred = cv2.GaussianBlur(image, (11, 11), 0) cv2.imshow('Blurred', blurred) cv2.waitKey() 第 4 行，我们使用了高斯模糊，用了11 x 11的核。 较大的核会产生更模糊的图像，较小的核将产生没那么的模糊图像。 绘图函数\r本节我们将在导入的图像上画矩形，圆，线以及添加文字。但值得注意的是，这些操作会影响到原始导入的image，为了避免这样，我们可以用image的副本进行操作。 import cv2 image = cv2.imread('demo.jpg') output = image.copy() cv2.rectangle(output, (163, 30), (244, 124), (0, 0, 255), 2) cv2.imshow('Rectangle', output) cv2.waitKey() 第 5 行，设置的参数如下： img：想要绘制图像的那幅图像，这里是output。 pt1：矩形左上角坐标，这里是(163, 30)。 pt2：矩形右下角坐标，这里是(244, 124)。 color：BGR 元组，这里是红色(0,0,255)。 thickness：线条粗细（如果一个闭合图形设置为负数，那么这个图形就会被填充），这里是2。 结果如下： 接下来，我们在猫咪的图像上画一个圆。 import cv2 image = cv2.imread('demo1.jpg') output = image.copy() cv2.circle(output, (32, 25), 20, (255,0,0),-1) cv2.imshow('Circle', output) cv2.waitKey() 要画圆的话，需要指定圆形的圆心坐标和半径大小。 第 5 行，我们指定圆心为(35,25)，半径大小为20。其他参数含义，和画矩形时一样。 画线的话，我们只需要指定起点和终点即可。 import cv2 image = cv2.imread('demo1.jpg') output = image.copy() cv2.line(output, (35,25),(125,69),(255,0,0),5) cv2.imshow('Line', output) cv2.waitKey() 第 5 行，我们指定起点为(35,25)，终点为(125,69)。 结果如下： 我们可能经常需要在图像上添加文字，比如在进行人脸识别的时候，需要在人的脸上绘制出他们的名字。可以使用 OpenCV 的cv2.putText()函数在图像上添加文字。 import cv2 image = cv2.imread('demo.jpg') output = image.copy() cv2.putText(output, 'Sasaki Nozomi', (10, 25), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2) cv2.imshow('Text', output) cv2.waitKey() 第 5~6 行，设置的参数如下： img：想要绘制图像的那幅图像，这里是output。 text：要绘制的文字内容，这里是Sasaki Nozomi。 pt：绘制的位置，这里是(10,25)。 font：字体类型，这里是cv2.FONT_HERSHEY_SIMPLEX。 scale：字体大小乘数，这里是0.7。 color：字体颜色，这里是红色(0,0,255)。 thickness：字体粗细，这里是2。 如下图所示，“Sasaki Nozomi”绘制在图像上， 参考\rhttps://opencv-python-tutroals.readthedocs.io/en/latest/ https://www.pyimagesearch.com/2018/07/19/opencv-tutorial-a-guide-to-learn-opencv/ ","date":"2019-01-07","objectID":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:0","tags":["OpenCV","Python"],"title":"OpenCV简明教程","uri":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"}]