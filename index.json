[{"categories":["源码剖析"],"content":"我们经常说，Python 是一门解释型语言，但你知道它的解释器 CPython 究竟是如何工作的么？Python 的内存管理、字节码执行、垃圾回收……这些幕后英雄是如何协作的？在这篇文章中，我们将通过剖析 CPython 源码，一起探索 Python 的运行本质。 ","date":"2024-11-27","objectID":"/cpython%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:0:0","tags":["Python","CPython","源码剖析"],"title":"CPython 源码剖析：Python 运行的奥秘","uri":"/cpython%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r为什么阅读 CPython 源码？理由很简单！ 注意\r只是想看看成功且优秀的代码是什么样的。\r严谨的代码结构：CPython 是由全球顶尖开发者共同维护的开源项目，其代码结构极为清晰。模块划分合理，功能边界明确，适合学习如何设计大规模软件系统。通过阅读，能学会如何平衡代码的灵活性和可维护性。 注释和文档的典范：CPython 源码中的注释和文档量非常丰富，代码可读性极高。尤其是核心部分的实现，几乎每个模块和关键函数都有注释，解释其意图、设计思路和限制条件。这是“写给人看的代码”应该具备的标准。 简洁而高效的实现：尽管实现的是复杂的功能，但 CPython 的代码常常让人感叹“原来还能这么简洁优雅”。它展示了如何用最小的复杂度完成既定任务，同时保持代码的直观性。 一致的风格：优秀代码的重要特征之一是风格统一。CPython 的开发者严格遵循 PEP（Python Enhancement Proposals）中的规范，代码风格干净利落且一致，值得作为日常开发中的代码书写范例。 精妙的性能优化：CPython 在追求易读性和高性能之间做出了巧妙的平衡。例如：内存管理的实现（如引用计数）、对象模型的优化、以及对关键代码路径的 C 语言加速。这些地方让人看到“优秀代码”不仅是可读的，还能高效运行。 经典设计模式的应用：CPython 源码中，很多地方使用了经典的设计模式，例如工厂模式（用于对象创建）、适配器模式（处理不同平台的系统调用）、策略模式（优化特定的算法执行）。它是学习设计模式实际应用的最佳实践。 跨平台的实现技巧：作为一个需要在多种操作系统上运行的解释器，CPython 的代码展示了如何编写兼容性良好的跨平台代码，同时又能利用特定平台的优势。它的解决方案体现了顶级工程师的智慧。 迭代与社区合作的典范：CPython 是经过二十多年迭代的成熟项目，许多代码并非一蹴而就，而是在社区的协作中不断打磨。这种“演化式”代码开发过程本身就是一种学习：代码如何从朴素走向优雅，从复杂趋于简洁。 阅读 CPython 源码，不仅能感受到编程艺术的美感，还能学到如何写出让别人（包括未来的自己）一看就懂的代码。作为一个开发者，我始终相信手里得有倚天剑或者屠龙刀，CPython 源码无疑就是这把神兵利器的锻造场！ ","date":"2024-11-27","objectID":"/cpython%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:1:0","tags":["Python","CPython","源码剖析"],"title":"CPython 源码剖析：Python 运行的奥秘","uri":"/cpython%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r参考 https://flaggo.github.io/python3-source-code-analysis/ 《Python 源码剖析》陈儒 ","date":"2024-11-27","objectID":"/cpython%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:2:0","tags":["Python","CPython","源码剖析"],"title":"CPython 源码剖析：Python 运行的奥秘","uri":"/cpython%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":" 纸上得来终觉浅，绝知此事要躬行。——陆游《冬夜读书示子聿》 csv2是一个轻量级 C++ 库，用于将 CSV 文件解析为 C++ 中的 STL 容器。该库的主要功能是高效地处理 CSV 数据，简化了处理 CSV 文件的代码编写过程。以下是它的主要特性： 简单易用：通过使用 STL 容器（如 std::vector 和 std::tuple），使得开发者能够轻松将 CSV 文件的内容转换为标准 C++ 数据结构。 依赖少：该库只有 C++17 标准库的依赖，因此不需要额外的第三方库。 高效解析：该库采用高效的解析机制，支持处理大型 CSV 文件。 轻量级：代码库很小，适用于嵌入式或对依赖库要求较高的项目。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:0:0","tags":["CSV","C++","源码剖析"],"title":"csv2 源码剖析：轻量级 CSV 处理的高效之道","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r准备项目源代码地址为p-ranav/csv2 v1.0。 阅读工具为 CLion。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:1:0","tags":["CSV","C++","源码剖析"],"title":"csv2 源码剖析：轻量级 CSV 处理的高效之道","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r剖析整个项目包含 4 个文件，分别是: reader.hpp、mio.hpp、writer.hpp和parameters.hpp。 .c vs .cc vs. .cpp vs .hpp vs .h vs .cxx: 由于历史渊源，造成头文件和源代码文件有些不同的命名方式，但本质而言没有什么区别。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:2:0","tags":["CSV","C++","源码剖析"],"title":"csv2 源码剖析：轻量级 CSV 处理的高效之道","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\rreader.hppreader.hpp 文件中主要定义了一个名为Reader的类。数据部分主要有: 紧接着定义了两个方法: mmap和parse，分别从文件和字符串内容解析内容。 从文件中解析内容: #include \"csv2/reader.hpp\" #include \u003cstring\u003e using namespace std; int main(){ csv2::Reader\u003ccsv2::delimiter\u003c','\u003e, csv2::quote_character\u003c'\"'\u003e, csv2::first_row_is_header\u003ctrue\u003e, csv2::trim_policy::trim_whitespace\u003e csv; std::string content = \"Name, Age\\nPeter, 12\\nLucy, 78\"; if(csv.parse(content)){ const auto header = csv.header(); for (const auto row: csv) { for (const auto cell: row) { // Do something with cell value std::string value; cell.read_value(value); cout \u003c\u003c value \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; } } } 从字符串中解析内容: #include \"csv2/reader.hpp\" #include \u003cstring\u003e using namespace std; int main(){ csv2::Reader\u003ccsv2::delimiter\u003c','\u003e, csv2::quote_character\u003c'\"'\u003e, csv2::first_row_is_header\u003ctrue\u003e, csv2::trim_policy::trim_whitespace\u003e csv; if(csv.mmap(\"demo.csv\")){ const auto header = csv.header(); for (const auto row: csv) { for (const auto cell: row) { // Do something with cell value std::string value; cell.read_value(value); cout \u003c\u003c value \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; } } } parse方法中使用了知识点 10。 reader.hpp 中还定义了Cell、Row、RowIterator等类。 为了方便在之后的类中使用 RowIterator、Row 和 CellIterator，文件中加了 forward-declaration，如上图所示。 CellCell 类的数据部分定义如下: 其中的buffer_指向 memory-mapped buffer，可参考知识点 4，我们可以简单的将其理解为指向数据内容的一个指针。 主要包括两个方法: read_raw_value和read_value，两个方法稍有区别，前者处理无转义字符，后者处理有转义字符。 RowRow 类的数据部分定义如下: 和 Cell 类的定义大同小异。Row 类中还定义了另一个类 CellIterator: class CellIterator { friend class Row; const char *buffer_; size_t buffer_size_; size_t start_; size_t current_; size_t end_; public: CellIterator(const char *buffer, size_t buffer_size, size_t start, size_t end) : buffer_(buffer), buffer_size_(buffer_size), start_(start), current_(start_), end_(end) { } CellIterator \u0026operator++() { current_ += 1; return *this; } Cell operator*() { bool escaped{false}; class Cell cell; cell.buffer_ = buffer_; cell.start_ = current_; cell.end_ = end_; size_t last_quote_location = 0; bool quote_opened = false; for (auto i = current_; i \u003c end_; i++) { current_ = i; if (buffer_[i] == delimiter::value \u0026\u0026 !quote_opened) { // actual delimiter // end of cell cell.end_ = current_; cell.escaped_ = escaped; return cell; } else { if (buffer_[i] == quote_character::value) { if (!quote_opened) { // first quote for this cell quote_opened = true; last_quote_location = i; } else { escaped = (last_quote_location == i - 1); last_quote_location += (i - last_quote_location) * size_t(!escaped); quote_opened = escaped || (buffer_[i + 1] != delimiter::value); } } } } cell.end_ = current_ + 1; return cell; } bool operator!=(const CellIterator \u0026rhs) { return current_ != rhs.current_; } }; CellIterator 中定义了自增操作符、取值操作符和不等操作符。Iterator 必须实现这三个操作符: #include \u003ciostream\u003e using namespace std; // forward-declaration to allow use in Iter class IntVector; class Iter { public: Iter (const IntVector* p_vec, int pos) : _pos( pos ) , _p_vec( p_vec ) { } // these three methods form the basis of an iterator for use with // a range-based for loop bool operator!= (const Iter\u0026 other) const { return _pos != other._pos; } // this method must be defined after the definition of IntVector // since it needs to use it int operator* () const; const Iter\u0026 operator++ () { ++_pos; // although not strictly necessary for a range-based for loop // following the normal convention of returning a value from // operator++ is a good idea. return *this; } private: int _pos; const IntVector *_p_vec; }; class IntVector { public: IntVector () { } int get (int col) const { return _data[ col ]; } Iter begin () const { return Iter( this, 0 ); } Iter end () const { return Iter( this, 100 ); } void set (int index, int val) { _data[ index ] = val; } private: int _data[ 100 ]; }; int Iter::operator* () const { return _p_vec-\u003eget( _pos ); } // sample usage of the range-based for loop on IntVector int main() { IntVector v; for ( int i = 0; i \u003c 100; i++ ) { v.set( i , i ); } for ( int i : v ) { cout \u003c\u003c i \u003c\u003c endl; } } C++ 11 range-based for loops: https://www.cprogramming.com/","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:2:1","tags":["CSV","C++","源码剖析"],"title":"csv2 源码剖析：轻量级 CSV 处理的高效之道","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\rmio.hppmio.hpp 相比与其他三个文件的代码多了不少，也复杂了许多。文件一开始定义了template \u003caccess_mode AccessMode, typename ByteT\u003e struct basic_mmap结构体，然后围绕这个结构体声明了一系列操作符: 其定义在行号 1058 处: 之后定义了 5 个工厂方法，方便构建mmap、mmap_source以及mmap_sink对象: 然后在 587 处开始定义了字符串相关的工具函数: 在 684 处开始定义了与 Windows 平台相关的open_file_helper函数。 然后定义了template \u003ctypename String\u003e file_handle_type open_file，inline size_t query_file_size和inline mmap_context memory_map函数，以及struct mmap_context结构体。之后，实现了许多在template \u003caccess_mode AccessMode, typename ByteT\u003e struct basic_mmap声明的方法。 最后定义了template \u003caccess_mode AccessMode, typename ByteT\u003e class basic_shared_mmap类。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:2:2","tags":["CSV","C++","源码剖析"],"title":"csv2 源码剖析：轻量级 CSV 处理的高效之道","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\rwriter.hppwriter.hpp 中包含将数据导出的功能。主要定义了两个方法:write_row和write_rows，代表写入一行和写入多行。 例如，将数据写入到文件中: #include \u003ccsv2/reader.hpp\u003e #include \u003ccsv2/parameters.hpp\u003e #include \u003ccsv2/mio.hpp\u003e #include \u003ccsv2/writer.hpp\u003e #include \u003ciostream\u003e #include \u003costream\u003e #include \u003cvector\u003e #include \u003cstring\u003e using namespace csv2; using namespace std; int main() { std::ofstream out(\"info.csv\"); csv2::Writer\u003ccsv2::delimiter\u003c','\u003e, std::ofstream\u003e writer(out); std::vector\u003cstd::string\u003e header = { \"Name\", \"Age\" }; std::vector\u003cstd::vector\u003cstd::string\u003e\u003e content{ {\"Andy\", \"19\"}, {\"Peter\", \"21\"}, {\"Lucas\", \"20\"} }; writer.write_row(header); writer.write_rows(content); } ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:2:3","tags":["CSV","C++","源码剖析"],"title":"csv2 源码剖析：轻量级 CSV 处理的高效之道","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\rparameters.hpp首先，为了组织代码引入了trim_policy命名空间。 包含了no_trimming、trim_characters两个结构体，以及using trim_whitespace = trim_characters\u003c' ', '\\t'\u003e;一句，于是给空白符' '和'\\t'新的使用方式——trim_whitespace。需要注意的是，该标识符在trim_policy命名空间中。 此外，还包含delimiter、quote_character以及first_row_is_header三个结构体，和之前不同的是它们在csv2命令空间中。 整个文件的结构体里面的方法或数据都是static的，表示我们可以用delimiter\u003c':'\u003e::value的方式直接获取里面的数据，而不用实例化（实例化从逻辑上好像也有一些问题，同样是用:作为分隔符却实例化了两个不同的对象，有点奇怪）。 关于可变参数模板可看知识点 5。 pair 的使用: https://cplusplus.com/reference/utility/pair/pair/ ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:2:4","tags":["CSV","C++","源码剖析"],"title":"csv2 源码剖析：轻量级 CSV 处理的高效之道","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r知识点","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:0","tags":["CSV","C++","源码剖析"],"title":"csv2 源码剖析：轻量级 CSV 处理的高效之道","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r1. CMake 项目添加第三方库在 CMakeLists.txt 中添加如下语句: 即可将三方库的头文件包含进来。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:1","tags":["CSV","C++","源码剖析"],"title":"csv2 源码剖析：轻量级 CSV 处理的高效之道","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r2. Static Const 使用mio.hpp 中有如下一段代码: /** * Determines the operating system's page allocation granularity. * * On the first call to this function, it invokes the operating system specific syscall * to determine the page size, caches the value, and returns it. Any subsequent call to * this function serves the cached value, so no further syscalls are made. */ inline size_t page_size() { static const size_t page_size = [] { #ifdef _WIN32 SYSTEM_INFO SystemInfo; GetSystemInfo(\u0026SystemInfo); return SystemInfo.dwAllocationGranularity; #else return sysconf(_SC_PAGE_SIZE); #endif }(); return page_size; } page_size()内部的匿名函数只会运行一次，得益于static const声明，这样可以避免重复调用sysconf()函数（如注释所述）。 https://www.tutorialspoint.com/static-const-vs-hashdefine-vs-enum ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:2","tags":["CSV","C++","源码剖析"],"title":"csv2 源码剖析：轻量级 CSV 处理的高效之道","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r3. static_assertmio.hpp 中有static_assert的写法。 static_assert declaration: https://en.cppreference.com/w/cpp/language/static_assert Understanding static_assert in C++ 11: https://www.geeksforgeeks.org/understanding-static_assert-c-11/ ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:3","tags":["CSV","C++","源码剖析"],"title":"csv2 源码剖析：轻量级 CSV 处理的高效之道","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r4. mmapmio.hpp 中的memory_map函数使用了mmap。 Use the mmap Function to Write to the Memory in C Shared Memory: https://kuafu1994.github.io/MoreOnMemory/sharedMemory.html mapread.c 和 mapwrite.c: https://gist.github.com/marcetcheverry/991042 Memory Mapped I/O: https://www.cs.uleth.ca/~holzmann/C/system/mmap.html 存储映射 I/O存储映射 I/O（Memory-Mapped I/O）能将一个磁盘文件映射到存储空间的一个缓冲区上，当从缓冲区中取数据时，就相当于读文件中的相应字节。与此类似，将数据存入缓冲区时，相应字节就自动写入文件。如此一来，就可以在不调用 read 和 write 的情况下执行 I/O。——《UNIX 环境高级编程》14.8 节 探索内存原理的内存映射文件: https://zhuanlan.zhihu.com/p/429987335 File Mapping in C++ Applications: https://www.geeksforgeeks.org/file-mapping-in-cpp-applications/ File Mapping: https://learn.microsoft.com/en-us/windows/win32/memory/file-mapping Mapping files into virtual memory in C on windows: https://stackoverflow.com/questions/68368291/mapping-files-into-virtual-memory-in-c-on-windows 示例代码: #include \u003ccstdio\u003e #include \u003cwindows.h\u003e #include \u003ciostream\u003e using namespace std; int main(int argc, char* argv[]) { const TCHAR* lpFileName = TEXT(\"hello.txt\"); HANDLE hFile; HANDLE hMap; LPVOID lpBasePtr; LARGE_INTEGER liFileSize; hFile = CreateFile(lpFileName, GENERIC_READ, // dwDesiredAccess 0, // dwShareMode NULL, // lpSecurityAttributes OPEN_EXISTING, // dwCreationDisposition FILE_ATTRIBUTE_NORMAL, // dwFlagsAndAttributes 0); // hTemplateFile if (hFile == INVALID_HANDLE_VALUE) { fprintf(stderr, \"CreateFile failed with error %d\\n\", GetLastError()); return 1; } if (!GetFileSizeEx(hFile, \u0026liFileSize)) { fprintf(stderr, \"GetFileSize failed with error %d\\n\", GetLastError()); CloseHandle(hFile); return 1; } if (liFileSize.QuadPart == 0) { fprintf(stderr, \"File is empty\\n\"); CloseHandle(hFile); return 1; } hMap = CreateFileMapping( hFile, NULL, // Mapping attributes PAGE_READONLY, // Protection flags 0, // MaximumSizeHigh 0, // MaximumSizeLow NULL); // Name if (hMap == 0) { fprintf(stderr, \"CreateFileMapping failed with error %d\\n\", GetLastError()); CloseHandle(hFile); return 1; } lpBasePtr = MapViewOfFile( hMap, FILE_MAP_READ, // dwDesiredAccess 0, // dwFileOffsetHigh 0, // dwFileOffsetLow 0); // dwNumberOfBytesToMap if (lpBasePtr == NULL) { fprintf(stderr, \"MapViewOfFile failed with error %d\\n\", GetLastError()); CloseHandle(hMap); CloseHandle(hFile); return 1; } // Display file content as ASCII charaters char* ptr = (char*)lpBasePtr; LONGLONG i = liFileSize.QuadPart; while (i-- \u003e 0) { fputc(*ptr++, stdout); } UnmapViewOfFile(lpBasePtr); CloseHandle(hMap); CloseHandle(hFile); printf(\"\\nDone\\n\"); } ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:4","tags":["CSV","C++","源码剖析"],"title":"csv2 源码剖析：轻量级 CSV 处理的高效之道","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r5. 可变参数模板在 parameters.hpp 中使用了可变参数模板（Variadic Template Function）。 C++11 – Variadic Template Function | Tutorial \u0026 Examples template\u003ctypename T\u003e void logging(T t){ cout \u003c\u003c t; cout \u003c\u003c \"\\nLast Call\\n\"; } template\u003ctypename T, typename ... Args\u003e void logging(T first, Args... args){ cout \u003c\u003c first \u003c\u003c \", \"; logging(args...); } ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:5","tags":["CSV","C++","源码剖析"],"title":"csv2 源码剖析：轻量级 CSV 处理的高效之道","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r6. #pragma onceWhat does #pragma once mean in C? 截至到 2023 年为止，主流的编译器都支持#pragma once。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:6","tags":["CSV","C++","源码剖析"],"title":"csv2 源码剖析：轻量级 CSV 处理的高效之道","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r7. __has_include()根据Source file inclusion的描述，__has_include()可以用来检测某个头文件是否存在，但此时并没有将其引入。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:7","tags":["CSV","C++","源码剖析"],"title":"csv2 源码剖析：轻量级 CSV 处理的高效之道","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r8. defined(identifier)reader.hpp 中有#if defined(identifier)一句。 #if, #elif, #else, and #endif directives ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:8","tags":["CSV","C++","源码剖析"],"title":"csv2 源码剖析：轻量级 CSV 处理的高效之道","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r9. 模板默认参数reader.hpp 有默认模板参数的写法: 在 C++ 17 之前，如果不用任何模板参数且正常使用 Reader 类的话，需要使用如下语法: Reader\u003c\u003e reader; 将 CMakeLists.txt 中的 C++版本由 14 set(CMAKE_CXX_STANDARD 14) 改为 17 set(CMAKE_CXX_STANDARD 17) 即可用如下轻便的语法使用 Reader。 Reader reader; ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:9","tags":["CSV","C++","源码剖析"],"title":"csv2 源码剖析：轻量级 CSV 处理的高效之道","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r10. std::forwardhttps://cplusplus.com/reference/utility/forward/ 通过使用std::forward函数可以根据实参调用不同的函数，如下面例子所示: #include \u003cutility\u003e // std::forward #include \u003ciostream\u003e // std::cout // function with lvalue and rvalue reference overloads: void overloaded (const int\u0026 x) {std::cout \u003c\u003c \"[lvalue]\";} void overloaded (int\u0026\u0026 x) {std::cout \u003c\u003c \"[rvalue]\";} // function template taking rvalue reference to deduced type: template \u003cclass T\u003e void fn (T\u0026\u0026 x) { overloaded (x); // always an lvalue overloaded (std::forward\u003cT\u003e(x)); // rvalue if argument is rvalue } int main () { int a; std::cout \u003c\u003c \"calling fn with lvalue: \"; fn (a); std::cout \u003c\u003c '\\n'; std::cout \u003c\u003c \"calling fn with rvalue: \"; fn (0); std::cout \u003c\u003c '\\n'; return 0; } ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:10","tags":["CSV","C++","源码剖析"],"title":"csv2 源码剖析：轻量级 CSV 处理的高效之道","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r11. std::stringhttps://cplusplus.com/reference/string/string/ string::erase 可用于清除指定位置的字符。 string::reserve 可用于指定 string 存储空间的大小。 string::push_back 可将字符存入 string 中。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:11","tags":["CSV","C++","源码剖析"],"title":"csv2 源码剖析：轻量级 CSV 处理的高效之道","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r最后项目中涉及到的存储映射 I/O ，若要想彻底弄清楚机制，可能需要补充一些操作系统方面的知识。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:4:0","tags":["CSV","C++","源码剖析"],"title":"csv2 源码剖析：轻量级 CSV 处理的高效之道","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["数据科学"],"content":"在当今数据驱动的世界中，从大规模数据分析到精准预测模型，数据科学正在塑造我们的决策方式。而在众多数据科学工具中，R 凭借其强大的统计分析能力和丰富的社区资源，成为数据科学家和分析师的首选之一。那么，如何利用 R 优雅地解锁数据的潜力？让我们从基础开始，逐步探索 R 的神奇之处。 ","date":"2024-08-26","objectID":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/:0:0","tags":["R","数据科学","数据可视化","数据分析"],"title":"R数据科学","uri":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"},{"categories":["数据科学"],"content":"\r数据框和 Tibble","date":"2024-08-26","objectID":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/:1:0","tags":["R","数据科学","数据可视化","数据分析"],"title":"R数据科学","uri":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"},{"categories":["数据科学"],"content":"\r数据框在 R 语言中，对于不同的列可以包含不同数据类型的数据，我们可以用data.frame()函数创建数据框： data \u003c- data.frame(col1, col2, col3,...) 其中的列向量col1、col2、col3等可为任何类型，比如字符型，数值型或逻辑型。每一列的名称可由函数names()指定。 我们来看一个例子： patientID \u003c- c(1:4) age \u003c- c(25, 34, 28, 52) status \u003c- c(\"Poor\", \"Improved\", \"Excellent\", \"Poor\") diabetes \u003c- c(\"Type1\", \"Type2\", \"Type1\", \"Type1\") patientData \u003c- data.frame(patientID, age, diabetes, status) 如果要选取某些列数据，我们可以如下几种方式： patientData[1] ## 选取第1列数据 patientData[1:3] ## 选取第1,2,3列数据 patientData[c(1,3)] ## 选取第1,3列数据 patientData[\"age\"] ## 选取age列数据 patientData[c(\"age\", \"patientID\")] ## 选取age列和patientID列数据 patientData$age ## 选取age列数据 ","date":"2024-08-26","objectID":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/:1:1","tags":["R","数据科学","数据可视化","数据分析"],"title":"R数据科学","uri":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"},{"categories":["数据科学"],"content":"\r创建 tibbletibble 是一种简单数据框，它对传统的数据框的功能进行了修改，以便让其更易于使用。tibble 是 tidyverse 的标准功能之一，由于多数其他 R 包使用的是标准数据框，因此可能需要将数据框转换为 tibble，为此我们可以使用as_tibble()函数来进行转换： as_tibble(patientData) 可以通过tibble()函数使用一个向量来创建新 tibble。tibble()会自动重复长度为 1 的输入，并且可以使用刚创建的变量，如下所示： tibble( x = 1:5, y = 1, z = x ^ 2 + y ## 使用刚创建的变量x ) 创建 tibble 的另一种方法是使用tribble()函数，tribble 是 transposed tibble 的缩写，其对数据按行进行编码，列标题由公式（以~开头）定义，数据条目以逗号分隔。 tribble(~x, ~y, ~z, \"a\", 1, 7, \"b\", 2, 3 ) ","date":"2024-08-26","objectID":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/:1:2","tags":["R","数据科学","数据可视化","数据分析"],"title":"R数据科学","uri":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"},{"categories":["数据科学"],"content":"\rtibble 和数据框对比tibble 和传统的数据框的使用方法主要有两处不同：打印和取子集。 打印tibble 的打印方法进行了优化，只显示前 10 行结果，并且列也是适合屏幕的，这种方式非常适合大数据集。除了打印列命，tibble 还会打印出列的数据类型。 在打印大数据框时，tibble 的这种设计避免了输出占满整个控制台。但有时需要比默认显示更多的输出，这时可以设置几个选项。 可以明确使用print()函数来打印数据框，并控制打印的行数（n）和显示的宽度（width）。width = Inf可以显示出所有列： nycflights13::flights %\u003e% print(n = 10, width = Inf) 还可以设置以下选项来控制默认的打印方式。 options(tibble.print_min = Inf)总是打印所有行。 options(tibble.width = Inf)总是打印所有列。 取子集如果我们想提取单个变量，我们可以使用$和[[]]，[[]]可以按名称或位置提取变量，而$只能按名称提取。 df \u003c- tibble( x = runif(5), y = rnorm(5) ) ## 按名称提取 df$x df[[\"x\"]] ## 按位置提取 df[[1]] 要想在管道中使用这些提取操作，需要使用特殊的占位符.： df %\u003e% .$x df %\u003e% .[[\"x\"]] 与data.frame相比，tibble 更严格：它不能进行部分匹配，如果想要访问的列不存在，会产生一条警告信息。 有些比较旧的函数不支持 tibble，此时我们可以使用as.data.frame()函数将 tibble 转换为data.frame。 ","date":"2024-08-26","objectID":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/:1:3","tags":["R","数据科学","数据可视化","数据分析"],"title":"R数据科学","uri":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"},{"categories":["数据科学"],"content":"\r探索性数据分析统计学家将使用可视化方法和数据转换来系统化地探索数据称为探索性数据分析（exploratory data analysis, EDA）。 EDA 期间的目标是获取对数据的理解。将问题作为指导调查研究的工具是进行 EDA 的最简单方式。 该提出什么样的问题来指导我们对数据的研究并没有确定的规则。但总有两类问题总是有助于我们理解数据，这两类问题大致如下： 变量本身会发生哪种变化？ 不同变量之间会发生哪种相关变化？ 本文中用到的数据集为如上所示的表格结构，每列是每个变量的值，每行称为一个观测或者样本，一个观测会包含多个值，每个值关联到不同变量，有时也将观测称为数据点。 上图为Diamonds数据集，其中： carat表示克拉重量 cut表示切割（Levels: Fair \u003c Good \u003c Very Good \u003c Premium \u003c Ideal） color表示成色（Levels: D \u003c E \u003c F \u003c G \u003c H \u003c I \u003c J） clarity表示净度（Levels: I1 \u003c SI2 \u003c SI1 \u003c VS2 \u003c VS1 \u003c VVS2 \u003c VVS1 \u003c IF） depth表示深度 table表示台面 price表示价格 x，y和z和含义如下图所示： 更多关于钻石的知识请参考：https://www.bluenile.com/cn/education/diamonds 每个变量的值都会有各自的变化模式，可以揭示一些有趣的信息。理解这种模式的最好方法就是对变量值的分布进行可视化分表示。 ","date":"2024-08-26","objectID":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/:2:0","tags":["R","数据科学","数据可视化","数据分析"],"title":"R数据科学","uri":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"},{"categories":["数据科学"],"content":"\r单个变量\r分类变量对变量值的分布进行可视化表示取决于变量是分类变量还是连续变量。如果一个变量的值仅在较小的集合内取值，那么这个变量就是分类变量。要想表示分类变量的分布，我们可以使用条形图： library(ggplot2) ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut)) 结果如下： 条形的高度表示每个x值观测的数量，可以用dplyr::count()手动计算出这些值： 连续变量如果一个变量可以在无限大的有序集合中任意取值，那么这个变量就是连续变量。数值型和日期时间型变量就是连续变量的两个例子。要想表示连续变量的分布，可以使用直方图： ggplot(data = diamonds) + geom_histogram(mapping = aes(x = carat), binwidth = 0.5) 我们也可以使用dplyr::count()和ggplot2::cut_width()函数的组合来手动计算结果： 直方图对 x 轴进行等宽分箱，然后使用条形的高度表示落入每个分箱的观测的数量。我们可以用binwidth参数来设定直方图中间隔的宽度，该参数用 x 轴变量的单位来度量的。不同的分箱宽度可以揭示不同的模式。比如，如果只考虑重量小于 3 克拉的钻石，并选择一个更小的分箱宽度，结果如下： diamonds %\u003e% filter(carat \u003c 3) %\u003e% ggplot(mapping = aes(x = carat)) + geom_histogram(binwidth = 0.1) 若想在一张图中叠加多个直方图，那么我们可以用geom_freqploy()函数来代替geom_histogram()函数，该函数使用的是折线图，相比一下更加容易理解： diamonds %\u003e% filter(carat \u003c 3) %\u003e% ggplot(mapping = aes(x = carat, color = cut)) + geom_freqpoly(binwidth = 0.1) 典型值条形图和直方图都用比较高的条形表示变量中的常见值，而用比较矮的条形表示变量中不常见的值，没有条形的位置表示数据中没有这样的值。 针对这些信息，我们提出一些问题，比如： 哪些值是最常见的？为什么？ 哪些值是很罕见的？为什么？符合预期吗？ 有什么异常的模式吗？如何解释？ diamonds %\u003e% filter(carat \u003c 3) %\u003e% ggplot(mapping = aes(x = carat)) + geom_histogram(binwidth = 0.01) 异常值异常值是与众不同的观测或是模式之外的数据点。有时异常值是由于数据录入错误而产生的。若数据量比较大，有时很难在直方图上发现异常值。查看Diamonds数据集中 y 轴变量的分布，唯一能表示存在异常值的证据是 y 轴的取值范围出奇的宽： ggplot(data = diamonds) + geom_histogram(mapping = aes(x = y), binwidth = 0.5) 由于正常值分箱中的观测值太多，以至于包括异常值的分箱高度太低，导致我们根本看不见。为了更容易发现异常值，我们可以使用coord_cartesian()函数将 y 轴靠近 0 的部分放大： ggplot(data = diamonds) + geom_histogram(mapping = aes(x = y), binwidth = 0.5) + coord_cartesian(ylim = c(0, 50)) 从上图可以看到有 3 个异常值，分别位于 0，30 左右和 60 左右。我们可以将其找出来： y变量的单位为毫米。钻石的宽度不可能为 0 毫米，因此这些值肯定是错误的，而 32 毫米和 59 毫米是难以置信的。 使用带有异常值和不带异常值的数据分别进行分析，是一种良好的做法。如果两次分析的结果差别不大，而又无法说明为什么会有异常值，那么完全可以用缺失值代替异常值，然后继续进行分析。但如果两次分析的结果有显著差别，那么就不能在没有正当理由下丢弃它们。需要弄清出现异常值的原因（如数据输入错误），并在文章中说明丢弃它们的理由。 ","date":"2024-08-26","objectID":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/:2:1","tags":["R","数据科学","数据可视化","数据分析"],"title":"R数据科学","uri":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"},{"categories":["数据科学"],"content":"\r缺失值如果在数据集中发现异常值，但想继续分析工作，那么有两种选择。 将带有可疑值的行全部丢弃 diamonds2 \u003c- diamonds %\u003e% filter(between(y, 3, 20)) 使用缺失值代替异常值 diamonds2 \u003c- diamonds %\u003e% mutate(y = ifelse(y \u003c 3 | y \u003e 20, NA, y)) 有时会想弄清楚造成有缺失值的观测和没有缺失值的观测的原因。例如，在nycflights::flights中，dep_time变量中的缺失值表示航班取消了。我们比较一下已取消航班和未取消航班的计划出发时间。可以使用is.na()函数创建一个新变量来完成此操作： nycflights13::flights %\u003e% mutate(cancelled = is.na(dep_time), sched_hour = sched_dep_time %/% 100, sched_min = sched_dep_time %% 100, sched_dep_time = sched_hour + sched_min / 60 ) %\u003e% ggplot(mapping = aes(x = sched_dep_time)) + geom_freqpoly(mapping = aes(color = cancelled), binwidth = 1 / 4) ","date":"2024-08-26","objectID":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/:2:2","tags":["R","数据科学","数据可视化","数据分析"],"title":"R数据科学","uri":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"},{"categories":["数据科学"],"content":"\r多个变量之前涉及到的主要是单个变量的变化模式，现在我们将主要集中于两个或多个变量间的关系。 分类变量与连续变量我们经常需要探索连续变量的分布，如果一组观测的数量明显少于其他组的话，就很难看出形状上的差别。例如，我们探索一下钻石价格是如何随着切割而变化的： ggplot(data = diamonds, mapping = aes(x = price)) + geom_freqpoly(mapping = aes(color = cut), binwidth = 500) 很难看出分布上的区别，因为总体看来各组数量的差别太大了。为了让比较变得容易，需要改变 y 轴的显示内容，不再显示计数，而是显示密度。密度是对计数的标准化，这样每个频率多边形下边的面积都是 1： ggplot(data = diamonds) + geom_freqpoly(mapping = aes(x = price, y = ..density.., color = cut), binwidth = 500) 按分类变量的分组显示连续变量分布的另一种方式是使用箱线图。箱线图是对变量值分布的一种简单可视化表示。我们可以使用geom_boxplot()函数查看按切割分类的价格分布： ggplot(data = diamonds) + geom_boxplot(mapping = aes(x = cut, y = price)) 上图看不出太多关于分布的信息，但其更加紧凑，因此可以更加容易地比较多个类别。 两个分类变量要想对两个分类变量间的相关变动进行可视化表示，需要计算出每个变量组合中的的观测数量，我们可以使用geom_count()函数完成这个任务： ggplot(data = diamonds) + geom_count(mapping = aes(x = cut, y = color)) 每个圆点的大小表示每个变量组合的观测数量。 另一种方法是使用dplyr： 接着使用geom_tile()函数和填充图形属性进行可视化表示： diamonds %\u003e% count(color, cut) %\u003e% ggplot(mapping = aes(x = color, y = cut)) + geom_tile(mapping = aes(fill = n)) 两个连续变量对于两个连续变量间的相关关系的可视化表示，我们可以使用geom_point()函数绘制散点图。例如，可以看到钻石的克拉重量和价格之间存在着指数关系： ggplot(data = diamonds) + geom_point(mapping = aes(x = carat, y = price)) 当数据量不断增加时，数据点会堆积在一片黑色区域中，我们可以使用alpha图形属性添加透明度： ggplot(data = diamonds) + geom_point(mapping = aes(x = carat, y = price), alpha = 1 / 100) 但很难对特别大的数据集使用透明度。另一种解决办法是使用分箱。之前使用了geom_histogram()和geom_freqpoly()函数在一个维度上进行分箱，我们可以使用geom_bin2d()和geom_hex()函数在两个维度上进行分箱。 geom_bin2d()和geom_hex()函数将坐标平面分为二维分箱，并使用一种填充颜色表示落入每个分箱的数据点。geom_bin2d()创建长方形分箱。geom_hex()创建六边形分箱。 ggplot(data = diamonds) + geom_bin2d(mapping = aes(x = carat, y = price)) install.packages(\"hexbin\") library(hexbin) ggplot(data = diamonds) + geom_hex(mapping = aes(x = carat, y = price)) 另一种方式是对一个连续变量进行分箱，因此该连续变量的作用就相当于分类变量。之后就可以使用前面学过的对分类变量和连续变量的组合进行可视化的技术了。例如，可以对carat进行分箱，然后为每个组生成一个箱线图： diamonds %\u003e% filter(carat \u003c 3) %\u003e% ggplot(mapping = aes(x = carat, y = price)) + geom_boxplot(mapping = aes(group = cut_width(carat, 0.1))) 另一种方法是近似地显示每个分箱中数据点的数量，此时可以使用cut_number()函数： diamonds %\u003e% filter(carat \u003c 3) %\u003e% ggplot(mapping = aes(x = carat, y = price)) + geom_boxplot(mapping = aes(group = cut_number(carat, 20))) ","date":"2024-08-26","objectID":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/:2:3","tags":["R","数据科学","数据可视化","数据分析"],"title":"R数据科学","uri":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"},{"categories":["数据科学"],"content":"\rTED 数据集分析我们已经初步了解了探索性数据分析的整体流程，接下来将用 TED 演讲数据集进行练习。TED 演讲数据集可以在和鲸社区或者Kaggle下载，该数据集包含两个文件： ted_main.csv transcripts.csv 文件 ted_main.csv 包含 17 个字段，具体含义如下： # 属性 数据类型 含义 1 name Integer 演讲的正式名称（主要发言人+标题） 2 title String 演讲的标题 3 description Integer 演讲内容 4 main_speaker String 主要发言人 5 speaker_occupation Integer 主要发言人职业 6 num_speaker Integer 发言人数量 7 duration Integer 演讲时长（以秒为单位） 8 event String 演讲所在的 TED/TEDx 活动 9 film_date Integer 演讲拍摄时间（Unix timestamp） 10 published_date Integer 演讲发布时间（Unix timestamp） 11 comments Integer 评论数量 12 tags String 与演讲相关的主题标签 13 languages String 收听演讲时可选择的语言数量 14 ratings String 一个列表，里面包含许多字典，每个字典是不同的演讲评级（如鼓舞人心，引人入胜，令人惊讶等） 15 related_talks String 一个列表，里面包含许多字典，每个字典是下一个值得观看的演讲推荐 16 url String 演讲的 URL 链接 17 views Integer 观看数量 文件 transcript.csv 包含 2 个字段，具体含义如下： # 属性 数据类型 含义 1 transcript String 演讲的官方英文字幕 2 url String 演讲的 URL 链接 加载数据集我们先将数据集进行加载： library(readr) ted \u003c- read_csv(\"F:/data_science_datasets/tedtalk/ted_main.csv\") transcript \u003c- read_csv(\"F:/data_science_datasets/tedtalk/transcripts.csv\") 查看一下数据的维度： dim(ted) dim(transcript) 数据质量诊断数据质量诊断（Data quality diagnosis）可以使用dlookr包的diagnose函数对数据集进行查看： library(dlookr) diagnose(ted) 可以看到只有speaker_occupation列有缺失值。 Data quality diagnosis：https://cran.r-project.org/web/packages/dlookr/vignettes/diagonosis.html 数据转换当前，film_date和pushlished_date字段中存储的是 Unix 时间戳，我们将其转换为日期： library(anytime) ted$film_date \u003c- anydate(ted$film_date) ted$published_date \u003c- anydate(ted$published_date) 单个变量\r分类变量对于单个分类变量，我们想知道speaker_occupation字段的情况，例如最热门的 10 个职业是什么？ occupation_df \u003c- as.data.frame(table(ted$speaker_occupation)) colnames(occupation_df) \u003c- c(\"Occupation\", \"Counts\") occupation_df \u003c- arrange(occupation_df, desc(Counts)) top_occupation_df \u003c- head(occupation_df, 10) ggplot(data = top_occupation_df, mapping = aes(x = Occupation, y = Counts)) + geom_bar(mapping = aes(fill = Occupation), stat = \"identity\") + geom_text(mapping = aes(label = Counts), vjust = 1.6, color = \"white\", size = 3) + ggtitle(\"Occupations of Ted Speakers vs their Counts\") + theme(axis.text.x=element_text(angle=45, hjust=1)) TED 最热门的 10 大职业如上图所示。 连续变量对于单个连续变量，我们想知道duration字段的情况。 ggplot(data = ted) + geom_histogram(mapping = aes(x = duration), binwidth = 100) 可以看到，TED 演讲时长主要集中在 800~1100 秒之间。 多个变量\r分类变量与连续变量speaker_occupation是分类变量，而views是连续变量，现在我们探索一下 10 大热门职业 TED 演讲的观看数量。 top_occupation_views \u003c- filter(ted, ted$speaker_occupation %in% top_occupation_df$Occupation) ggplot(data = top_occupation_views, mapping = aes(x = speaker_occupation, y = views, fill = speaker_occupation)) + geom_boxplot() + geom_jitter(shape=16, position=position_jitter(0.2), alpha = 0.1) + theme(axis.text.x=element_text(angle=45, hjust=1)) 可以看到，与其他职业相比，作家的 TED 演讲观看数量分布最广且正偏（上侧的须较下侧的须更长）。整体而言，作家的 TED 演讲观看数量最大。 两个分类变量接下来，我们探究一下event和speaker_occupation两个分类变量之间的关系。 event_df \u003c- as.data.frame(table(ted$event)) colnames(event_df) \u003c- c(\"Event\", \"Counts\") event_df \u003c- arrange(event_df, desc(Counts)) top_event_df \u003c- head(event_df, 10) event_occupation_df \u003c- filter(ted, speaker_occupation %in% top_occupation_df$Occupation \u0026 event %in% top_event_df$Event) ggplot(data = event_occupation_df) + geom_count(mapping = aes(x = event, y = speaker_occupation)) + theme(axis.text.x=element_text(angle=45, hjust=1)) 两个连续变量最后，我们查看一下comments和views两个连续变量之间的关系。 ggplot(data = ted) + geom_point(mapping = aes(x = views, y = comments)) cor(ted$views, ted$comments) # 0.5309387 相关系数为 0.5309387 表明comments和views之间有较强相关性。 ","date":"2024-08-26","objectID":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/:2:4","tags":["R","数据科学","数据可视化","数据分析"],"title":"R数据科学","uri":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"},{"categories":["数据科学"],"content":"\r推荐Best ggplot visualization：https://nextjournal.com/jk/best-ggplot TED Talk Analysis in R：https://www.kaggle.com/kratisaxena/ted-talk-analysis-in-r ","date":"2024-08-26","objectID":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/:3:0","tags":["R","数据科学","数据可视化","数据分析"],"title":"R数据科学","uri":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"},{"categories":["数据科学"],"content":"\r参考 《R 数据科学》 《R 语言实战 》第 2 版 ","date":"2024-08-26","objectID":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/:4:0","tags":["R","数据科学","数据可视化","数据分析"],"title":"R数据科学","uri":"/r%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"},{"categories":["源码剖析"],"content":"Node.js 的诞生，让 JavaScript 从浏览器的专属语言，跃升为构建高性能服务器的利器。凭借事件驱动的架构和非阻塞 I/O 特性，Node.js 成为现代网络应用开发中的重要基石。然而，当你写下 http.createServer时，是否好奇过这些简单的 API 背后究竟发生了什么？ 本篇文章将带你深入 Node.js 的源码世界，揭开其核心模块、事件循环、异步模型和底层实现的神秘面纱。从 libuv 的非阻塞 I/O，到 V8 引擎对 JavaScript 的极速解析，我们将从代码的视角探索 Node.js 是如何在性能与灵活性之间找到绝佳平衡的。 无论你是想提升对 Node.js 的理解，还是希望从源码中汲取工程设计的智慧，这都将是一次充满收获的技术旅程。准备好了吗？让我们从入口文件开始，走进 Node.js 的源码迷宫！ ","date":"2024-06-27","objectID":"/node.js%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:0:0","tags":["Node.js","运行时","非阻塞","异步","事件驱动","源码剖析"],"title":"Node.js 源码剖析：非阻塞世界的引擎密码","uri":"/node.js%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r参考 Node.js 源码剖析 《深入浅出 Node.js》朴灵 ","date":"2024-06-27","objectID":"/node.js%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:1:0","tags":["Node.js","运行时","非阻塞","异步","事件驱动","源码剖析"],"title":"Node.js 源码剖析：非阻塞世界的引擎密码","uri":"/node.js%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":null,"content":" 这里汇集了各个领域中整理的优质学习资源和实用工具，不论是编程与技术，还是人文与艺术，你都能在这里找到适合自己的内容。不论你是初学者，还是在追求多元知识的探索者，我都希望这些资源能为你的学习旅程带来启发和帮助。从深度教程到精选书单，从实用工具到开源项目。希望这些内容能助你高效学习，发现更多有趣的知识世界！✨ ","date":"2024-02-26","objectID":"/resource/:0:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\r计算机科学导论计算机科学速成课 - Crash Course Computer Science 哈佛大学公开课：计算机科学 cs50 ","date":"2024-02-26","objectID":"/resource/:1:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\r计算机组成陆俊林 计算机组成 CSE 351: The Hardware/Software Interface ","date":"2024-02-26","objectID":"/resource/:2:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\r操作系统向勇 操作系统 6.828: Operating System Engineering os-tutorial: How to create an OS from scratch 李治军 操作系统 哈工大操作系统实验手册 实验楼 操作系统原理与实践 ","date":"2024-02-26","objectID":"/resource/:3:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\r数据库6.830/6.814: Database Systems SQL Tutorial for Beginners with MySQL ","date":"2024-02-26","objectID":"/resource/:4:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\r分布式系统Distributed Systems 6.824: Distributed Systems ","date":"2024-02-26","objectID":"/resource/:5:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\r计算机网络Computer Networking Tutorial: The Ultimate Guide ","date":"2024-02-26","objectID":"/resource/:6:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\r编译器华保健 编译原理 Compilers B 站观看 Compiler Design Implementing a Regular Expression Engine 自己动手写编译器: 本书将介绍一个非常简单的编译器（ TinyC 编译器）的实现，用简单和易于实现的实例来描述基本的编译原理及过程，希望能为学习编译原理的读者提供一些参考。 ","date":"2024-02-26","objectID":"/resource/:7:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\r密码学Christof Paar - Introduction to Cryptography ","date":"2024-02-26","objectID":"/resource/:8:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rFrontendTop 10 Frontend Frameworks of 2018 前端开发学习路线 ","date":"2024-02-26","objectID":"/resource/:9:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rC翁恺 C 语言程序设计 Practical Programming in C Introduction to C Memory Management and C++ Object-Oriented Programming Let’s Build a Simple Database Tinyhttpd: Tinyhttpd 是 J. David Blackstone 在 1999 年写的一个不到 500 行的超轻量型 Http Server，用来学习非常不错，可以帮助我们真正理解服务器程序的本质。 json-tutorial: 从零开始的 JSON 库教程。 project-based-tutorials-in-c: A curated list of project-based tutorials in C awesome-c: A curated list of awesome C frameworks, libraries, resources and other shiny things. Inspired by all the other awesome-… projects out there. awesome-c: Continuing the development of awesome-c list on GitHub ","date":"2024-02-26","objectID":"/resource/:10:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rC++郑莉 C++语言程序设计基础 和 C++语言程序设计进阶 CS106X: Programming Abstractions in C++ CS106B: Programming Abstractions in C++ B 站观看 muduo: Event-driven network library for multi-threaded Linux server in C++11. MyTinySTL: Achieve a tiny STL in C++11. musikcube: a cross-platform, terminal-based music player, audio engine, metadata indexer, and server in c++. C++ 跟侯捷学 C++: 系统学习 C++知识体系。 sudoku: C++实现的跨平台数独游戏，命令行操作易上手，可以在开发间隙用来放松身心。数百行代码，初学者也可以轻松掌握。 LearnCpp.com: LearnCpp.com is a free website devoted to teaching you how to program in C++. Whether you’ve had any prior programming experience or not, the tutorials on this site will walk you through all the steps to write, compile, and debug your C++ programs, all with plenty of examples. Learn OpenGL: Welcome to the online book for learning OpenGL! Whether you are trying to learn OpenGL for academic purposes, to pursue a career or simply looking for a hobby, this book will teach you the basics, the intermediate, and all the advanced knowledge using modern (core-profile) OpenGL. The aim of LearnOpenGL is to show you all there is to modern OpenGL in an easy-to-understand fashion with clear examples, while also providing a useful reference for later studies. awesome-modern-cpp: A collection of resources on modern C++ Awesome C++: A curated list of awesome C++ (or C) frameworks, libraries, resources, and shiny things. Inspired by awesome-… stuff. ","date":"2024-02-26","objectID":"/resource/:11:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rC#Learn C# by Building a Simple RPG: If you want to write a Role Playing Game, but don’t know how to program, or just want to learn how to program in C#, then you’re at right the place. ","date":"2024-02-26","objectID":"/resource/:12:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rPythonc9-python-getting-started: Sample code for Channel 9 Python for Beginners course 计算机科学和 Python 编程导论 CS 61A: Structure and Interpretation of Computer Programs Python 教程 Let’s Build A Simple Interpreter httpstat: httpstat 美化了 curl 的结果，使得结果更加可读。 reddit: reddit 网站的源码。 500lines: 500 Lines or Less. you-get: ⏬ Dumb downloader that scrapes the web scrapydweb: Web app for Scrapyd cluster management, Scrapy log analysis \u0026 visualization, Auto packaging, Timer tasks, Monitor \u0026 Alert, and Mobile UI. manim: Animation engine for explanatory math videos scylla: Intelligent proxy pool for Humans™ wttr.in: ⛅️ The right way to check the weather https://wttr.in spug: 开源运维平台：面向中小型企业设计的轻量级无 Agent 的自动化运维平台，整合了主机管理、主机批量执行、主机在线终端、文件在线上传下载、应用发布部署、在线任务计划、配置中心、监控、报警等一系列功能。 learn_python3_spider: python 爬虫教程系列、从 0 到 1 学习 python 爬虫，包括浏览器抓包，手机 APP 抓包，如 fiddler、mitmproxy，各种爬虫涉及的模块的使用，如：requests、beautifulSoup、selenium、appium、scrapy 等，以及 IP 代理，验证码识别，Mysql，MongoDB 数据库的 python 使用，多线程多进程爬虫的使用，css 爬虫加密逆向破解，JS 爬虫逆向，分布式爬虫，爬虫项目实战实例等。 ","date":"2024-02-26","objectID":"/resource/:13:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rJavaIntroduction to Programming in Java CS106A - Programming Methodology Java 教程 Java Tutorial, Java EE Tutorials 深入浅出 Java 多线程 JavaWeb 学习总结: 详尽的 JavaWeb 学习总结，Servlet/学习推荐阅读！ istock: 👉 一个基于 spring boot 实现的 java 股票爬虫(仅支持 A 股)，如果你 ❤️ 请 ⭐️ . V2 升级版正在开发中！ vhr: 微人事是一个前后端分离的人力资源管理系统，项目采用 SpringBoot+Vue 开发。 toBeTopJavaer: To Be Top Javaer - Java 工程师成神之路 tech-weekly: 小马哥技术周报 web: 适合 java 新手入门练习的 java web 个人网站项目，目前主要维护 web-mysql 和 web-psql 两个分支。前台包括博客、代码库、文件下载、留言、登录注册、站内搜索、分类目录等功能，后台包括上传文件、博客、代码，编辑、删除文章，修改个人资料等功能，目前暂停开发新功能。 mall: mall 项目是一套电商系统，包括前台商城系统及后台管理系统，基于 SpringBoot+MyBatis 实现，采用 Docker 容器化部署。 halo: ✍ Halo 一款现代化的个人独立博客系统 jblog: 🔱 一个简洁漂亮的 java blog 👉 基于 Spring /MVC+ Hibernate + MySQL + Bootstrap + freemarker SeimiCrawler: 一个简单、敏捷、分布式的支持 SpringBoot 的 Java 爬虫框架;An agile, distributed crawler framework. spring-boot-examples: Spring Boot 教程、技术栈示例代码，快速简单上手教程。 SpringAll: 循序渐进，学习 Spring Boot、Spring Boot \u0026 Shiro、Spring Cloud、Spring Security \u0026 Spring Security OAuth2，博客 Spring 系列源码。 My-Blog: 🌴:octocat:A simple \u0026 beautiful blogging system implemented with spring-boot \u0026 thymeleaf \u0026 mybatis My Blog 是由 SpringBoot + Mybatis + Thymeleaf 等技术实现的 Java 博客系统，页面美观、功能齐全、部署简单及完善的代码，一定会给使用者无与伦比的体验 jsoup: Java HTML Parser JavaGuide: 【Java 学习+面试指南】 一份涵盖大部分 Java 程序员所需要掌握的核心知识。 MusicPlayer: Desktop Music Player for Windows and Mac using JavaFX/Java 8 giffun: 一款开源的 GIF 在线分享 App，乐趣就要和世界分享。 symphony: 🎶 A modern community (forum/BBS/SNS/blog) platform implemented in Java. 一款用 Java 实现的现代化社区（论坛/BBS/社交网络/博客）平台。 cim: 📲cim(cross IM) 适用于开发者的分布式即时通讯系统 advanced-java: 😮 互联网 Java 工程师进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务、海量数据处理等领域知识 ","date":"2024-02-26","objectID":"/resource/:14:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rGoLearn Go Programming - Golang Tutorial for Beginners gogs: 用 Go 写的一款极易搭建的自助 Git 服务，支持所有平台。就像 GitLab 一样的服务，但是 GitLab 是基于 ruby 语言的。另外：完善的中文文档、支持 Go 语言支持的所有平台，包括 Linux、Mac OS X、Windows 以及 ARM 平台。 pan-light: 百度网盘不限速客户端, golang + qt5, 跨平台图形界面 unioffice: Pure go library for creating and processing Office Word (.docx), Excel (.xlsx) and Powerpoint (.pptx) documents. geziyor: Geziyor, a fast web crawling \u0026 scraping framework for Go. Supports JS rendering. annie: 👾 Fast, simple and clean video downloader 7days-golang: 7 days golang apps from scratch ","date":"2024-02-26","objectID":"/resource/:15:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rRubydiscourse: A platform for community discussion. ","date":"2024-02-26","objectID":"/resource/:16:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rRR for Graduate Students Introduction to Data Science R Programming for Data Science Data Visualization with R: R is an amazing platform for data analysis, capable of creating almost any type of graph. This book helps you create the most popular visualizations - from quick and dirty plots to publication-ready graphs. The text relies heavily on the ggplot2 package for graphics, but other approaches are covered as well. ggplot2: Elegant Graphics for Data Analysis: This is the on-line version of work-in-progress 3rd edition of “ggplot2: elegant graphics for data analysis” published by Springer. You can learn what’s changed from the 2nd edition in the Preface. R Graphics Cookbook, 2nd edition: Welcome to the R Graphics Cookbook, a practical guide that provides more than 150 recipes to help you generate high-quality graphs quickly, without having to comb through all the details of R’s graphing systems. Each recipe tackles a specific problem with a solution you can apply to your own project, and includes a discussion of how and why the recipe works. R for Excel Users: This course is for Excel users who want to add or integrate R and RStudio into their existing data analysis toolkit. It is a friendly intro to becoming a modern R user, full of tidyverse, RMarkdown, GitHub, collaboration \u0026 reproducibility. 李东风的主页 UC Business Analytics R Programming Guide The openair book Tools for air quality data analysis R CODER: Begin your data science career with R language! Hands-On Machine Learning with R Mastering Spark with R Modern Data Science with R R for Data Science Text Mining with R: A Tidy Approach Modern R with the tidyverse ","date":"2024-02-26","objectID":"/resource/:17:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rJavaScriptJavaScript Tutorial The Modern JavaScript Tutorial JavaScript 教程 cdfang-spider: 成都房协网爬虫，可视化数据分析 request: 🏊🏾 Simplified HTTP request client. vanillawebprojects: Mini projects built with HTML5, CSS \u0026 JavaScript. No frameworks or libraries. Learn-Vue-Source-Code: 🔥 🔥 逐行剖析 Vue.js 源码 在线阅读地址https://nlrx-wjc.github.io/Learn-Vue-Source-Code/ 100+ JavaScript Projects for Beginners!: Do all 100+ of the listed JavaScript Projects for beginners that you’ll find on this page. javascript-algorithms: 📝 Algorithms and data structures implemented in JavaScript with explanations and links to further readings ","date":"2024-02-26","objectID":"/resource/:18:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rNode.jsHow to start a Node.js project Express web framework (Node.js/JavaScript) Nodejs-Roadmap: 【Nodejs-Roadmap】侧重于 Node.js 服务端的开发指南 ","date":"2024-02-26","objectID":"/resource/:19:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rJuliaFrom zero to Julia!: An expanding series of short tutorials about Julia, starting from the beginner level and going up to deal with the more advanced topics. ","date":"2024-02-26","objectID":"/resource/:20:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rSwiftSwift-30-Projects: 30 mini Swift Apps for self-study. ","date":"2024-02-26","objectID":"/resource/:21:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rMatlabA Quick Tutorial on MATLAB Introduction to MATLAB: This is an accelerated introduction to MATLAB® and its popular toolboxes. Lectures are interactive, with students conducting sample MATLAB problems in real time. The course includes problem-based MATLAB assignments. Students must provide their own laptop and software. This is great preparation for classes that use MATLAB. Introduction To MATLAB Programming: This course is intended to assist undergraduates with learning the basics of programming in general and programming MATLAB® in particular. ","date":"2024-02-26","objectID":"/resource/:22:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rLinuxThe Best Linux Tutorials Linux 工具快速教程 The Linux Command Line Unix \u0026 Linux 大学教程 Linux Tutorial ","date":"2024-02-26","objectID":"/resource/:23:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rDockerDocker 入门教程 Docker 微服务教程 ","date":"2024-02-26","objectID":"/resource/:24:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rCodingGoogle 开源项目风格指南 Learning-SICP: MIT 视频公开课《计算机程序的构造和解释》中文化项目及课程学习资料搜集。 ","date":"2024-02-26","objectID":"/resource/:25:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\r提问提問的智慧: 本文原文由知名 Hacker Eric S. Raymond 所撰寫，教你如何正確的提出技術問題並獲得你滿意的答案。 ","date":"2024-02-26","objectID":"/resource/:26:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\r游戏Game Engine ","date":"2024-02-26","objectID":"/resource/:27:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rElasticsearchElasticsearch: 权威指南 ","date":"2024-02-26","objectID":"/resource/:28:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rData Structure \u0026 AlgorithmsWhat is your strategy for learning data structures and algorithms? The BEST way to learn Data Structures and Algorithms Problem Solving with Algorithms and Data Structures using Python Learn data structures from scratch in C, Java and Python CS 61B Data Structures, Fall 2019 Stanford Algorithm Part 1 and Part 2 邓俊辉 数据结构(上) 和 数据结构(下) 数据结构(C++语言版) 陈越 何钦铭 数据结构 Data Structure by Saurabh Shukla Sir - YouTube Data Structures Tutorial Videos | Mr. Srinivas - YouTube Introduction to Algorithms Design and Analysis of Algorithms Advanced Algorithms Data Structures and Algorithms ","date":"2024-02-26","objectID":"/resource/:29:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rMath麻省理工学院公开课：单变量微积分 和 麻省理工学院公开课：单变量微积分习题课 麻省理工学院公开课：多变量微积分 和 麻省理工学院公开课：多变量微积分习题课 麻省理工公开课：线性代数 和 麻省理工学院公开课：MIT 线性代数习题课 麻省理工学院公开课：微分方程 葉丙成 頑想學概率：機率一 和 頑想學概率：機率二 Intro to Descriptive Statistics Intro to Inferential Statistics 马昱春 组合数学 Seeing Theory: A visual introduction to probability and statistics. ","date":"2024-02-26","objectID":"/resource/:30:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rKaggleThe Beginner’s Guide to Kaggle ","date":"2024-02-26","objectID":"/resource/:31:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rGenerative Adversarial NetworksAdversarialNetsPapers: The classical paper list with code about generative adversial nets. Keras-GAN: Keras implementations of Generative Adversarial Networks. ","date":"2024-02-26","objectID":"/resource/:32:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rAction RecognitionAwesome Action Recognition: A curated list of action recognition and related area resources. ","date":"2024-02-26","objectID":"/resource/:33:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rTensorflowTensorflow-Cookbook: Simple Tensorflow Cookbook for easy-to-use ","date":"2024-02-26","objectID":"/resource/:34:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rMachine LearningMachine Learning Andrew Ng Notes CS229: Machine Learning ML2017FALL Machine Learing with Python CSE 599W: Systems for ML Python Data Science Handbook 40 Must-Read AI / Machine Learning Blogs MLAlgorithms: Minimal and clean examples of machine learning algorithms implementations. ","date":"2024-02-26","objectID":"/resource/:35:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rRecommendation SystemComprehensive Guide to build a Recommendation Engine from scratch (in Python) ","date":"2024-02-26","objectID":"/resource/:36:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rMatplotlibMatplotlib tutorial ","date":"2024-02-26","objectID":"/resource/:37:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rReinforcement LearningDeep Reinforcement Learning Deep RL Bootcamp Deep Reinforcement Learning Course: A Free course in Deep Reinforcement Learning from beginner to expert. ","date":"2024-02-26","objectID":"/resource/:38:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rDeep LearningDive into Deep Learning: An interactive deep learning book with code, math, and discussions. Provides both NumPy/MXNet and PyTorch implementations Practical Deep Learning for Coders 深度学习入门：基于 Python 的理论与实现 Neural Networks and Deep Learning Keras and Convolutional Neural Networks (CNNs) DeepLearning-500-questions: 深度学习 500 问，以问答形式对常用的概率知识、线性代数、机器学习、深度学习、计算机视觉等热点问题进行阐述，以帮助自己及有需要的读者。 MIT 6.S191 Introduction to Deep Learning: MIT’s official introductory course on deep learning methods with applications in robotics, and more! Deep-Learning-Papers-Reading-Roadmap: About Deep Learning papers reading roadmap for anyone who are eager to learn this amazing tech! ","date":"2024-02-26","objectID":"/resource/:39:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rCVCS231n: Convolutional Neural Networks for Visual Recognition ","date":"2024-02-26","objectID":"/resource/:40:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rNLPCS224d: Deep Learning for Natural Language Processing CS224n: Natural Language Processing with Deep Learning nlp_course: YSDA course in Natural Language Processing ","date":"2024-02-26","objectID":"/resource/:41:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rAnomaly Detectionanomaly-detection-resources: Anomaly detection related books, papers, videos, and toolboxes ","date":"2024-02-26","objectID":"/resource/:42:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rSelf-Driving CarsMIT 6.S094: Deep Learning for Self-Driving Cars ","date":"2024-02-26","objectID":"/resource/:43:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\r哲学哈佛大学公开课：公正-该如何做是好？ 耶鲁大学公开课：哲学-死亡 ","date":"2024-02-26","objectID":"/resource/:44:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\r心理哈佛大学公开课：幸福课 ","date":"2024-02-26","objectID":"/resource/:45:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\r文学紅樓夢 歐麗娟: 本課程以《紅樓夢》為範圍，區分為文化與人物論兩大範疇。在文化方面，由於《紅樓夢》吸納傳統中國文學與文化的涵蓋面甚廣，將涉及「神話運用與詮釋」、「讖語式的表達」、「悟道模式」、「遊仙模式」、「喜劇精神」… ","date":"2024-02-26","objectID":"/resource/:46:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rYoutubeGate Lectures by Ravindrababu Ravula Derek Banas: I make tutorials based on your requests. I will cover any topic you can imagine. I upload new programming videos on Saturday and Wednesday morning. I Live Stream at 8PM EST on Monday and at 7PM EST on Tuesday, Thursday and Friday. sentdex: Python Programming tutorials, going further than just the basics. Learn about machine learning, finance, data analysis, robotics, web development, game development and more. The Cherno freeCodeCamp.org: We’re an open source community of busy people who learn to code and build projects for nonprofits. StatQuest with Josh Starmer: Statistics, Machine Learning and Data Science can sometimes seem like very scary topics, but since each technique is really just a combination of small and simple steps, they are actually quite simple. My goal with StatQuest is to break down the major methodologies into easy to understand pieces. That said, I don’t dumb down the material. Instead, I build up your understanding so that you are smarter. Numberphile: Videos about numbers - it’s that simple. TED: The TED Talks channel features the best talks and performances from the TED Conference, where the world’s leading thinkers and doers give the talk of their lives in 18 minutes (or less). Look for talks on Technology, Entertainment and Design – plus science, business, global issues, the arts and more. You’re welcome to link to or embed these videos, forward them to others and share these ideas with people you know. 3Blue1Brown: 3blue1brown, by Grant Sanderson, is some combination of math and entertainment, depending on your disposition. The goal is for explanations to be driven by animations and for difficult problems to be made simple with changes in perspective. CrashCourse: Tons of awesome courses in one awesome channel! Nicole Sweeney teaches you sociology, Carrie Anne Philbin teaches you computer science, Craig Benzine teaches film history, and Mike Rugnetta is teaching mythology! Check out the playlists for past courses in physics, philosophy, games, economics, U.S. government and politics, astronomy, anatomy \u0026 physiology, world history, biology, literature, ecology, chemistry, psychology, and U.S. history. ","date":"2024-02-26","objectID":"/resource/:47:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rListcomputer-science: 🎓 Path to a free self-taught education in Computer Science! awesome-computer-vision: A curated list of awesome computer vision resources. awesome-nlp: 📖 A curated list of resources dedicated to Natural Language Processing (NLP). awesome-deep-learning: A curated list of awesome Deep Learning tutorials, projects and communities. awesome-courses: 📚 List of awesome university courses for learning Computer Science! HelloGitHub: :octocat: Find pearls on open-source seashore 分享 GitHub 上有趣、入门级的开源项目 jstraining: 全栈工程师培训材料 free-books: 互联网上的免费书籍 Spring Boot 学习资料汇总 SpringBoot-Labs: 一个涵盖六个专栏：Spring Boot 2.X、Spring Cloud、Spring Cloud Alibaba、Dubbo、分布式消息队列、分布式事务的仓库。 ultimate-coding-resources: A collection of the best resources for programming, web development, computer science and more. Teach Yourself Computer Science: If you’re a self-taught engineer or bootcamp grad, you owe it to yourself to learn computer science. Thankfully, you can give yourself a world-class CS education without investing years and a small fortune in a degree program 💸. coding-interview-university: A complete computer science study plan to become a software engineer. ⭐⭐⭐⭐⭐ deep-learning-drizzle: Drench yourself in Deep Learning, Reinforcement Learning, Machine Learning, Computer Vision, and NLP by learning from these exciting lectures!! 程序员的自我修养 Project Based Learning: A list of programming tutorials in which learners build an application from scratch. These tutorials are divided into different primary programming languages. Some have intermixed technologies and languages. build-your-own-x: 🤓 Build your own (insert technology here) ⭐⭐⭐⭐⭐ awesome-competitive-programming: 💎 A curated list of awesome Competitive Programming, Algorithm and Data Structure resources ","date":"2024-02-26","objectID":"/resource/:48:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\r开源书籍pydata-notebook: 利用 Python 进行数据分析 第二版 (2017) 中文翻译笔记 the-craft-of-selfteaching: 自学是门手艺 webrtc-book-cn: 中文翻译 《 Real-Time Communication with WebRTC 》 ","date":"2024-02-26","objectID":"/resource/:49:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\r推荐项目json-tutorial: 从零开始的 JSON 库教程 http-parser: http request/response parser for c mongoose: Embedded Web Server xgboost: Scalable, Portable and Distributed Gradient Boosting (GBDT, GBRT or GBM) Library, for Python, R, Java, Scala, C++ and more. Runs on single machine, Hadoop, Spark, Dask, Flink and DataFlow darknet: Convolutional Neural Networks build-your-own-x: Master programming by recreating your favorite technologies from scratch. project-based-learning: Curated list of project-based tutorials ","date":"2024-02-26","objectID":"/resource/:50:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rInterviewinterview_internal_reference: 2019 年最新总结，阿里，腾讯，百度，美团，头条等技术面试题目，以及答案，专家出题人分析汇总。 如何写一份有效的技术简历？ CS-Notes: 📚 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计、Java、Python、C++ ","date":"2024-02-26","objectID":"/resource/:51:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\r工作Job-Recommend: 🔎 互联网内推信息（社招、校招、实习） ","date":"2024-02-26","objectID":"/resource/:52:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rToolsGlitch CodePen JS Bin JSFiddle IntelliJ-IDEA-Tutorial: IntelliJ IDEA 简体中文专题教程 Git Cheat Sheet EndNote_Tutorial_Hand_by_Hand: 手把手教你使用 EndNote X9/NoteExpress HistCite_Tutorial: HistCite 快速定位核心文献 Resources to learn Git Overleaf ","date":"2024-02-26","objectID":"/resource/:53:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\rWebsites深入浅出现代 Web 编程 Java Guides 阿里云开发者社区 Made With ML - Share what you’ve made with ML ZetCode 阮一峰的个人网站 GeeksforGeeks Hacker Noon Medium DEV hashnode MDN web docs Analytics Vidhya Stack Overflow - Where Developers Learn, Share, \u0026 Build Careers 纪录片天地 Coursera edureka! Software Engineering Daily MIT OpenCourseWare | Free Online Course Materials Github ","date":"2024-02-26","objectID":"/resource/:54:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\r其它Student-resources: 本文介绍的是利用学生身份可以享受到的相关学生优惠权益，但也希望各位享受权利的同时不要忘记自己的义务，不要售卖、转手自己的学生优惠资格，使得其他同学无法受益。 from_coder_to_expert: 从程序员到 CTO，从专业走向卓越，分享大牛企业内部 pdf 与 PPT。 Web-Series: 📚 现代 Web 开发，现代 Web 开发导论 | 基础篇 | 进阶篇 | 架构优化篇 | React 篇 | Vue 篇 document-style-guide: 中文技术文档的写作规范 learning GitHubDaily: 坚持分享 GitHub 上高质量、有趣实用的开源技术教程、开发者工具、编程网站、技术资讯。A list cool, interesting projects of GitHub. ","date":"2024-02-26","objectID":"/resource/:55:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\r🎓 公开课集散地汇集来自全球各大平台的优质公开课 🌍，涵盖编程 💻、数据科学 📊、人工智能 🤖、人文社科 📖 等多个领域。无论你是想提升技能 🔧，拓展视野 🌈，还是发现新兴趣 ✨，都能在这里找到合适的课程。这些课程多数免费开放，让你随时随地学习 📅。希望你能在这里收获知识的快乐 🎉，不断成长 🌱！ awesomeCsCourses: 国内外优秀的计算机软件专业在线课程推荐 awesome-cs-courses-zh: 计算机公开课推荐 CS 自学指南 ","date":"2024-02-25","objectID":"/opencourse/:1:0","tags":null,"title":"公开课","uri":"/opencourse/"},{"categories":null,"content":"\r🌈 学习清单","date":"2024-02-25","objectID":"/opencourse/:2:0","tags":null,"title":"公开课","uri":"/opencourse/"},{"categories":null,"content":"\r2024Stanford CS107 Programming Paradigms 编程范式 清华大学 经济学原理 耶鲁大学 聆听音乐 哈尔滨工业大学 操作系统 Machine Learning 2022 Spring Deep Learning for Human Language Processing 2020 Spring 6.824 Schedule: Spring 2022 计算机网络 2015 CMU 15-213 CSAPP 深入理解计算机系统 ","date":"2024-02-25","objectID":"/opencourse/:2:1","tags":null,"title":"公开课","uri":"/opencourse/"},{"categories":null,"content":"\r2025GAMES101 现代计算机图形学入门 闫令琪 MIT 6.824: Distributed System 清华大学 数据挖掘：理论与算法 国立台湾大学 頑想學概率 国立阳明交通大学 统计学（一）基础统计 国立阳明交通大学 统计学（二）进阶统计 哈佛大学 积极心理学 北京师范大学 普通心理学 耶鲁大学 哲学-死亡 中国人民公安大学 犯罪心理解析 耶鲁大学 博弈论 南政法大学 法律基础 ","date":"2024-02-25","objectID":"/opencourse/:2:2","tags":null,"title":"公开课","uri":"/opencourse/"},{"categories":null,"content":" 引用\r书籍是人类进步的阶梯。—— 高尔基\r","date":"2024-02-25","objectID":"/book/:0:0","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r🎉 书籍集散地无论是技术领域的深度探索，还是生活智慧的启迪，每一本书都是一扇通往新世界的窗。希望这些精选书单能激发你对知识的渴望，帮助你在个人成长和职业发展中不断迈上新台阶。 我的编程之路 程序员最应该读的图书（原版） 程序员最应该读的图书（中译版） 交互设计，并不仅仅是设计 ⋯⋯ 『只读经典』思维改变生活（原“心理学改变生活”） Hack 的技术与艺术 机器学习与人工智能 耶鲁大学部分公开课教科书与参考书目录 心智黑客 豆瓣 9 分以上计算机图书 computer-book-list: 一个综合了豆瓣，goodreads 综合评分的计算机书籍书单 有哪些值得推荐的豆友的豆列？ ","date":"2024-02-25","objectID":"/book/:1:0","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r🌟 阅读清单在这里，将与大家分享那些改变我思维、提升我能力的书籍。 ","date":"2024-02-25","objectID":"/book/:2:0","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r2024\r计算机JavaScript 高级程序设计 第 4 版 Unix\u0026Linux 大学教程 学习 JavaScript 数据结构与算法 第 3 版 Hands-on Machine Learning with Scikit-Learn, Keras \u0026 TensorFlow 2nd Edition 编写可读代码的艺术 JavaScript 面向对象精要 深入理解计算机系统 第 3 版 操作系统导论 C++并发编程实战（第 2 版） 深入浅出面向对象分析与设计（中文版） 文学红楼梦 金瓶梅 传记王安石传 毛泽东传 经济经济学原理(第 8 版) 经济学的思维方式 饮食一日一果 写作文心 哲学哲学家们都干了些什么 苏菲的世界 理想国 政治政治学通识 电影认识电影 历史明朝那些事儿 万历十五年 理财小狗钱钱 ","date":"2024-02-25","objectID":"/book/:2:1","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r2025\r计算机整洁代码的艺术 编程珠玑 第 2 版 Web 性能实践日志 Web 界面设计 TCP/IP 详解 卷 1：协议（原书第 2 版） Wireshark 网络分析就这么简单 Wireshark 网络分析的艺术 深入浅出 Node.js Head First 设计模式（中文版） 理财手把手教你读财报（新准则升级版） 张新民教你读财报 数学统计学（第 3 版） 统计学漫话 机会的数学 概率论与数理统计 ","date":"2024-02-25","objectID":"/book/:2:2","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r🚀 论文集散地要成长为一个高手，论文是你一定要读的。下面是一些非常不错的计算机方面的论文集散地。 2 Minute Papers ，这是一个 YouTube 的频道，其会给出一些非常不错的和计算机相关的论文介绍，让你了解目前最有意思的一些科学突破，每次两分钟左右。 Best Paper Awards in Computer Science ，从 1996 年以来，获奖的计算机科学方面的论文收集。 Google Scholar ，Google 学术搜索（英语：Google Scholar）是一个可以免费搜索学术文章的网络搜索引擎，由计算机专家阿努拉格·阿查里雅（Anurag Acharya）开发。2004 年 11 月，Google 第一次发布了 Google 学术搜索的试用版。该项索引包括了世界上绝大部分出版的学术期刊。 Facebook ，Facebook 公司的论文。 Research at Google ，Google 发布一些论文。 Microsoft Research ，微软发布的论文。 MIT’s Artificial Intelligence Lab Publications ，MIT 和人工智能相关的论文。 MIT’s Distributed System’s Reading Group ，MIT 和分布式系统相关的论文。 arXiv Paper Repository ，arXiv 是一个收集物理学、数学、计算机科学与生物学的论文预印本的网站，始于 1991 年 8 月 14 日。截至 2008 年 10 月，arXiv.org 已收集超过 50 万篇预印本。至 2014 年底，藏量达到 1 百万篇。 在 2014 年时，约以每月 8000 篇的速度增加。arXiv 的存在是造就科学出版业中所谓开放获取运动的因素之一。现今的一些数学家及科学家习惯先将其论文上传至 arXiv.org，再提交予专业的学术期刊。这个趋势对传统学术期刊的经营模式造成了可观的冲击。 SciRate ，arXiv 上的论文太多，所以，SciRate 索引了 arXiv 上的一些好评的论文，并供大家评论和打分。（开源代码。） cat-v.org ，这个网站，不只有论文，还有技术手册或是一些有意思的文章，包括一些历史资料什么的。 Usenix: Best Papers ，Usenix 上推荐的最佳论文。 The Morning Paper ，该博客会每天推送一篇论文，特别棒。 Lobste.rs tagged as PDF ，Lobsters 是一个聚焦于技术的社区，主要是链接聚合和对话题进行讨论。其中的 PDF 分类可以认为也是一个论文的集散地。 Papers We Love ，GitHub 上的一个近 3 万颗星的计算机科学方面的论文社区。 注意\r以上内容摘抄自左耳朵耗子《左耳听风》专栏“技术资源集散地”一文\r","date":"2024-02-25","objectID":"/paper/:1:0","tags":null,"title":"论文","uri":"/paper/"},{"categories":null,"content":"\r✨ 阅读清单","date":"2024-02-25","objectID":"/paper/:2:0","tags":null,"title":"论文","uri":"/paper/"},{"categories":null,"content":"\r2024 # 标题 年份 论文 代码 状态 1 You Only Look Once: Unified, Real-Time Object Detection 2015 Link Link ❎ 2 YOLOv4: Optimal Speed and Accuracy of Object Detection 2020 Link Link ❎ 3 A Neural Algorithm of Artistic Style 2015 Link Link ❎ ","date":"2024-02-25","objectID":"/paper/:2:1","tags":null,"title":"论文","uri":"/paper/"},{"categories":null,"content":" 大家好！我是东东东尼君，一个热爱学习和分享的技术探索者。在编程的世界里，我专注于 JavaScript、Node.js、C/C++ 和 Python，并且不断扩展自己的技能边界，从前端到后端，从数据分析到机器学习，力求通过技术创造更大的价值。 ","date":"2024-02-25","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"\r📚 目前正在学习为了持续提升自己的技术能力，我目前正在学习： C++ 并发编程：深入理解多线程编程模型及并发控制技术，提高系统性能与效率。 操作系统原理：研究操作系统的核心概念，如进程管理、内存管理、文件系统等，以更好地理解底层系统架构。 ","date":"2024-02-25","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"\r✍️ 博客与分享内容我热衷于分享我的开发旅程，在博客和各大技术社区中输出原创内容，包括但不限于： 技术文章：深入探讨前后端开发、系统架构、数据库优化、机器学习等主题。 开源项目：分享我的项目经验和代码库，包括实际案例中的技术挑战和解决方案。 学习笔记：记录学习新技术的过程，如 C++ 并发编程 和 操作系统原理。 行业观察：关于前沿技术、开发者工具和行业趋势的分析与个人见解 读书笔记：总结技术书籍、经典书籍的阅读收获和思考。 ","date":"2024-02-25","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"\r📢 社交媒体 \u0026 开源社区我坚信技术的力量源于分享和协作，期待与更多的技术爱好者交流碰撞灵感！欢迎关注我的社交媒体账号，一起探索无限可能： GitHub: AndyFree96 Twitter: @IRONAnthony96 知乎: IRONAnthony Facebook: anthonyfree96 不定期更新开源项目，分享前沿技术动态与个人思考，技术答疑与知识分享。 ","date":"2024-02-25","objectID":"/about/:3:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"\r🚀 座右铭“编程是一场永无止境的学习旅程，每一行代码都是对未来的探索。” 非常感谢你的关注，期待与大家一起探索和成长！欢迎随时联系我！😊 ","date":"2024-02-25","objectID":"/about/:4:0","tags":null,"title":"关于","uri":"/about/"},{"categories":["细读经典"],"content":" 2024/1/17 更新: 增加进程间通信 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:0:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r理解网络编程和套接字","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r理解网络编程和套接字网络编程中接受连接请求的套接字创建过程如下: 调用socket函数创建套接字 调用bind函数分配 IP 地址和端口号 调用listen函数转为可接收请求和状态 调用accpet函数受理连接请求 客户端程序只有“调用 socket 函数创建套接字”和“调用 connect 函数向服务器发送连接请求”两个步骤。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:1","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r基于 Linux 的文件操作对 Linux 而言，socket 操作与文件操作没有区别，socket 被认为是文件的一种，因此在网络数据传输过程中自然可以使用文件 I/O 的相关函数。Windows 和 Linux 不同，区分二者。 文件描述符只不过是为了方便称呼操作系统创建的文件或套接字而赋予的数而已。文件描述符有时也称为句柄，但“句柄”主要是 Windows 中的术语。 在项目中，为了给基本数据类型赋予别名，一般会添加大量的typedef声明。为了与程序员定义的新数据类型加以区分，操作系统定义的数据类型会添加后缀_t，例如size_t、ssize_t等。 文件描述符从 3 开始由小到大顺序编号，因为 0、1、2 分配给标准 I/O 的描述符。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:2","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r基于 Windows 平台的实现Windows 套接字（简称 Winsock）大部分是参考 BSD 系列的 UNIX 套接字设计的。 为了在 Windows 基础上开发网络程序，需要做如下准备。 导入头文件winsock2.h 链接ws2_32.lib库 Winsock 编程时必须首先调用WSAStartup函数，设置程序中用到的 Winsock 版本，并初始化相应版本的库。 注销该库使用如下函数: ##include \u003ciostream\u003e ##include \u003cWinSock2.h\u003e int main() { WSADATA wsaData; if (WSAStartup(MAKEWORD(2, 2), \u0026wsaData) != 0) { std::cout \u003c\u003c \"WSAStartup ERROR!\" \u003c\u003c std::endl; } WSACleanup(); return 0; } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:3","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r套接字类型与协议设置协议是计算机对话使用的通信规则。 ##include \u003csys/socket.h\u003e int socket(int domain, int type, int protocol); // 成功返回文件描述符，失败时返回-1 domain套接字使用的协议族信息 type套接字数据传输类型信息 protocol计算机间通信中使用的协议信息 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r协议族套接字通信中的协议有一些分类，通过socket函数的第一个参数传递套接字中使用的协议分类信息。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:1","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r套接字类型套接字类型指的是套接字的数据传输方式，通过socket函数的第二个参数传递，只有这样才能决定创建的套接字的数据传输方式。为什么通过第一个参数传递了协议族信息，还要决定数据传输方式？这是因为决定了协议族并不能同时决定数据传输方式，换而言之，socket函数第一个参数PF_INET协议族中也存在多种数据传输方式。 面向连接的套接字（SOCK_STREAM）可靠的、按序传递的、基于字节的面向连接的数据传输方式的套接字。（传送带传输，收和发套接字都有缓存，多次write可能只需要一次read，即二者的次数可以不等，传输的数据不存在数据边界） 面向消息的套接字（SOCK_DGRAM）不可靠的、不按序传递的、以数据的高速传递为目的的套接字（摩托车传输，发一次得收一次，传输的数据存在数据边界）。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:2","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r协议的最终选择socket函数的前两个参数传递了协议族的信息和套接字数据传输方式，这些信息还不足以决定采用的协议吗？为什么还需要传递第 3 个参数？ 前两个参数即可创建所需套接字。所以大部分情况下可以向第三个参数传递 0，除非遇到以下情况: 同一个协议族中存在多个传输方式相同的协议 数据传输方式相同，但协议不同。此时需要通过第三个参数具体指定协议信息。 比如，创建“IPv4 协议族面向连接的套接字”。 参数PF_INET指 IPv4 网络协议族，SOCK_STREAM是面向连接的数据传输。满足这两个条的协议只有IPPROTO_TCP，这种套接字称为 TCP 套接字。 int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); 再比如，创建“IPv4 协议族面向消息的套接字”。 满足上述条件的协议只有IPPROTO_UDP，这种套接字称为 UDP 套接字。 int udp_socket = socket(PF_INET, SOCKET_STREAM, IPPROTO_UDP); ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:3","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r地址族与数据序列","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r分配给套接字的 IP 地址和端口号IP 是 Internet Protocol（网络协议）的简写，是为收发网络数据而分配给计算机的值。端口号并非赋予计算机的值，而是为区分程序中创建的套接字而分配给套接字的序号。 网络地址（Internet Address）为让计算机连接到网络并收发数据，需向其分配 IP 地址。IP 地址分为两类。 IPv4（Internet Protocol version 4） 4 字节地址族 IPv6（Internet Protocol version 6） 16 字节地址族 网络地址（网络 ID）是为区分网络而设置的一部分 IP 地址。传输数据时，并非一开始就浏览所有 4 字节 IP 地址，进而找到目标主机；而是仅浏览 4 字节 IP 地址的网络地址，向把数据传到网络。网络（构成网络的路由器（Router）或交换机（Switch））接到数据后，浏览传输数据的主机地址（主机 ID）并将数据传给目标计算机。 构建网络需要一种物理设备完成外网与本网主机之间的数据交换，这种设备便是路由器或交换机。它们也是一种计算机，只不过为了特殊目的而设计运行的，因而有了别名。我们可在自己的计算机中安装适当的软件，也可以将其作为交换机。交换机的功能比路由器简单一些，实际差别不大。 网络地址分类与主机地址边界只需通过 IP 地址的第一个字节即可判断网络地址占用的字节数: 用于区分套接字的端口号计算机中一般配有 NIC（Network Interface Card，网络接口卡）数据传输设备。通过 NIC 向计算机内部传输数据时会用到 IP。操作系统负责把传递到内部的数据适当分配给套接字，这时就要利用端口号。也就是说，通过 NIC 收到的数据内有端口号，操作系统参考此端口号把数据传输给相应端口的套接字。 端口号是在同意操作系统内为区分不同套接字而设置的，因此无法将一个端口号分配给不同套接字。端口号由 16 位构成，可分配的端口号范围是 0~65535。但 0~1023 是知名端口号（Wll-known PORT），一般分配给特定应用程序。TCP 套接字和 UDP 套接字不会公用端口号，所以允许重复。 数据传输目标地址同时包含 IP 地址和端口号，只有这样，数据才会被传输到最终的目的应用程序（应用程序套接字）。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:1","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r地址信息的表示\r表示 IPv4 地址的结构体 struct sockaddr_in { sa_family_t sin_family; // 地址族(Address Family) uint16_t sin_port; // 16位TCP/UDP端口号 struct in_addr sin_addr; // 32位IP地址 char sin_zero[8]; // 不使用 } in_addr定义如下: struct in_addr { In_addr_t s_addr; // 32位IPv4地址 }; 结构体sockaddr_in的成员分析","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:2","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r网络字节序与地址转换\r字节序（Order）与网络字节序CPU 向内存保存数据的方式有两种: 大端序（Big Endian）: 高位字节放到低位地址 小端序（Little Endian）: 高位字节放到高位地址 主流的 Intel 系列 CPU 以小端序方式保存数据。 在通过网络传输数据时约定统一的方式，称为网络字节序（Network Byte Order），非常简单——统一为大端序。即，先把数据数组转化为大端序格式再进行网络传输。 字节序转换（Endian Conversions） 除了向sockaddr_in结构体变量填充数据外，其他情况无需考虑字节序问题。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:3","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r网络地址的初始化与分配\r将字符串信息转换为网络字节序的整数型使用inet_addr函数可以将字符串形式的 IP 地址转换为 32 为整型数据。 ##include\u003carpa/inet.h\u003e in_addr_t inet_addr(const char* string); // 成功返回32位大端序整型值，失败时返回INADDR_NONE。 char* inet_ntoa(struct in_addr adr); // 成功返回转换的字符串地址值，失败时返回-1 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:4","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r基于 TCP 的服务器端/客户端(1)","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r实现基于 TCP 的服务器端/客户端\rTCP 服务器端的默认函数调用顺序 进入等待连接请求状态我们已调用bind函数给套接字分配了地址，接下来就要通过listen函数进入等待连接请求状态。只有调用了listen函数，客户端才能进入可发出连接请求的状态。这时客户端才能调用connect函数（若提前调用将发生错误）。 ##include \u003csys/socket.h\u003e int listen(int sock, int backlog); // 成功返回0，失败返回-1 // sock 希望进入等待连接状态的套接字文件描述符，传递的描述符套接字参数成为服务器端套接字（监听套接字） // backlog 连接请求等待队列的长度，若为5，则队列长度为5，表示最多使5个连接请求进入队列 受理客户端连接请求服务器端套接字是做门卫的。如果与客户端的数据交换使用门卫，那谁来守门呢？因此需要另外一个套接字，但没必要亲自创建。accpet函数将自动创建套接字，并连接到发起请求的客户端。 ##include \u003csys/socket.h\u003e int accpet(int sock, struct sockaddr* addr, socklen_t* addrlen); // 成功时返回创建的套接字文件描述符，失败返回-1 // sock 服务器套接字的文件描述符 // addr 保存发起连接请求的客户端地址信息的变量地址值，调用函数后向传递来的地址变量参数填充客户端地址信息 // addrlen 第二个参数addr结构体的长度，但是存有长度的变量地址。函数调用完成后，该变量即被填入客户端地址长度 TCP 客户端的默认函数调用顺序 服务器调用listen函数后创建连接请求等待队列，之后客户端即可请求连接。通过如下函数即可发起请求连接: ##include \u003csys/socket.h\u003e int connect(int sock, struct sockaddr* servaddr, socklen_t addrlen); // 成功时返回0，失败时返回-1 // sock 客户端套接字文件描述符 // servaddr 保存目标服务器端地址信息的变量地址值 // addrlen 以字节为单位传递已传递给第二个结构体参数servaddr的地址变量长度 客户端调用connect函数后，发生以下情况之一才会返回（完成函数调用）。 服务器端接收连接请求 发生断网等异常情况而中断连接请求 接收连接并不意味着服务器端调用accpet函数，其实是服务器端把连接请求信息记录到等待队列。因此connect函数返回后并不立即进行数据交换。 客户端套接字何时、何地、如何分配地址呢？调用connect函数时。操作系统，准确地说是在内核中。IP 用主机的 IP，端口随机。客户端的 IP 地址和端口在调用connect函数时自动分配，无需调用bind函数进行分配。 基于 TCP 和服务器端/客户端函数调用关系 服务器端创建套接字后连续调用bind和listen函数进入等待状态，客户端通过调用connect函数发起连接请求。客户端只能等到服务器端调用listen函数后才能调connect函数。客户端调用connect函数前，服务器端有可能率先调用accpet函数。此时服务器端在调用accpet函数时进入阻塞状态，直到客户端调用connect函数为止。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:1","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r实现迭代服务器端/客户端\r实现迭代服务器端插入循环语句反复调用accept函数。 从上图可看出，调用accept函数后紧接着调用 I/O 相关的read和write函数，之后调用close函数。这并非针对服务器端套接字，而是针对accept函数调用时创建的套接字。 调用close函数就意味着结束了针对某一客户端的服务。此时如果还想服务于其他客户端，就要重新调用accpet函数。同一时刻只能服务于一个客户端，学完进程和线程后，就可以编写同时服务多个客户端的服务器了。 迭代回声服务器/客户端 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:2","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r基于 Windows 的实现\r基于 Windows 的回声服务器端 ##include \u003ciostream\u003e ##include \u003ccstdlib\u003e ##include \u003ccstring\u003e ##include \u003cwinsock2.h\u003e ##include \u003ccstdio\u003e ##define BUF_SIZE 1024 void ErrorHandling(const char* message); int main(int argc, char* argv[]) { WSADATA wsaData; SOCKET hServerSocket, hClientSocket; char message[BUF_SIZE]; int strlen, i; int clientAddrSize; SOCKADDR_IN serverAddr, clientAddr; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } if (WSAStartup(MAKEWORD(2, 2), \u0026wsaData) != 0) ErrorHandling(\"WSAStartup() error!\"); hServerSocket = socket(PF_INET, SOCK_STREAM, 0); if (hServerSocket == INVALID_SOCKET) ErrorHandling(\"socket() error!\"); memset(\u0026serverAddr, 0, sizeof(serverAddr)); serverAddr.sin_family = AF_INET; serverAddr.sin_addr.s_addr = htonl(INADDR_ANY); serverAddr.sin_port = htons(atoi(argv[1])); if (bind(hServerSocket, (sockaddr*)\u0026serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) { ErrorHandling(\"bind() error!\"); } if (listen(hServerSocket, 5) == SOCKET_ERROR) { ErrorHandling(\"listen() error!\"); } clientAddrSize = sizeof(clientAddr); for (i = 0; i \u003c 5; i++) { hClientSocket = accept(hServerSocket, (sockaddr*)\u0026clientAddr, \u0026clientAddrSize); if (hClientSocket == -1) ErrorHandling(\"accept() error!\"); else std::cout \u003c\u003c \"Connected client \" \u003c\u003c i + 1 \u003c\u003c \"\\n\"; while ((strlen = recv(hClientSocket, message, BUF_SIZE, 0)) != 0) { send(hClientSocket, message, strlen, 0); } closesocket(hClientSocket); } closesocket(hServerSocket); WSACleanup(); return 0; } void ErrorHandling(const char* message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } 基于 Windows 的回声客户端 ##include \u003ciostream\u003e ##include \u003ccstdlib\u003e ##include \u003ccstring\u003e ##include \u003cwinSock2.h\u003e ##include \u003ccstdio\u003e ##pragma warning(disable:4996) ##define BUF_SIZE 1024 void ErrorHandling(const char* message); int main(int argc, char* argv[]) { WSADATA wsaData; SOCKET hSocket; char message[BUF_SIZE]; int strLen; SOCKADDR_IN serverAddr; if (argc != 3) { printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e\\n\", argv[0]); exit(1); } if (WSAStartup(MAKEWORD(2, 2), \u0026wsaData) != 0) ErrorHandling(\"WSAStartup() error!\"); hSocket = socket(PF_INET, SOCK_STREAM, 0); if (hSocket == INVALID_SOCKET) ErrorHandling(\"socket() error\"); memset(\u0026serverAddr, 0, sizeof(serverAddr)); serverAddr.sin_family = AF_INET; serverAddr.sin_addr.s_addr = inet_addr(argv[1]); serverAddr.sin_port = htons(atoi(argv[2])); if (connect(hSocket, (sockaddr*)\u0026serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) { ErrorHandling(\"connect() error!\"); } while (1) { fputs(\"Input message (Q to quit): \", stdout); fgets(message, BUF_SIZE, stdin); if (!strcmp(message, \"q\\n\") || !strcmp(message, \"Q\\n\")) break; send(hSocket, message, strlen(message), 0); strLen = recv(hSocket, message, BUF_SIZE - 1, 0); message[strLen] = 0; printf(\"Message from server : %s\", message); } closesocket(hSocket); WSACleanup(); return 0; } void ErrorHandling(const char* message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:3","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r基于 TCP 的服务器端/客户端(2)","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r回声客户端的完美实现 ##include \u003cstdio.h\u003e ##include \u003cstdlib.h\u003e ##include \u003cstring.h\u003e ##include \u003cunistd.h\u003e ##include \u003carpa/inet.h\u003e ##include \u003csys/socket.h\u003e ##define BUF_SIZE 1024 void error_handling(char *message); int main(int argc, char *argv[]) { int sock; char message[BUF_SIZE]; int str_len, recv_len, recv_cnt; struct sockaddr_in serv_addr; if (argc != 3) { printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e \\n\", argv[0]); exit(1); } sock = socket(PF_INET, SOCK_STREAM, 0); if (sock == -1) { error_handling(\"socket() error\"); } memset(\u0026serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = inet_addr(argv[1]); serv_addr.sin_port = htons(atoi(argv[2])); if (connect(sock, (struct sockaddr *)\u0026serv_addr, sizeof(serv_addr)) == -1) { error_handling(\"connect() error\"); } else { puts(\"connected....\"); } while (1) { fputs(\"Input message (Q to quit): \", stdout); fgets(message, BUF_SIZE, stdin); if (!strcmp(message, \"q\\n\") || !strcmp(message, \"Q\\n\")) { break; } str_len = write(sock, message, strlen(message)); recv_len = 0; while (recv_len \u003c str_len) { recv_cnt = read(sock, \u0026message[recv_len], BUF_SIZE - 1); if (recv_cnt == -1) { error_handling(\"read() error\"); } recv_len += recv_cnt; } message[recv_len] = 0; printf(\"Message from server : %s\", message); } close(sock); return 0; } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:1","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\rTCP 原理\rTCP 套接字中的 I/O 缓冲TCP 套接字的数据收发无边界。服务器端即使调用 1 次write函数传输 40 字节的数据，客户端也有可能通过 4 次read函数调用每次读取 10 字节。write函数调用后并非立即传输数据，read函数调用后也并非马上接收数据。write函数调用瞬间，数据将移至输出缓冲；read函数调用瞬间，从输入缓冲读取数据。 如上图所示，调用write函数时，数据将移到输出缓冲，在适当的时候（不管是分别传送还是一次性传送）传向对方的输入缓冲。这时对方将调用read函数从输入缓冲读取数据。这些 I/O 缓冲特性可整理如下。 I/O 缓冲在每个 TCP 套接字中单独存在 I/O 缓冲在创建套接字时自动生成 即使关闭套接字也会继续传递输出缓冲中遗留的数据 关闭套接字将丢失输入缓冲中的数据 不会发生超过输入缓冲大小的数据传输，因为 TCP 会控制数据流。TCP 中有滑动窗口（Sliding Window）协议。数据收发也是如此，TCP 不会因为缓冲溢出而丢失数据。 TCP 内部工作原理 1：与对方套接字的连接TCP 套接字从创建到消失分为以下 3 步。 与对方套接字建立连接 与对方套接字进行数据交换 断开与对方套接字的连接 连接过程中实际交换的信息格式如下: 该过程又称 Tree-way handhshaking（三次握手）。 TCP 内部工作原理 2：与对方主机的数据交换 ACK 号 -\u003e SEQ 号 + 传递字节数 + 1 TCP 内部工作原理 3：断开与套接字的连接 数据包内的 FIN 表示断开连接。即双方各发送 1 次 FIN 消息后断开连接。该过程经历了 4 个阶段，因此又称四次握手（Four-way handshaking）。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:2","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r基于 Windows 实现服务器端op_server.c ##include \u003ccstdio\u003e ##include \u003ccstdlib\u003e ##include \u003ciostream\u003e ##include \u003cWinSock2.h\u003e ##include \u003ccstring\u003e ##define BUF_SIZE 1024 ##define OPZS 4 void ErrorHandling(const char* message); int calculate(int opnum, int opnds[], char op); int main(int argc, char* argv[]) { WSADATA wsData; SOCKET serverSocket, clientSocket; SOCKADDR_IN serverAddr, clientAddr; char opinfo[BUF_SIZE]; int clientAddrSize, i; int result, opndCount; int recvCount, recvLen; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } if (WSAStartup(MAKEWORD(2, 2), \u0026wsData) != 0) ErrorHandling(\"WSAStartup() error!\"); serverSocket = socket(PF_INET, SOCK_STREAM, 0); if (serverSocket == INVALID_SOCKET) ErrorHandling(\"socket() error!\"); memset(\u0026serverAddr, 0, sizeof(serverAddr)); serverAddr.sin_family = PF_INET; serverAddr.sin_port = htons(atoi(argv[1])); serverAddr.sin_addr.s_addr = htonl(INADDR_ANY); if (bind(serverSocket, (SOCKADDR*)\u0026serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) ErrorHandling(\"bind() error!\"); if (listen(serverSocket, 5) == SOCKET_ERROR) ErrorHandling(\"listen() error!\"); clientAddrSize = sizeof(clientAddr); for (i = 0; i \u003c 5; i++) { opndCount = 0; clientSocket = accept(serverSocket, (SOCKADDR*)\u0026clientAddr, \u0026clientAddrSize); recv(clientSocket, (char*)\u0026opndCount, 1, 0); recvLen = 0; while ((opndCount * OPZS + 1) \u003e recvLen) { recvCount = recv(clientSocket, opinfo, BUF_SIZE - 1, 0); recvLen += recvCount; } result = calculate(opndCount, (int*)opinfo, opinfo[recvLen - 1]); send(clientSocket, (char*)\u0026result, sizeof(result), 0); closesocket(clientSocket); } closesocket(serverSocket); WSACleanup(); return 0; } void ErrorHandling(const char* message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } int calculate(int opnum, int opnds[], char op) { int result = opnds[0], i; switch (op) { case '+': for (i = 1; i \u003c opnum; i++) result += opnds[i]; break; case '-': for (i = 1; i \u003c opnum; i++) result -= opnds[i]; break; case '*': for (i = 1; i \u003c opnum; i++) result *= opnds[i]; break; } return result; } 客户端op_client.c ##include \u003ciostream\u003e ##include \u003cWinSock2.h\u003e ##include \u003ccstdlib\u003e ##include \u003ccstdio\u003e ##pragma warning(disable:4996) ##define BUF_SIZE 1024 ##define RLT_SIZE 4 ##define OPSZ 4 void ErrorHandling(const char* message); int main(int argc, char* argv[]) { WSADATA wsData; SOCKET hSocket; char opmsg[BUF_SIZE]; int result, opndCount, i; SOCKADDR_IN serverAddr; if (argc != 3) { printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e\\n\", argv[0]); exit(1); } if (WSAStartup(MAKEWORD(2, 2), \u0026wsData) != 0) { ErrorHandling(\"WSAStartup() error!\"); } hSocket = socket(PF_INET, SOCK_STREAM, 0); if (hSocket == INVALID_SOCKET) ErrorHandling(\"socket() error!\"); memset(\u0026serverAddr, 0, sizeof(serverAddr)); serverAddr.sin_addr.s_addr = inet_addr(argv[1]); serverAddr.sin_family = AF_INET; serverAddr.sin_port = htons(atoi(argv[2])); if (connect(hSocket, (SOCKADDR*)\u0026serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) ErrorHandling(\"socket() error!\"); else puts(\"Connected ......\"); fputs(\"Operand count : \", stdout); scanf(\"%d\", \u0026opndCount); opmsg[0] = (char)opndCount; for (i = 0; i \u003c opndCount; i++) { printf(\"Operand %d : \", i + 1); scanf(\"%d\", (int*)\u0026opmsg[i * OPSZ + 1]); } fgetc(stdin); fputs(\"Operator : \", stdout); scanf(\"%c\", \u0026opmsg[opndCount * OPSZ + 1]); send(hSocket, opmsg, opndCount * OPSZ + 2, 0); recv(hSocket, (char*)\u0026result, RLT_SIZE, 0); printf(\"Operation result : %d \\n\", result); closesocket(hSocket); WSACleanup(); return 0; } void ErrorHandling(const char* message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:3","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r推荐File Transfer using TCP Socket in C: https://idiotdeveloper.com/file-transfer-using-tcp-socket-in-c/ ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:4","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r基于 UDP 的服务器端/客户端","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:6:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r理解 UDP\rUDP 内部工作原理 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:6:1","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r实现基于 UDP 的服务器端/客户端\rUDP 中的服务器端和客户端没有连接UDP 服务器端和客户端不像 TCP 那样在连接状态下交换数据，因此与 TCP 不同，无需经过连接过程。即，不必调用 TCP 连接过程中调用的listen函数和accept函数。UDP 中只有创建套接字的过程和数据交换过程。 UDP 服务器端和客户端均只需 1 个套接字TCP 中，套接字之间应该是一对一的关系。若要向 10 个客户端提供服务，则除了守门的服务器套接字外，还需要 10 个服务器端套接字。但在 UDP 中，不管是服务器端还是客户端都只需要 1 个套接字。 只需 1 个 UDP 套接字就可以向任意主机传输数据（类似收发信件的邮筒）。只需 1 个 UDP 套接字就能和多台主机通信。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:6:2","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r基于 Windows 实现 ##include \u003cwinsock2.h\u003e int sendto(SOCKET s, const char* buf, int len, int flags, const struct sockaddr* to, int tolen); // 成功返回传输的字节数，失败返回SOCKET_ERROR int recvfrom(SOCKET s, char* buf, int len, int flag, struct sockaddr* from, int* fromlen); // 成功返回接收的字节数，失败返回SOCKET_ERROR ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:6:3","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r优雅地断开套接字连接","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:7:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r基于 TCP 的半关闭\r套接字和流（Stream）两台主机通过套接字建立连接后进入可交换数据的状态，又称“流形成的状态”。也就是把建立套接字后可交换数据的状态看作一种流。此处的流可以比作水流。水朝着一个方向流动，同样，在套接字的流中，数据也只能向一个方向流动。为了进行双向通信，就需要如下图所示的 2 个流。 一旦两台主机建立了套接字连接，每个主机机会拥有单独的输入流和输出流。其中一个主机的输入流与一台主机的输出流相连，而输出流则与另一主机的输入流相连。优雅地断开连接方式指的是只断开其中一个流，而非同时断开两个流。Linux 的close和 Windows 的closesocket函数将同时断开这两个流，因此不够优雅。 针对优雅断开的shutdown函数shutdown函数可以用来关闭其中 1 个流。 ##include \u003csys/socket.h\u003e int shutdown(int sock, int howto); // 成功返回0，失败返回-1 调用上述函数时，第二个参数决定断开连接的方式，其可能值如下: SHUT_RD: 断开输入流 SHUT_WR: 断开输出流 SHUT_RDWR: 同时断开 I/O 流 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:7:1","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r基于 Windows 的实现Windows 平台调用的shutdown函数传递的参数略有不同。 ##include \u003cwinsock2.h\u003e int shutdown(SOCKET sock, int howto); // 成功返回0，失败返回SOCKET_ERROR // sock 要断开的套接字句柄 // howto 断开方式的信息 调用上述函数时，第二个参数的可能值如下: SD_RECEIVE: 断开输入流 SD_SEND: 断开输出流 SD_BOTH: 同时断开 I/O 流 服务器端file_server_win.cpp: ##include \u003cWinSock2.h\u003e ##include \u003ccstdio\u003e ##include \u003ccstdlib\u003e ##pragma warning(disable:4996) ##define BUF_SIZE 30 void ErrorHandling(const char* message); int main(int argc, char* argv[]) { WSADATA wsaData; SOCKET serverSocket, clientSocket; FILE* fp; char buf[BUF_SIZE]; int readCount; SOCKADDR_IN serverAddr, clientAddr; int clientAddrSize; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } if (WSAStartup(MAKEWORD(2, 2), \u0026wsaData) != 0) ErrorHandling(\"WSAStartup() error!\"); fp = fopen(\"file_server_win.cpp\", \"rb\"); serverSocket = socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serverAddr, 0, sizeof(serverAddr)); serverAddr.sin_family = AF_INET; serverAddr.sin_addr.s_addr = htonl(INADDR_ANY); serverAddr.sin_port = htons(atoi(argv[1])); bind(serverSocket, (SOCKADDR*)\u0026serverAddr, sizeof(serverAddr)); listen(serverSocket, 5); clientAddrSize = sizeof(clientAddr); clientSocket = accept(serverSocket, (SOCKADDR*)\u0026clientAddr, \u0026clientAddrSize); while (true) { readCount = fread((void*)buf, 1, BUF_SIZE, fp); if (readCount \u003c BUF_SIZE) { send(clientSocket, (char*)\u0026buf, readCount, 0); break; } send(clientSocket, (char*)\u0026buf, BUF_SIZE, 0); } shutdown(clientSocket, SD_SEND); recv(clientSocket, (char*)buf, BUF_SIZE, 0); printf(\"Message from client : %s \\n\", buf); fclose(fp); closesocket(clientSocket); closesocket(serverSocket); WSACleanup(); return 0; } void ErrorHandling(const char* message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } 客户端file_client_win.cpp: ##include \u003ciostream\u003e ##include \u003cWinSock2.h\u003e ##include \u003ccstdlib\u003e ##include \u003ccstdio\u003e ##pragma warning(disable:4996) ##define BUF_SIZE 30 void ErrorHandling(const char* message); int main(int argc, char* argv[]) { WSADATA wsData; SOCKET hSocket; char buf[BUF_SIZE]; int readCount; SOCKADDR_IN serverAddr; FILE* fp; if (argc != 3) { printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e\\n\", argv[0]); exit(1); } if (WSAStartup(MAKEWORD(2, 2), \u0026wsData) != 0) { ErrorHandling(\"WSAStartup() error!\"); } fp = fopen(\"receive.dat\", \"wb\"); hSocket = socket(PF_INET, SOCK_STREAM, 0); if (hSocket == INVALID_SOCKET) ErrorHandling(\"socket() error!\"); memset(\u0026serverAddr, 0, sizeof(serverAddr)); serverAddr.sin_addr.s_addr = inet_addr(argv[1]); serverAddr.sin_family = AF_INET; serverAddr.sin_port = htons(atoi(argv[2])); if (connect(hSocket, (SOCKADDR*)\u0026serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) ErrorHandling(\"socket() error!\"); else puts(\"Connected ......\"); while ((readCount = recv(hSocket, buf, BUF_SIZE, 0)) != 0) { fwrite((void*)buf, 1, readCount, fp); } puts(\"Received file data\"); send(hSocket, \"Thank you\", 10, 0); fclose(fp); closesocket(hSocket); WSACleanup(); return 0; } void ErrorHandling(const char* message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:7:2","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r域名及网络地址","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:8:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r套接字的多种可选项","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:9:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r多进程服务器端","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r进程概念及应用\r并发服务器的的实现方法 多进程服务器: 通过创建多个进程提供服务 多路复用服务器: 通过绑定并统一管理 I/O 对象提供服务 多线程服务器: 通过生成与客户端等量的线程提供服务 第一种方法: 多进程服务器。不适合在 Windows 平台下（Windows 不支持），因此将重点放在 Linux 平台。 理解进程（Process）定义如下: 占用内存空间的正在运行的程序 进程 ID无论进程是如何创建的，所有进程都会从操作系统分配到 ID。此 ID 称为进程 ID，其值为大于 2 的整数。1 要分配给操作系统启动后（用于协助操作系统）首个进程，因此用户进程无法得到 ID 值 1。 通过 ps 命令可以查看当前运行的所有进程。 通过调用 fork 函数创建进程 ##include \u003cunistd.h\u003e pid_t fork(void); // 成功返回进程ID，失败返回-1 fork函数将创建调用的进程副本。即并非根据完全不同的程序创建进程，而是复制正在运行的、调用fork函数的进程。两个进程都将执行fork函数调用后的语句（准确说是在fork函数返回后）。但因为通过同一个进程、复制相同的内存空间，之后的程序流要根据fork函数的返回值加以区分。fork函数的特点如下: 父进程: fork函数返回子进程 ID 子进程: fork函数返回 0 这里的父进程（Parent Process）指的是原进程，即调用fork函数的主体，而子进程（Child Process）是通过父进程调用fork函数复制出的进程。 从上图可以看到，父进程调用fork函数的同时复制出子进程，并分别得到fork函数的返回值。在父进程和子进程中gval和lval互不影响。因此fork函数调用后分成了完全不同的进程，只是二者共享同一代码而已。 ##include \u003cstdio.h\u003e ##include \u003cunistd.h\u003e int gval = 10; int main(int argc, char* argv[]){ pid_t pid; int lval = 20; gval++, lval+=5; pid = fork(); if (pid == 0) gval += 2, lval += 2; else gval -= 2, lval -= 2; if (pid == 0) printf(\"Child Proc : [%d, %d] \\n\", gval, lval); else printf(\"Parent Proc : [%d, %d] \\n\", gval, lval); return 0; } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:1","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r进程和僵尸进程进程销毁和进程创建同等重要。如果未认真进程销毁，它们将变成僵尸进程。 僵尸（Zombie）进程进程完成工作后（执行完main函数中的程序后）应被销毁，但有时这些进程将变成僵尸进程，占用系统中的重要资源。这种状态下的进程称作“僵尸进程”，也是给系统带来负担的原因之一。 产生僵尸进程的原因调用fork函数产生子进程的终止方式: 传递参数并调用exit函数 main函数中执行return语句并返回值 向exit函数传递的参数值和main函数的return语句返回的值都会传递给操作系统。而操作系统不会销毁子进程，直到把这些值传递给产生该子进程的父进程。处在这种状态下的进程就是僵尸进，将子进程变成僵尸进程的正是操作系统。那么如何销毁僵尸进程呢？向父进程传递exit函数的参数值或return的返回值即可。如何向父进程传递这些值呢？操作系统不会主动传递给父进程，只有父进程主动发起请求（函数调用）时，操作系统才会传递该值。换言之，如果父进程未主动要求获得子进程的结束状态值，操作系统将一直保存，并让子进程长时间处于僵尸进程状态。 ##include \u003cstdio.h\u003e ##include \u003cunistd.h\u003e int main(int argc, char* argv[]){ pid_t pid = fork(); if (pid == 0) puts(\"Child Process\"); else { printf(\"Child Process ID : %d \\n\", pid); sleep(30); // Sleep 30 sec } if (pid == 0) puts(\"End Child Process\"); else puts(\"End Parent Process\"); return 0; } 销毁僵尸进程 1：利用 wait 函数为了销毁子进程，父进程应主动请求获取子进程的返回值。发起请求的方法有两种，其中之一就是调用如下函数。 ##include \u003csys/wait.h\u003e pid_t wait(int* statloc); // 成功返回终止的子进程ID，失败返回-1 调用此函数时如果已有子进程终止，那么子进程终止时传递的返回值（exit函数的参数值、main函数的return返回值）将保存到该函数的参数所指内存空间。但函数参数指向的单元中还包含其他信息，因此需要通过下列宏进行分离。 WIFEXITED子进程正常终止时返回真（True） WEXITSTATUS返回子进程的返回值 向wait函数传递变量status的地址时，调用wait函数后应编写如下代码: if (WIFEXITED(status)) // 是正常终止吗？ { puts(\"Normal termination!\"); printf(\"Child pass num: %d\", WEXITSTATUS(status)); // 返回值是多少？ } 根据上述内容编写示例，此示例不会再让子进程变成僵尸进程。 ##include \u003cstdio.h\u003e ##include \u003cstdlib.h\u003e ##include \u003cunistd.h\u003e ##include \u003csys/wait.h\u003e int main(int argc, char* argv[]){ int status; pid_t pid = fork(); if (pid == 0) { return 3; } else { printf(\"Child PID %d \\n\", pid); pid = fork(); if (pid == 0) { exit(7); } else { printf(\"Child PID %d \\n\", pid); wait(\u0026status); if (WIFEXITED(status)){ printf(\"Child send one : %d\\n\", WEXITSTATUS(status)); } wait(\u0026status); if (WIFEXITED(status)){ printf(\"Child send two : %d\\n\", WEXITSTATUS(status)); } sleep(30); } } return 0; } 调用wait函数时，如果没有已终止的子进程，那么程序将阻塞（Blocking）直到有子进程终止，因此需谨慎调用该函数。 销毁僵尸进程 2：使用 waitpid 函数wait函数会引起程序阻塞，可以考虑调用waitpid函数。这是防止僵尸进程的第二种方法，也是防止阻塞的方法。 ##include \u003csys/wait.h\u003e pid_t waitpid(pid_t pid, int* statloc, int options); // 成功返回终止的子进程ID（或0），失败返回-1 // pid 等待终止的目标子进程ID，若传递-1，则与wait函数相同，可以等待任意子进程终止 // statloc 与wait函数的statloc参数具有相同含义 // options 传递头文件sys/wait.h中声明的常量WNOHANG，即使没有终止的子进程也不会进入阻塞状态，而是返回0并退出函数 示例如下: ##include \u003cstdio.h\u003e ##include \u003cstdlib.h\u003e ##include \u003cunistd.h\u003e ##include \u003csys/wait.h\u003e int main(int argc, char *argv[]) { int status; pid_t pid = fork(); if (pid == 0) { sleep(15); return 24; } else { while (!waitpid(-1, \u0026status, WNOHANG)) { sleep(3); puts(\"Sleep 3sec.\"); } if (WIFEXITED(status)) { printf(\"Child send %d \\n\", WEXITSTATUS(status)); } } return 0; } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:2","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r信号处理我们已经直到子进程的创建及销毁方法，但还有一个问题没解决。 子进程究竟何时终止？调用waitpid函数后要无休止地等待吗？ 父进程往往与子进程一样繁忙，因此不能只调用waitpid函数以等待子进程终止。 向操作系统求助子进程终止的识别主体是操作系统。如果操作系统能把子进程终止的消息告诉正忙于工作的父进程，将有助于构建高效的程序。 此时父进程暂时放下工作，处理子进程终止相关事宜。为了实现该想法，引入信号处理（Signal Handling）机制。此处的“信号”是在特定时间发生时由操作系统向进程发送的消息。为了响应该消息，执行与消息相关的自定义操作的过程“处理”或“信号处理”。 信号与 signal 函数信号注册函数，请求操作系统当子进程结束时调用某函数。 ##include \u003csignal\u003e void (*signal(int signo, void(*func)(int)))(int) 上述函数的返回值类型为函数指针。第一个参数为特殊情况信息，第二个参数为特殊情况下将要调用的函数的地址值（指针）。发生第一个参数代表的情况时，调用第二个参数所指的函数。可以在signal函数中注册的部分特殊情况和对应常数如下: SIGALRM: 已到通过调用alarm函数注册的时间 SIGNIT: 输入CTRL + C SIGCHLD: 子进程终止 比如，编写调用signal函数完成“子进程终止则调用 myChild 函数”的请求，语句如下: signal(SIGCHILD, myChild); 以上就是信号注册过程。注册好信号后，发生注册信号时（注册的情况发生时），操作系统将调用该信号对应的函数。 先介绍alarm函数。 ##include \u003cunistd.h\u003e unsigned int alarm(unsigned int seconds); // 返回0或者以秒为单位的距SIGALRM信号发生所剩时间 如果调用该函数的同时向它传递一个正整型函数，相应时间后（以秒为单位）将产生 SIGALRM 信息。若向该函数传递 0，则之前对 SIGALRM 信号预约将取消。如果通过该函数预约信号后为指定该信号对应的处理函数，则（通过调用signal函数）终止进程，不做任何处理。 示例如下: ##include \u003csignal.h\u003e ##include \u003cunistd.h\u003e ##include \u003cstdio.h\u003e void timeout(int sig) { if (sig == SIGALRM) puts(\"Time out!\"); alarm(2); } void keycontrol(int sig) { if (sig == SIGINT) puts(\"CTRL + C pressed\"); } int main(int argc, char *argv[]) { int i; signal(SIGALRM, timeout); signal(SIGINT, keycontrol); alarm(2); for (i = 0; i \u003c 3; i++) { puts(\"wait...\"); sleep(100); } return 0; } 发生信号时将唤醒由于调用sleep函数而进入阻塞状态的进程。调用函数的主体是操作系统，但进程处于睡眠状态无法调用函数。因此，产生信号时，为了调用信号处理器 ，将唤醒由于调用sleep函数而进入阻塞状态的进程。而且，进程一旦被唤醒，就不会再进入睡眠状态。即使还未到sleep函数中规定的时间也如此。所以上述示例运行不到 10 秒就会结束，连续输入CTRL + C可能 1 秒都不到。 利用 sigaction 函数进行信号处理sigaction函数类似于signal函数，且完全可以代替它，也更稳定。稳定的原因是signal函数在 UNIX 系列的不同操作系统中可能存在区别，但sigaction函数完全相同。 ##include \u003csignal.h\u003e int sigaction(int signo, const struct sigaction* act, struct sigaction* oldact); // 成功时返回0，失败时返回-1 // signo 与signal函数相同，传递信号信息 // act 对于与第一个参数的信号处理函数（信号处理器）信息 // oldact 通过参数获取之前注册的信号处理函数指针，若不需要则传递0 声明并初始化sigaction结构体变量以调用上述函数，该结构体定义如下: 结构体的sa_handler成员保存信号处理函数的指针值（地址值）。 示例如下: ##include \u003csignal.h\u003e ##include \u003cstdio.h\u003e ##include \u003cunistd.h\u003e void timeout(int sig) { if (sig == SIGALRM) { puts(\"Time out!\"); } alarm(2); } int main(int argc, char *argv[]) { int i; struct sigaction act; act.sa_handler = timeout; sigemptyset(\u0026act.sa_mask); act.sa_flags = 0; sigaction(SIGALRM, \u0026act, 0); alarm(2); for (i = 0; i \u003c 3; i++) { puts(\"wait...\"); sleep(100); } return 0; } 利用信号处理技术消灭僵尸进程进程终止时将产生SIGCHLD信号。 ##include \u003cstdio.h\u003e ##include \u003cstdlib.h\u003e ##include \u003cunistd.h\u003e ##include \u003csignal.h\u003e ##include \u003csys/wait.h\u003e void read_childproc(int sig) { int status; pid_t pid = waitpid(-1, \u0026status, WNOHANG); if (WIFEXITED(status)) { printf(\"Removed proc id : %d\\n\", pid); printf(\"Child send : %d \\n\", WEXITSTATUS(status)); } } int main(int argc, char *argv[]) { pid_t pid; struct sigaction act; act.sa_handler = read_childproc; sigemptyset(\u0026act.sa_mask); act.sa_flags = 0; sigaction(SIGCHLD, \u0026act, 0); pid = fork(); if (pid == 0) // 子进程执行区域 { puts(\"Hi! I am child process\"); sleep(10); return 12; } else // 父进程执行区域 { printf(\"Child proc is : %d\\n\", pid); pid = fork(); if (pid == 0) // 另一子进程执行区域 { puts(\"Hi! I am child process\"); sleep(10); exit(24); } else { int i; printf(\"Child proc is : %d\\n\", pid); for (i = 0; i \u003c 5; i++) { puts(\"wait...\"); sleep(5); } } } return 0; } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:3","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r基于多任务的并发服务器\r基于进程的并发服务器模型此前的回声服务器端每次都只能向一个客户端提供服务。因此，我们可以扩展回声服务器端，使其可以同时向国歌客户端提供服务，实现模型如下。 每当有客户端请求服务（连接请求）时，回声服务器都创建子进程以提供服务。请求服务的客户端若有 5 个，则将创建 5 个子进程提供服务。过程如下: 第一阶段：回声服务器端（父进程）通过调用accept函数受理连接请求 第二阶段：此时获取的套接字文件描述符创建并传递给子进程 第三阶段：子进程利用传递来的文件描述符提供服务 子进程会复制父进程拥有的所有资源，实际上根本不哦那个另外传递文件描述符的过程。 实现并发服务器 // echo_mpserv.c ##include \u003cstdio.h\u003e ##include \u003cstdlib.h\u003e ##include \u003cstring.h\u003e ##include \u003cunistd.h\u003e ##include \u003csignal.h\u003e ##include \u003csys/wait.h\u003e ##include \u003carpa/inet.h\u003e ##include \u003csys/socket.h\u003e ##define BUF_SIZE 30 void error_handling(char *message); void read_childproc(int sig); int main(int argc, char *argv[]) { int serv_sock, clnt_sock; struct sockaddr_in serv_adr, clnt_adr; pid_t pid; struct sigaction act; socklen_t adr_sz; int str_len, state; char buf[BUF_SIZE]; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } act.sa_handler = read_childproc; sigemptyset(\u0026act.sa_mask); act.sa_flags = 0; state = sigaction(SIGCHLD, \u0026act, 0); serv_sock = socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family = AF_INET; serv_adr.sin_addr.s_addr = htonl(INADDR_ANY); serv_adr.sin_port = htons(atoi(argv[1])); if (bind(serv_sock, (struct sockaddr *)\u0026serv_adr, sizeof(serv_adr)) == -1) { error_handling(\"bind() error\"); } if (listen(serv_sock, 5) == -1) { error_handling(\"listen() error\"); } while (1) { adr_sz = sizeof(clnt_adr); clnt_sock = accept(serv_sock, (struct sockaddr *)\u0026clnt_adr, \u0026adr_sz); if (clnt_sock == -1) { continue; } else { puts(\"new client connected...\"); } pid = fork(); if (pid == -1) { close(clnt_sock); continue; } if (pid == 0) // 子进程运行区域 { close(serv_sock); while ((str_len = read(clnt_sock, buf, BUF_SIZE)) != 0) { write(clnt_sock, buf, str_len); } close(clnt_sock); puts(\"client disconnected...\"); return 0; } else { close(clnt_sock); } } close(serv_sock); return 0; } void read_childproc(int sig) { pid_t pid; int status; pid = waitpid(-1, \u0026status, WNOHANG); printf(\"removed proc id %d \\n\", pid); } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } 启动服务器后，可以发现服务器可以向多个客户端提供服务。 通过 fork 函数复制文件描述符echo_mpserv.c中父进程将 2 个套接字（一个服务器端套接字，一个是与客户端连接的套接字）文件描述符复制给子进程。 只复制文件描述符吗？是否也复制了套接字？ 调用fork函数时复制父进程的所有资源，但套接字并非进程所有——严格意义上说，套接字属于操作系统——只是进程拥有代表相应套接字的文件描述符。 调用fork函数后，2 个文件描述符指向同一套接字。 1 个套接字中存在 2 个文件描述符时，只有 2 个文件描述符都终止（销毁）后，才能销毁套接字。如果维持上图中的连接状态，即使子进程销毁了与客户端连接的套接字文件描述符，也无法完全销毁套接字（服务器端套接字同样如此）。因此，调用fork函数后，要将无关的套接字文件描述符关掉，如下图所示。 为了将文件描述符整理成上图形式，echo_mpserv.c调用了close函数。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:4","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r分割 TCP 的 I/O 程序\r分割 I/O 程序的优点已经实现的回声客户端的数据回声方式如下： 向服务器端传输数据，并等待服务器端回复。无条件等待，直到接受完服务器端的回声数据后，才能传输下一批数据。 传输数据后需等待服务器端返回的数据，因为程序代码中重复调用了read和write函数。这么写的原因是，程序在 1 个进程中运行。现在可创建多个进程，因此可以分割数据收发过程。分割模型如下: 如此实现的一个重要原因是程序实现更简单。父进程中只需编写接收数据的代码，子进程中只需编写发送数据的代码，所以会简化。 另一个好处是可以提高频繁交换数据的性能。 分割 I/O 后的客户端发送数据时不必考虑接收数据的情况，因此可以连续发送数据，由此提高同一时间内传输的数据量。这种差异在网络较慢时尤为明显。 回声客户端的 I/O 程序分割 // echo_mpclient.c ##include \u003cstdio.h\u003e ##include \u003cstdlib.h\u003e ##include \u003cstring.h\u003e ##include \u003cunistd.h\u003e ##include \u003carpa/inet.h\u003e ##include \u003csys/socket.h\u003e ##define BUF_SIZE 30 void error_handling(char *message); void read_routine(int sock, char *buf); void write_routine(int sock, char *buf); int main(int argc, char *argv[]) { int sock; char buf[BUF_SIZE]; pid_t pid; struct sockaddr_in serv_addr; if (argc != 3) { printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e \\n\", argv[0]); exit(1); } sock = socket(PF_INET, SOCK_STREAM, 0); if (sock == -1) { error_handling(\"socket() error\"); } memset(\u0026serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = inet_addr(argv[1]); serv_addr.sin_port = htons(atoi(argv[2])); if (connect(sock, (struct sockaddr *)\u0026serv_addr, sizeof(serv_addr)) == -1) { error_handling(\"connect() error\"); } else { puts(\"connected....\"); } pid = fork(); if (pid == 0) { write_routine(sock, buf); } else { read_routine(sock, buf); } close(sock); return 0; } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } void read_routine(int sock, char *buf) { while (1) { int str_len = read(sock, buf, BUF_SIZE); if (str_len == 0) { return; } buf[str_len] = 0; printf(\"Message from server : %s\", buf); } } void write_routine(int sock, char *buf) { while (1) { fgets(buf, BUF_SIZE, stdin); if (!strcmp(buf, \"q\\n\") || !strcmp(buf, \"Q\\n\")) { shutdown(sock, SHUT_WR); return; } write(sock, buf, strlen(buf)); } } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:5","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r进程间通信","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:11:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r进程间通信的基本概念进程间通信（Inter Process Communication）意味着两个不同进程间可以交换数据，为了完成这一点，操作系统中应提供两个进程可以同时访问的内存空间。 对进程通信的基本理解只要有两个进程可以同时访问的内存空间，就可以通过此空间交换数据。但进程具有完全独立的内存结构。连通过fork函数创建的子进程也不会与父进程共享内存空间。因此，进程间通信只能通过其他特殊方法完成。 通过管道实现进程间通信 为了完成进程间通信，需要创建管道。管道并非属于进程的资源，而是和套接字一样，属于操作系统（也就不是fork函数的复制对象）。所以，两个进程通过操作系统提供的内存空间进行通信。创建管道的函数如下: ##include \u003cunistd.h\u003e int pipe(int filedes[2]); // 成功返回0，失败返回-1 // filedes[0] 通过管道接收数据时使用的文件描述符，即管道出口 // filedes[1] 通过管道传输数据时使用的文件描述符，即管道入口 以长度为 2 的 int 数组地址值作为参数调用上述函数时，数组中存有两个文件描述符，它们将被用作管道的出口和入口。父进程调用该函数时将创建管道，同时获取对应于出入口的文件描述符，此时父进程可以读写同一管道。由于父进程的目的是与子进程进行数据交换，因此需要将入口或出口中的 1 个文件描述符传递给子进程。 // pipe1.c ##include \u003cstdio.h\u003e ##include \u003cunistd.h\u003e ##define BUF_SIZE 30 int main(int argc, char *argv[]) { int fds[2]; char str[] = \"Who are you?\"; char buf[BUF_SIZE]; pid_t pid; pipe(fds); pid = fork(); if (pid == 0) { write(fds[1], str, sizeof(str)); } else { read(fds[0], buf, BUF_SIZE); puts(buf); } return 0; } 上例中的通信方法如下。父子进程都可以访问管道 I/O 路径，但子进程仅用输入路径，父进程仅用输出路径。 通过管道进程进程间双向通信创建 2 个进程通过 1 个管道进程双向数据交换，通信方式如下: // pipe2.c ##include \u003cstdio.h\u003e ##include \u003cunistd.h\u003e ##define BUF_SIZE 30 int main(int argc, char *argv[]) { int fds[2]; char str1[] = \"Who are you?\"; char str2[] = \"Thank you for your message\"; char buf[BUF_SIZE]; pid_t pid; pipe(fds); pid = fork(); if (pid == 0) { write(fds[1], str1, sizeof(str1)); sleep(2); read(fds[0], buf, BUF_SIZE); printf(\"Child proc output : %s\\n\", buf); } else { read(fds[0], buf, BUF_SIZE); printf(\"Parent proc output : %s\\n\", buf); write(fds[1], str2, sizeof(str2)); sleep(3); } return 0; } 运行结果: 向管道传递数据时，先读的进程会把数据取走。简而言之，数据进入管道后称为无主数据。通过read函数先读取数据的进程将得到数据，即使是该进程将数据传到了管道。 只用 1 个管道进行双向通信并非易事。为了实现这点，程序需要预测并控制运行流程，这在每种系统中都不同，可以视为不可能完成的任务。我们可以通过创建 2 个管道进行双向通信。各自负责不同的数据流动即可。 ##include \u003cstdio.h\u003e ##include \u003cunistd.h\u003e ##define BUF_SIZE 30 int main(int argc, char *argv[]) { int fds1[2], fds2[2]; char str1[] = \"Who are you?\"; char str2[] = \"Thank you for your message\"; char buf[BUF_SIZE]; pid_t pid; pipe(fds1); pipe(fds2); pid = fork(); if (pid == 0) { write(fds1[1], str1, sizeof(str1)); read(fds2[0], buf, BUF_SIZE); printf(\"Child proc output : %s\\n\", buf); } else { read(fds1[0], buf, BUF_SIZE); printf(\"Parent proc output : %s\\n\", buf); write(fds2[1], str2, sizeof(str2)); sleep(3); } return 0; } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:11:1","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r运用进程间通信\r保存消息的回声服务器端扩展echo_mpserv.c，将回声客户端传输得的字符串按序保存到文件中。 我们可以将该任务委托给另外的进程。换言之，另行创建进程，从向客户端提供服务的进程读取字符串信息。当然，该过程中需要创建用于接收数据的管道。 // echo_storeserv.c ##include \u003cstdio.h\u003e ##include \u003cstdlib.h\u003e ##include \u003cstring.h\u003e ##include \u003cunistd.h\u003e ##include \u003csignal.h\u003e ##include \u003csys/wait.h\u003e ##include \u003carpa/inet.h\u003e ##include \u003csys/socket.h\u003e ##define BUF_SIZE 30 void error_handling(char *message); void read_childproc(int sig); int main(int argc, char *argv[]) { int serv_sock, clnt_sock; struct sockaddr_in serv_adr, clnt_adr; int fds[2]; pid_t pid; struct sigaction act; socklen_t adr_sz; int str_len, state; char buf[BUF_SIZE]; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } act.sa_handler = read_childproc; sigemptyset(\u0026act.sa_mask); act.sa_flags = 0; state = sigaction(SIGCHLD, \u0026act, 0); serv_sock = socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family = AF_INET; serv_adr.sin_addr.s_addr = htonl(INADDR_ANY); serv_adr.sin_port = htons(atoi(argv[1])); if (bind(serv_sock, (struct sockaddr *)\u0026serv_adr, sizeof(serv_adr)) == -1) { error_handling(\"bind() error\"); } if (listen(serv_sock, 5) == -1) { error_handling(\"listen() error\"); } pipe(fds); pid = fork(); if (pid == 0) { FILE *fp = fopen(\"echomsg.txt\", \"wt\"); char msgbuf[BUF_SIZE]; int i, len; for (i = 0; i \u003c 10; i++) { len = read(fds[0], msgbuf, BUF_SIZE); fwrite((void *)msgbuf, 1, len, fp); } fclose(fp); return 0; } while (1) { adr_sz = sizeof(clnt_adr); clnt_sock = accept(serv_sock, (struct sockaddr *)\u0026clnt_adr, \u0026adr_sz); if (clnt_sock == -1) { continue; } else { puts(\"new client connected...\"); } pid = fork(); if (pid == -1) { close(clnt_sock); continue; } if (pid == 0) // 子进程运行区域 { close(serv_sock); while ((str_len = read(clnt_sock, buf, BUF_SIZE)) != 0) { write(clnt_sock, buf, str_len); write(fds[1], buf, str_len); } close(clnt_sock); puts(\"client disconnected...\"); return 0; } else { close(clnt_sock); } } close(serv_sock); return 0; } void read_childproc(int sig) { pid_t pid; int status; pid = waitpid(-1, \u0026status, WNOHANG); printf(\"removed proc id %d \\n\", pid); } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:11:2","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\rI/O 复用","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:12:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r多种 I/O 函数","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:13:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r多播与广播","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:14:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r套接字和标准 I/O","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:15:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r关于 I/O 流分离的其他内容","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:16:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r由于 select 和 epoll","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:17:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r多线程服务器端的实现","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:18:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\rWindows 平台下的线程的使用","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:19:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\rWindows 中的线程同步","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:20:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r异步通知的 I/O 模型","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:21:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r重叠 I/O 模型","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:22:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r制作 HTTP 服务器端","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:23:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r进阶内容","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:24:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r推荐Windows Sockets 2: https://learn.microsoft.com/en-us/windows/win32/api/_winsock/ 《计算机网络 自顶向下》 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:25:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r参考《TCP/IP 网络编程》 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:26:0","tags":["TCP/IP","计算机网络","网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["细读经典"],"content":"\r2023/11/23 更新: 增加 4 个练习项目——Parallax scroll animation、Voyage Slider、App Menu With Lock Screen 和 Old Film Effect 2023/12/13 更新: 增加练习项目——Polaroid Camera 2024/10/08 更新: 选择器增加来自@Shefali__J的选择器速查表 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:0:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r准备随书代码: https://github.com/CSSInDepth/css-in-depth Node.js: https://nodejs.org/en/ Visual Studio Code: https://code.visualstudio.com/ Git: https://git-scm.com/ ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:1:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r层叠、优先级和继承","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:2:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r层叠当声明冲突时，层叠会依据三种条件解决冲突。 样式表的来源: 样式是从哪里来的，包括你的样式和浏览器默认样式。 选择器优先级: 哪些选择器比另一些选择器更重要。 源码顺序: 样式在样式表里的声明顺序。 选择器和声明块一起构成了规则集（ruleset）。一个规则集也简称一个规则。 @规则（at-rules）是指用@符号开头的语法，比如@import规则或者@media查询。 样式表的来源自己的样式表属于作者样式表，除此之外还有用户代理样式表，即浏览器默认样式。用户代理样式表优先级低，自己的样式会覆盖它们。 标记了!important的声明会被当作更高优先级的来源，因此总体的优先级按照由高到低排列如下所示: 作者的!important 作者 用户代理 理解优先级如果无法用来源解决冲突声明，浏览器会尝试检查它们的优先级。 浏览器将优先级分为两部分: HTML 的行内样式和选择器样式。 优先级的规则如下： 如果选择器的 ID 数量更多，则它会胜出。 如果 ID 数量一致，那么拥有更多类的选择器胜出。 如果以上两次比较都一致，那么拥有最多标签名的选择器胜出。 伪类选择器（如:hover）和属性选择器（如[type=\"input\"]）与一个类选择器的优先级相同。通用选择器（*）和组合器（\u003e、+、~）对优先级没有影响。 我们可以用优先级标记来比较不同选择器的优先级: 通常最好让优先级尽可能低，这样当需要覆盖一些样式时，才能有选择空间。 源码顺序如果两个声明的来源和优先级相同，其中一个声明在样式表中出现比较晚，或者位于页面较晚引入的样式表中，则该声明胜出。 两条经验法则 在选择器中不要使用 ID。就算只用一个 ID，也会大幅度提升优先级。但需要覆盖整个选择器时，通常找不到另一个有意义的 ID，于是就会复制原来的选择器，然后加上另一个类，以区别想要覆盖的选择器。 不要使用!important。它比 ID 更难覆盖，一旦用了它，想要覆盖原先的声明，就需要加上一个!important，而且依然要处理优先级的问题。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:2:1","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r继承只有特定的属性能被继承，通常是我们希望被继承的那些。它们主要是跟文本相关的属性: color font font-family font-size font-weight font-variant font-style line-height letter-spacing text-align text-indent text-transform white-space word-spacing 列表属性也可以被继承: list-style list-style-type list-style-position list-style-image 活用开发者工具了解具体情况: ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:2:2","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r特殊值有两个特殊值可以赋给任意属性，用户控制层叠: inherit和initial。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:2:3","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r简写属性https://developer.mozilla.org/zh-CN/docs/Web/CSS/Shorthand_properties ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:2:4","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r相对单位相对单位会根据外部因素发生变化。例如，2em的具体值会更具它作用到的元素（有时甚至是根据属性）而变化。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r相对单位的好处响应式: 能够根据浏览器窗口的大小有不同的“响应”。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:1","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\rem 和 rem在 CSS 中，1em等于当前元素的字号，其准确值取决于作用的元素。 浏览器会根据相对单位的值计算出绝对值，称作计算值（computed value）。 使用 em 定义字号如果声明font-size: 1.2em，这个font-size是根据继承的字号来计算的。 body { font-size: 16px; } .slogan { font-size: 1.2em; /* 19.2px */ padding: 1.2em; /* 23.04px */ } 字体缩小问题 body { font-size: 16px; } ul { font-size: .8em; } 会导致嵌套的列表字体越来越小。纠正方法如下: ul { font-size: .8em; } ul ul { font-size: 1em; } 使用 rem 设置字号根节点有一个伪类选择器（:root），可以用来选中它自己。这等价于类型选择器html，但html的优先级相当于一个类名，而不是标签。 rem是 root em 的缩写。rem 不是相当于当前元素，而是相对于根元素的单位。 :root { font-size: 1em; /* 使用浏览器的默认字号(16px) */ } ul { font-size: .8rem; /* 12.8px */ } 提示: 拿不准的时候，用 rem 设置字号，用 px 设置边框，用 em 设置其他大部分属性。 通过这种策略，可以轻松构建响应式面板: .panel { padding: 1em; border-radius: 0.5em; border: 1px solid #999; } .panel \u003e h2 { margin-top: 0; font-size: 0.8rem; font-weight: bold; text-transform: uppercase; } 使用媒体查询改变根元素的字号。这样就可以基于不同用户的屏幕尺寸，渲染出不同大小的面板。 :root { font-size: 0.75em; } @media (min-width: 800px) { /* 宽度800px以上 */ :root { font-size: 0.875em; } } @media (min-width: 1200px) { /* 宽度1200px以上 */ :root { font-size: 1em; } } 充分体现了使用em的优势。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:2","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r视口的相对单位视口: 浏览器窗口中网页可见部分的边框区域。不包括浏览器的地址栏、工具栏、状态栏。 vh: 视口高度的 1/100 vw: 视口宽度的 1/100 vmin: 视口宽、高中较小一方的 1/100 vmax: 视口宽、高中较大一方的 1/100 使用 vw 定义字号给一个元素加上font-size: 2vw在一个 1200px 的显示器上计算值为 24px。在一个 768px 宽的平板上，计算值约为 15px。这样做的好处在于元素能够在这两种大小之间平滑地过渡， 这意味着不会在某个断点突然开始改变。当视口大小改变时，元素会逐渐过渡。 使用 calc()定义字号calc()函数内可以对两个及其以上的值进行基本运算。支持的运算包括加减乘除。 :root { font-size: calc(0.5em + 1vw); } https://gist.github.com/basham/2175a16ab7c60ce8e001 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:3","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r自定义属性(即 CSS 变量)定义一个自定义属性: :root { --main-font: Helvetica, Arial, sans-serif; } p { font-family: var(--main-font); } 变量名用两个连字符用来和 CSS 属性区分。 变量必须在一个声明块内声明。这里用了:root选择器，所以可以在整个网页使用。 var()函数接受第二个参数，它指定了备用值。如果第一个参数指定的变量未定义，那么就会使用第二个值。 若 var()函数算出来的是一个非法值，对应的属性就会设置为其初始值。 动态改变自定义属性自定义属性的声明能够层叠和继承：可以再多个选择器中定义相同的变量，这个变量在网页的不同地方有不同的值。 如下所示: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003e导航\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"style.css\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003cheader class=\"page-header\"\u003e \u003ch1 class=\"title\" id=\"page-title\"\u003eWombat Coffe Roasters\u003c/h1\u003e \u003cnav\u003e \u003cul class=\"nav\" class=\"main-nav\"\u003e \u003cli\u003e\u003ca href=\"/\"\u003eHome\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/coffees\"\u003eCoffes\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/brewers\"\u003eBrewers\u003c/a\u003e\u003c/li\u003e \u003cli\u003e \u003ca href=\"/specials\" class=\"featured\"\u003eSpecials\u003c/a\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/nav\u003e \u003c/header\u003e \u003cmain\u003e \u003cdiv class=\"panel\"\u003e\u003c/div\u003e \u003cdiv class=\"panel dark\"\u003e\u003c/div\u003e \u003c/main\u003e \u003c/body\u003e \u003c/html\u003e :root { font-size: calc(0.5em + 0.5vw); --bg-color: #368; } h1 { font-family: sans-serif; } ##page-title { font-family: sans-serif; } .title { font-family: monospace; } .panel { width: 5em; height: 5em; background-color: var(--bg-color); margin: 1em; } .dark { --bg-color: #000; } 使用 JavaScript 改变自定义属性 const rootElement = document.documentElement; const styles = getComputedStyle(rootElement); const bgColor = styles.getPropertyValue(\"--bg-color\"); console.log(String(bgColor).trim()); rootElement.style.setProperty(\"--bg-color\", \"red\"); ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:4","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r盒模型\r调整盒模型在 CSS 中可以使用box-sizing属性调整盒模型的行为。其默认值为content-box，任何指定的宽或高都只会设置内容盒子的大小。将其值设为border-box后，height和width属性会设置内容、内边距以及边框的大小总和。 全局设置 border-box通用选择器*可以选中页面上所有元素，并用两个选择器选中网页的所有伪元素。 *, ::before, ::after { box-sizing: border-box; } 如果用了第三方组件，使用上述方式可能会破坏其中一些组件的布局。我们可以利用继承改一下修改盒模型的方式。 :root { box-sizing: border-box; } *, ::before, ::after { box-sizing: inherit; } ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:5","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r元素高度的问题通常最好避免给元素指定明确的高度。普通文档流是为限定的宽度和无限的高度设计的。内容会填满视口的高度，然后在必要的时候折行。因此，容器的高度由内容天然地决定，而不是容器自己决定。 普通文档流——指的是网页元素的默认布局行为。行内元素跟随文字的方向从左到右排列，当到达容器边缘时会换行。块级元素会占据完整的一行，前后都有换行。 控制溢出行为当明确设置一个元素的高度时，内容可能会溢出。当内容在限定区域放不下渲染到父元素外面时，就会发生这种现象。 用 overflow 属性可以控制溢出内容的行为，该属性支持以下 4 个值。 visible（默认值）——所有内容可见，即使溢出容器边缘。 hidden——溢出容器内边距边缘的内容被裁剪，无法看见。 scroll——容器出现滚动条。 auto——只有内容溢出时容器才会出现滚动条。 百分比高度的备选方案用百分比指定高度存在问题。百分比参考的事元素容器块的大小，但是容器的高度通常是由子元素的高度决定的。这样会造成死循环，浏览器处理不了，因此它会忽略这个声明。想要让百分比高度生效，必须给父元素明确定义一个高度。 CSS 表格布局 给容器设置display: table，给每一列设置display: table-cell。这里没有table-row元素，因为 CSS 表格不像 HTML 表格那样必须有行元素。 不像block的元素，默认情况下，显示为table的元素宽度不会扩展到 100%，因此需要明确指定宽度。但外边距不会作用于table-cell元素。 可以用表格元素border-spacing属性来定义单元格的间距。该属性接受两个长度值: 水平间距和垂直间距。可以给容器加上border-spacing: 1.5em 0，但这会产生一个副作用: 这个值也会作用于表格的外边缘。如此一来就无法和头部左右对齐。 我们可以使用负外边距解决这个问题，但这需要给整个表格包裹一层新的容器。代码如下: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003e盒模型\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"style.css\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003cheader\u003e \u003ch1\u003eFranklin Running Club\u003c/h1\u003e \u003c/header\u003e \u003cdiv class=\"wrapper\"\u003e \u003cdiv class=\"container\"\u003e \u003cmain class=\"main\"\u003e \u003cp\u003e The Franklin Running Club meets at 6:00pm every Thursday at the town square. Runs are three to five miles, at your own pace. \u003c/p\u003e \u003c/main\u003e \u003caside class=\"sidebar\"\u003e \u003cdiv class=\"widget\"\u003e\u003c/div\u003e \u003cdiv class=\"widget\"\u003e\u003c/div\u003e \u003c/aside\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 样式设置如下: :root { box-sizing: border-box; } *, ::before, ::after { box-sizing: inherit; } .wrapper { margin-left: -1.5em; margin-right: -1.5em; } .container { display: table; border-spacing: 1.5em 0; width: 100%; } body { background-color: #eee; font-family: Helvetica, Arial, sans-serif; } header { color: #fff; background-color: #0072b0; border-radius: 0.5em; } main { display: block; } .main { display: table-cell; width: 70%; background-color: #fff; border-radius: 0.5em; } .sidebar { display: table-cell; margin-left: 1.5em; width: calc(30% - 1.5em); padding: 1.5em; background-color: #fff; border-radius: 0.5em; } Flexbox 还可以用 Flexbox 实现两列等高布局。Flexbox 不需要一个额外的 div 包裹元素，它默认会产生等高的元素，也不需要使用负外边距。 :root { box-sizing: border-box; } *, ::before, ::after { box-sizing: inherit; } .container { display: flex; } body { background-color: #eee; font-family: Helvetica, Arial, sans-serif; } header { color: #fff; background-color: #0072b0; border-radius: 0.5em; } main { display: block; } .main { width: 70%; background-color: #fff; border-radius: 0.5em; } .sidebar { width: 30%; padding: 1.5em; margin-left: 1.5em; background-color: #fff; border-radius: 0.5em; } 弹性容器（Flex Container）子元素默认等高。 使用 min-height 和 max-height可以用这两个属性指定最小或最大值，而不是明确定义高度，这样元素就可以再这些界限内自动决定高度。 可以用min-height指定一个最小高度，而不指定它的明确高度。这意味着元素至少等于指定的高度，如果内容太多，浏览器就会允许元素自己扩展高度，以免内容溢出。 max-height允许元素自然地增加到一个特定界限。如果到达这个界限，元素就不再增高，内容会溢出。 还有类似属性min-width和max-width。 垂直居中给块级元素设置vertical-align: middle后，通常不能垂直居中，因为浏览器会忽略这个声明。 vertical-align声明只会影响行内元素或table-cell元素。 垂直居中指南 http://howtocenterincss.com/ ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:6","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r负外边距https://www.educba.com/negative-margin-css/ ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:7","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r外边距折叠在没有其他 CSS 的影响下，所以相邻的顶部和底部外边距都会折叠。 只有上下外边距会产生折叠，左右外边距不会折叠。 如下方法可以防止外边距折叠： ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:8","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r容器内的元素间距猫头鹰选择器 body * + * { margin-top: 1.5em; } ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:9","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r理解浮动","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:4:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r浮动的设计初衷浮动能将一个元素（通常是一张图片）拉到容器的一侧，这样文档流就能包围它。 浮动元素会被移除正常文档流，并被拉到容器边缘。文档流会重新排列，但是它会包围浮动元素此刻所占据的空间。 如果让多个元素向同侧浮动，它们就会挨着排列。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:4:1","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r容器折叠和清楚浮动\r理解容器折叠 \u003c!doctype html\u003e \u003chead\u003e \u003cstyle\u003e :root { box-sizing: border-box; } *, ::before, ::after { box-sizing: inherit; } body { background-color: #eee; font-family: Helvetica, Arial, sans-serif; } body * + * { margin-top: 1.5em; } header { padding: 1em 1.5em; color: #fff; background-color: #0072b0; border-radius: .5em; margin-bottom: 1.5em; } .main { padding: 0 1.5em; background-color: #fff; border-radius: .5em; } .container { max-width: 1080px; margin: 0 auto; } .media { float: left; width: 50%; padding: 1.5em; background-color: #eee; border-radius: 0.5em; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"container\"\u003e \u003cheader\u003e \u003ch1\u003eFranklin Running Club\u003c/h1\u003e \u003c/header\u003e \u003cmain class=\"main clearfix\"\u003e \u003ch2\u003eRunning tips\u003c/h2\u003e \u003cdiv\u003e \u003cdiv class=\"media\"\u003e \u003cimg class=\"media-image\" src=\"runner.png\"\u003e \u003cdiv class=\"media-body\"\u003e \u003ch4\u003eStrength\u003c/h4\u003e \u003cp\u003e Strength training is an important part of injury prevention. Focus on your core\u0026mdash; especially your abs and glutes. \u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"media\"\u003e \u003cimg class=\"media-image\" src=\"shoes.png\"\u003e \u003cdiv class=\"media-body\"\u003e \u003ch4\u003eCadence\u003c/h4\u003e \u003cp\u003e Check your stride turnover. The most efficient runners take about 180 steps per minute. \u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"media\"\u003e \u003cimg class=\"media-image\" src=\"shoes.png\"\u003e \u003cdiv class=\"media-body\"\u003e \u003ch4\u003eChange it up\u003c/h4\u003e \u003cp\u003e Don't run the same every time you hit the road. Vary your pace, and vary the distance of your runs. \u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"media\"\u003e \u003cimg class=\"media-image\" src=\"runner.png\"\u003e \u003cdiv class=\"media-body\"\u003e \u003ch4\u003eFocus on form\u003c/h4\u003e \u003cp\u003e Run tall but relaxed. Your feet should hit the ground beneath your hips, not out in front of you. \u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/main\u003e \u003c/div\u003e \u003c/body\u003e 效果如下： 容器白色的背景没有延伸到媒体盒子后面。这是因为浮动元素不同于普通文档流的元素，它们的高度不会加到父元素上。 一个解决的办法是使用和浮动配套的clear属性。将一个元素放在主容器末尾，并对其使用clear，这会让容器扩展到浮动元素下面。 \u003cmain class=\"main\"\u003e ... \u003cdiv style=\"clear: both;\"\u003e\u003c/div\u003e \u003c/main\u003e 因为空div本身没有浮动，所以容器就会扩展，直到包含它。 理解清除浮动 伪元素——特殊的选择器，可以选中文档的特定部分。伪元素以双冒号开头，大部分浏览器为了向后兼容也支持单冒号形式。 .clearfix::after { display: block; content: \" \"; clear: both; } 要给包含浮动的元素清除浮动。 https://learningnow.com.tw/css-float/ ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:4:2","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\rFlexbox","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:5:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\rFlexbox 的原则给元素添加display: flex，该元素就变成了一个弹性容器（Flex Container），它的直接子元素就变成了弹性子元素（Flex Item）。弹性子元素默认是在同一行按照从左到右的顺序并排排列。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:5:1","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r弹性子元素的大小flex属性控制弹性子元素在主轴方向上的大小（宽度）。 .column-main { flex: 2; } .column-sidebar { flex: 1; } flex属性是三个不同大小属性的简写：flex-grow、flex-shrink和flex-basis。 flex: 2等价于flex: 2 1 0%，也可以分别声明: .column-main { flex-grow: 2; flex-shrink: 1; flex-basis: 0%; } 使用flex-basis属性flex-basis定义了元素大小的基准值，即一个初始的主尺寸。flex-basis属性可以设置为任意的 width 值，包括 px、em、百分比。它的初始值是auto，此时浏览器会检查元素是否设置了width属性值。如果有，则使用width的值作为flex-basis的值；如果没有，则用元素内容自身的大小。使用flex-basis的值不是 auto，width 属性会被忽略。 使用flex-grow属性每个弹性子元素的flex-basis值计算出来后，它们（加上子元素之间的外边距）加起来会占据一定的宽度。加起来的宽度不一定正好填满弹性容器的宽度，多出来的留白会按照 flex-grow 的值分配每个弹性子元素。 flex-grow 的值为非负数。若一个弹性子元素的值 flex-grow 值为 0，那么它的宽度不会超过 flex-basis 的值；如果某个弹性子元素的 flex-grow 非 0，那么这些元素会增长到所有的剩余空间被分配完。 使用flex-shrink属性计算出弹性子元素的初始主尺寸后，它们的累加值可能会超出弹性容器的可用宽度。如果不用flex-shrink，就会导致溢出。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:5:2","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r弹性方向 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:5:3","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r对齐、间距等细节通常情况下，创建一个弹性盒子方法如下: 选择一个容器及其子元素，给容器设置display: flex 如有必要，给容器设置flex-direction 给弹性子元素设置外边距和/或 flex 值，用来控制它们的大小 理解弹性容器的属性弹性容器的属性: 弹性子元素的属性: ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:5:4","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r网格布局","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:6:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r网页布局开启新纪元和 Flexbox 类似，设置为display: grid的元素成为一个网格容器。它的子元素变成网格元素。 .grid { display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr; grid-gap: 0.5em; } .grid \u003e * { background-color: darkgray; color: white; padding: 2em; border-radius: 0.5em; } grid-template-columns和grid-template-rows定义了网格每列每行的大小。使用了一个新单位fr，代表每一列（或每一行）的分数单位（fraction unit）。 这个单位和 Flexbox 中flex-grow因子的表现一样。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:6:1","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r网络剖析 repeat()函数，在声明多个网格轨道时提供了简写方式。grid-template-rows: repeat(4, auto);定义了四个水平网格轨道。轨道大小设置为auto，轨道会根据自身内容扩展。 用repeat()符号还可以定义不同的重复模式，比如repeat(3, 2fr, 1fr)会重复三遍这个模式，从而定义 6 个网格轨道。 可以给网格线或网格区域命名。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:6:2","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r显式和隐式网格使用grid-template-*属性定义网格轨道时，创建的是显式网格。 可以给网格容器设置grid-auto-columns和grid-auto-rows为隐式网格轨道指定一个大小。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:6:3","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r对齐 CSS Grid 网格布局教程: https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html 最强大的 CSS 布局 —— Grid 布局: https://juejin.cn/post/6854573220306255880 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:6:4","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r定位和层叠上下文position属性可以用来构建下拉菜单、模态框以及现代 Web 应用程序的一些基本效果。 position属性的初始值是static。如果把它改成其他值，就说元素被定位了。若元素使用了静态定位，那么就说它未被定位。 定位将元素彻底从文档流中移走，允许将元素放在屏幕的任意位置。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:7:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r固定定位给一个元素设置position: fixed就能将元素放在视口的任意位置。这需要搭配四种属性一起使用：top、right、bottom和left。 这些属性的值决定了固定定位的元素与浏览器视口边缘的距离。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:7:1","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r绝对定位绝对定位不是相对视口，而是相对最近的祖先定位元素。 如果祖先元素都没有定位，那么绝对定位的元素会基于初始包含块来定位。初始包含块和视口一样大，固定在网页的顶部。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:7:2","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r相对定位相对定位会让元素从原来的位置移走。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:7:3","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r层叠上下文和z-index拥有较高z-index的元素出现在拥有较低z-index的元素前面。拥有负数z=index的元素出现在静态元素后面。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:7:4","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r响应式设计响应式设计的三大原则: 移动优先。在实现桌面布局之前先构建移动版的布局。 @media 规则。使用该样式规则，可以为不同大小的视口定制样式。通常叫作媒体查询，写的样式只有在特定条件下才会生效。 流式布局。这种方式允许容器根据视口宽度缩放尺寸。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:8:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r移动优先构建桌面版之前要先构建移动端布局。 移动端布局一般是很朴素的设计。主要关注的是内容，在大屏上，可以把页面的大块区域拿来做头部、主图和菜单。在移动设备上，用户通常有更明确的目标。 做响应式设计时，要确保 HTML 包含各种屏幕尺寸所需的全部内容。可以对每个屏幕尺寸应用不同的 CSS，但必须共享同一份 HTML。 断点（breakpoint）：一个特殊的临界值。屏幕尺寸到达这个值时，网页的样式会发生改变，以便给当前屏幕尺寸提供最佳的布局。 视口meta标签。该 HTML 标签告知移动设备，已特意将网页适配了小屏设备。如果不加该标签，移动浏览器会假定网页不是响应式的，并且会尝试模拟桌面浏览器，那之前的移动端设计就白做了。 为了避免这种情况，我们将meta标签包含进去。 \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /\u003e \u003ctitle\u003eWombat Coffee Roasters\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"./style.css\" /\u003e \u003c/head\u003e meta标签的content属性里包含两个选项。首先，它告诉浏览器当解析 CSS 时将设备宽度作为假定宽度，而不是一个全屏的桌面浏览器宽度。其次，当页面加载时，它使用initial-scale将缩放比设置为 100%。 现代浏览器的开发者工具提供了模拟移动浏览器的功能。 Using the viewport meta tag to control layout on mobile browsers: https://udn.realityripple.com/docs/Mozilla/Mobile/Viewport_meta_tag ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:8:1","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r媒体查询媒体查询允许某些样式只在页面满足特定条件时才生效。这样就可以根据屏幕大小定制样式。可以针对小屏设备定义一套样式，针对中等屏幕设备定义另一套样式，针对大屏幕设备再定义一套样式，这样就可以让页面的内容拥有多种布局。 媒体查询使用@media规则选择满足条件的设备。一条简单的媒体查询如下所示: @media (min-width: 560px) { .title \u003e h1 { font-size: 2.25rem; } } 在最外层的大括号内可以定义任意的样式规则。@media规则会对条件进行见检查，只有满足所有的条件时，才会让这些样式应用到页面上。上例中浏览器会检查min-width: 560px。只有当设备的视口宽度大于等于 560px 时，才会给标题设置2.25rem的字号，否则将会被忽略。 在媒体查询里更适合用 em，如: .title \u003e h1 { color: #333; text-transform: uppercase; font-size: 1.5rem; margin: 0.2em 0; } @media (min-width: 35em) { .title \u003e h1 { font-size: 2.25rem; } } 媒体查询的类型可以进一步将两个条件用and关键字联合起来组成一个媒体查询，如下所示: @media (min-width: 20em) and (max-width: 35em) {...} 这种联合媒体查询只在设备同时满足两个条件时生效。若设备只需满足多个条件之一，可以用逗号分隔: @media (max-width: 20em), (min-width: 35em) {...} 还有一些别的媒体特征，参考: https://developer.mozilla.org/en-US/docs/Web/CSS/@media 给网页添加断点在任何媒体查询之前，最先写的是移动端样式，然后设置越来越大的断点。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:8:2","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r流式布局流式布局（Fluid Layout），有时被称作液体布局（Liquid Layout），指的是使用的容器随视口宽度而变化。它和固定布局相反，固定布局的列都是用 px 或 em 单位定义。固定容器（例如，设定了width: 800px的元素）在小屏上会超出视口范围，导致需要水平滚动条，而流式容器会自动缩小以适应视口。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:8:3","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r响应式图片创建不同分辨率的图片副本，利用媒体查询发送合适的图片。或者使用srcset提供对应的图片。 The anatomy of responsive images: https://jakearchibald.com/2015/anatomy-of-responsive-images/ ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:8:4","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r推荐RWD 是什么？: https://welly.tw/serp-rank-optimization/what-is-rwd-and-how-to-use The Beginner’s Guide to Responsive Web Design: https://kinsta.com/blog/responsive-web-design/ ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:8:5","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r模块化 CSS","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:9:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r基础样式: 打好基础每个样式表的开头都要写一些给整个页面使用的通用规则。这些规则通常被称为基础样式，其他样式是构建在这些基础样式之上的。 :root { box-sizing: border-box; } *, *::before, *::after { box-sizing: inherit; } body { font-family: Helvetica, Arial, sans-serif; } normalize.css库，可以协助消除不同客户端浏览器上的不一致。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:9:1","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r模式库","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:10:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r背景、阴影和混合模式","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:11:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r渐变background属性还有很多功能等着我们去探索，实际上，它是以下八个属性的简写。 background-image: 指定一个文件或生成的颜色渐变作为背景图片 background-position: 设置背景图片的初始位置 background-size: 指定元素内背景图片的渲染尺寸 background-repeat: 决定在需要填充整个元素时，是否平铺图片 background-origin: 决定背景相对于元素的边框盒、内边距框盒（初始值）或内容盒子来定位 background-clip: 指定背景是否应该填充边框盒（初始值）、内边距框盒或内容盒子 background-attachment: 指定背景图片是随着元素上下滚动（初始值），还是固定在视口区域。使用fixed值会对页面性能产生负面影响 background-color: 指定纯色背景，渲染到背景图片下方 使用简写属性background可以设置指定的值，同时把其他属性重置为初始值。因此，在需要用到多个属性时，可以考虑用单独的值。 background-image可以接受一个图片 URL 路径，例如background-image: url(coffee-beans.jpg)。也可以接受一个渐变函数，例如一个从白色过渡到蓝色的渐变。 线性渐变 .fade { height: 200px; width: 400px; background-image: linear-gradient(to right, white, blue); } linear-gradient函数使用三个参数来定义行为: 角度、起始颜色和终止颜色。上例的角度是to right（也可以是to left、to top、to bottom，或者是to bottom right），意思是渐变从元素的左侧开始平滑过渡到右侧。也可以使用其他的颜色表示方法，比如#0000ff、rgb(0,0,255)或者transparent关键字。 可以用确切的单位（比如度）更精确地控制角度。值0deg代表垂直向上，更大的值会颜色顺时针变化，90deg代表向右渐变。 度是最常用的单位，还有一些其他单位可用来表示角度: rad: 弧度，完整的圆是 2Π turn: 代表环绕圆周的圈数 gad: 百分度，一个完整的圆是 400 百分度 可以定义包含多个颜色的渐变，其中每个颜色可以称为颜色节点（Color Stop）。下面例子包含三个颜色节点的渐变: .fade { height: 200px; width: 400px; background-image: linear-gradient(90deg, red, white, blue); } 一个渐变可以接受任意数量的颜色节点，节点之间用逗号分隔。渐变会自动均匀地平铺这些颜色节点。本例中，最左侧（0%）从红色开始，过渡到中间（50%）的白色，到最右侧的蓝色（100%）。我们也可以在渐变函数中为每个颜色节点明确指定位置。 .fade { height: 200px; width: 400px; background-image: linear-gradient(90deg, red 0%, white 50%, blue 100%); } 使用repeating-linear-gradient()可以实现重复渐变，对于重复渐变最好使用特定的长度而不是百分比，因为设置的值决定了要重复图片大小。 条纹进度条示例: .fade { height: 1em; width: 400px; background-image: repeating-linear-gradient( -45deg, #57b, #57b 10px, #148 10px, #148 20px ); border-radius: 0.3em; } 更多例子，请看 Stripes in CSS: https://css-tricks.com/stripes-css/ 径向渐变线性渐变是从元素的一端开始，沿着直线过渡到另一端。而径向渐变不同，它是从一个点，全方位向外扩展。 .fade { height: 200px; width: 400px; background-image: radial-gradient(white, blue); } 更多例子: 若想深入研究一下，可看 Using CSS gradients: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Images/Using_CSS_gradients ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:11:1","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r阴影阴影是另一种可以为网页增加立体感的特效。有两个属性可以常见阴影，box-shadow为元素盒子生成阴影，text-shadow为渲染后的文字生成阴影。 模糊半径用来控制阴影边缘模糊区域的大小（可以简单理解为模糊程度），可以为阴影生成一个更柔和、有点透明的边缘。扩展半径用来控制阴影的大小，设置为正值可以使阴影全方位变大，设置负值则会变小。 使用渐变和阴影形成立体感新建一个网页和样式表，添加如下内容: \u003cbutton class=\"butotn\"\u003eSign up now\u003c/button\u003e .button { padding: 1em; border: 0; font-size: 0.8rem; color: white; border-radius: 0.5em; background-image: linear-gradient(to bottom, #57b, #148); box-shadow: 0.1em 0.1em 0.5em #124; } .button:active { box-shadow: inset 0 0 0.5em #124, inset 0 0.5em 1em rgba(0, 0, 0, 0.4); } 上面的样式增加了一个inset关键字，这样可以让阴影出现在元素边框的内部，而非之前的外部。同时定义了不止一个阴影，用逗号分隔。通过这种方式可以添加多个阴影。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:11:2","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r混合模式多数情况下，不论是使用真正的图片还是渐变，元素一般只用一张背景图片。但某些情况下可能会想要用两张或者更多的背景图片，CSS 支持这么做。 background-image属性可以接受任意数量的值，相互之间用逗号分开。 .blend { background-image: url(./bear.jpg), linear-gradient(to bottom, #57b, #148); } 使用多个背景图片时，排在前面的图片会渲染到排序靠后图片的上面。在此例中，bear.jpg 会遮盖在线性渐变之上，渐变就会不可见。若我们使用两张背景图片，那么一般是希望第二章图片可以透视显示。这时就可以用混合模式（Blend Mode）。 示例: \u003cdiv class=\"blend\"\u003e\u003c/div\u003e .blend { min-height: 80vh; background-image: url(./bear.jpg), url(./bear.jpg); background-size: cover; background-repeat: no-repeat; background-position: -30vw, 30vw; background-blend-mode: multiply; /* 应用混合模式 */ } 大部分背景相关的属性可以接受多个值，以逗号分隔。background-position就使用了两个值，第一个值用到第一张背景图片上，第二个值用到第二章背景图片上。 background-size和background-repeat属性也可以接受多个值，若只设置一个值，就会应用到所有背景图片上。 background-size属性接受两个关键字值，分别是cover和contain。使用cover值可以调整背景图片的大小，让其填满整个元素，这样会导致图片的边缘被裁剪掉一部分；使用contain值可以保证整个背景图片可见，这可能导致元素的一些地方不会被背景图片覆盖。该属性也可以接受长度值，用来明确设置背景图片的宽度和高度。 修改混合模式的其他值可以看到不同效果，例如: 使用某种颜色或者渐变为图片着色 为图片添加某种纹理效果，比如划痕或者老胶片放映时的颗粒感等 缓和、加深或减小图片的对比度，使图片上的文字更具可读性 在图片上覆盖一条文字横幅，但让图片完整显示 为图片着色通过使用混合模式，我们可以将一张全彩的图片着色成单一色相的图片。 .blend { min-height: 80vh; background-image: url(\"./bear.jpg\"); background-color: #148; background-size: cover; background-repeat: no-repeat; background-position: center; background-blend-mode: luminosity; /* 使用明度混合模式 */ } background-blend-mode不仅会合并多个背景图片，还会合并background-color。明度混合模式将前景层（大熊图片）的明度，与背景层（蓝色背景色图层）的色相饱和度混合。 即最终使用背景色图层的颜色，但明暗程度来自大熊图片。 混合模式的类型如下图所示: 为图片添加纹理纹理图片以重复平铺的方式覆盖在大熊图片上方。 .blend { min-height: 80vh; background-image: url(\"./scratches.png\"), url(\"./bear.jpg\"); background-size: 200px, cover; background-repeat: repeat, no-repeat; background-position: center, center; background-blend-mode: soft-light; /* 使用柔光混合模式 */ } 使用融合混合模式background-blend-mode属性可以实现多张图片的混合，但只能局限于元素的背景颜色或者背景图片使用。还有一个属性mix-blend-mode，可以融合多个元素。不仅可以混合图片，还可以把元素的文本和边框与容器的背景图片混合在一起。 .blend { background-image: url(\"./bear.jpg\"); background-size: cover; background-position: center; padding: 5em 0 10em; } .blend \u003e h1 { margin: 0; font-family: Arial, Helvetica, sans-serif; font-size: 6rem; text-align: center; mix-blend-mode: hard-light; background-color: #c33; color: #808080; border: 0.1em solid #ccc; border-width: 0.1em 0; } ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:11:3","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r对比、颜色和间距","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:12:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r对比最重要对比是设计中的一种手段，通过突出某物来达到吸引注意力的目的。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:12:1","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r排版随着 Web 字体的兴起，使用@font-face规则，告诉浏览器去哪里找到并下载自定义字体，供页面使用。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:13:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r过渡Web 是个生动的媒介，可以做如元素淡出、菜单滑入、颜色从一种变成另一种，实现这些效果最简单的方式是过渡（Transitions）。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:14:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r从这边到那边过渡是通过一系列transition-*属性来实现的。如果某个元素设置了过渡，那么当它的属性值发生变化时，并不是直接变成新值，而是使用过渡效果。 先看一个示例，最开始是个蓝绿色方角按钮，鼠标悬停时，过渡成一个红色圆角按钮: \u003cbutton\u003eHover over me\u003c/button\u003e button { background-color: hsl(180, 50%, 20%); border: 0; color: white; font-size: 1rem; padding: 0.3em 1em; transition-property: all; transition-duration: 0.5s; } button:hover { background-color: hsl(0, 50%, 50%); border-radius: 1em; } transition-property属性可以指定哪些属性使用过渡。关键字all表示所有的属性变化都使用过渡。transition-duration属性代表过渡到最终值之前需要多长时间，本例是 0.5 秒。 也可以使用简写属性transition，该简写属性接受四个参数值，分别代表四个过渡属性transition-property、transition-duration、transition-timing-function和transition-delay。 第一个值设置了哪些属性需要过渡，初始值是关键字 all，表示所有属性都生效。如果只有某个属性需要过渡，在这里指定属性即可。例如: transition-property: color将只应用在元素的颜色上，其他属性会立刻发生变化。也可以设置多个值，比如: transition-property: color, font-size。 第二个值是持续时间，用秒或者毫秒表示。 第三个值是定时函数，用来控制属性的中间值如何计算，实际上控制的是过渡过程中变化率如何加速或者减速。定时函数可以是一个关键字值，比如linear或者ease-in，也可以是自定义函数。 最后一个值是延迟时间，允许开发者在属性值改变之后过渡生效之前设置一个等待周期。 如果需要为两个不同的属性分别设置不同的过渡，可以添加多个过渡规则，以逗号分隔: transition: border-radius 0.3s linear, background-color 0.6s ease; 等价于以下代码: transition-property: border-radius, background-color; transition-duration: 0.3s, 0.6s; transition-timing-function: linear, ease; ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:14:1","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r定时函数定时函数用来说明如何移动。是以恒定的速度移动？还是开始慢，后面快？ 我们可以用 linear、ease-in 和 ease-out 等关键字来描述移动过程。 linear 过渡，值以固定的速度改变；ease-in 过渡，变化速度开始时慢，然后一直加速，直到过渡完成；ease-out 是减速，开始时快速变化，结束时比较慢。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:14:2","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r变换","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:15:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r旋转、平移、缩放和倾斜基本的变换规则如下: transform: rotate(90deg); 这条规则应用到元素上后，会让元素向右（顺时针）旋转 90 度。变换函数rotate()用来指定元素如何变换。其他变换函数如下: 旋转（Rotate）: 元素围绕一个轴心转动一定角度 平移（Translate）: 元素上下左右各个方向移动 缩放（Scale）: 缩小或放大元素 倾斜（Skew）: 使元素变形，顶边滑向一个方向，底边滑向相反的方向 每种变换都使用相应的函数作为transform属性的值。使用变换的时候元素可能会被移动到页面上的新位置，但它不会脱离文档流。其初始位置不会被其他元素占用。 变换不能作用在 span 或 a 这样的行内元素上。若确实需要，要么改变元素的 display 属性，替换掉inline（比如inline-block），要么把元素改为弹性子元素或网格项目。 更改变换基点变换是围绕基点（Point of origin）发生的。基点是旋转的轴心，也是缩放或倾斜开始的地方。这意味着元素的基点是固定在某个位置上，元素的剩余部分围绕基点变换（translate 是个例外，因为平移过程中元素整体移动）。 默认情况下，基点就是元素的中心，可以通过transform-origin属性改变基点位置。 例如: transform-origin: right center; transform-origin: 100% 50%; 以上两句等价。 使用多重变换可以对transform属性指定多个值，用空格隔开。变换的每个值从右向左按顺序执行，例如: transform: rotate(15deg) translate(15px, 0)，元素会先向右平移 15px，然后顺时针旋转 15 度。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:15:1","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r在运动中变换变换本身不具备太多实用性。当和动作结合起来使用的时候，变换就会有用多了。 SVG——可缩放矢量图形（Scalable Vector Graphics）的简称。这是一种基于 XML 的图片格式，使用向量定义图片。由于图片是使用数学计算来定义的，所以可以放大或缩小到任意尺寸。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:15:2","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r动画关键帧（keyframe）是指动画过程中某个特定时刻。我们定义一些关键帧，浏览器负责填充或者插入这些关键帧之间的帧图像。 从原理上看，过渡和关键帧动画类似: 我们定义第一帧（起始点）和最后一帧（结束点），浏览器计算所有中间值，使得元素可以在这些值之间平滑变换。但使用关键帧动画，我们就不在局限于两个点，而是想加多少就加多少。浏览器负责填充一个个点与点之间的值，直到最后一个关键帧，最终生成一系列无缝衔接的过渡。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:16:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r关键帧CSS 中的动画包括两部分: 用来定义动画的@keyframes规则和为元素添加动画的animation属性。 先创建一个简单的动画来熟悉以下语法: @keyframes over-and-back { 0% { background-color: hsl(0, 50%, 50%); transform: translate(0); } 50% { transform: translate(50px); } 100% { background-color: hsl(270, 50%, 50%); transform: translate(0); } } .box { width: 100px; height: 100px; background-color: green; animation: over-and-back 1.5s linear 3; } \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003e动画\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"./style.css\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"box\"\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:16:1","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r选择器","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:17:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r基础选择器 tagname——标签选择器。该选择器匹配目标元素的标签名。其优先级是0,0,1。例如: p、h1、strong。 .class——类选择器。该选择器匹配 class 属性中有指定类名的元素。其优先级是0,1,0。例如: .media、.nav-menu。 #id——ID 选择器。该选择器匹配拥有指定 ID 属性的元素。其优先级是1,0,0。例如: #sidebar。 *——通用选择器。该选择器匹配所有元素。其优先级是0,0,0。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:17:1","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r组合器组合器将多个基础选择器连接起来组成一个复杂选择器。 后代组合器（空格）——匹配的目标元素的其他元素的后代。例如: .nav-menu li。 子组合器（\u003e）——匹配的目标元素紧跟在其他元素后面。例如: .parent \u003e .child。 相邻兄弟组合器（+）——匹配的目标元素紧跟在其他元素后面。例如: p + h1。 通用兄弟组合器（~）——匹配所有跟随在指定元素之后的兄弟元素。 多个基础选择器可以连起来（不使用空格或者其他组合器）组成一个复合选择器（例如: h1.page-header）。复合选择器选中的元素将匹配其全部基础选择器。例如，.dropdown.is-active能选中\u003cdiv class=\"dropdown is-active\"\u003e...\u003c/div\u003e，当无法选中\u003cdiv class=\"dropdown\"\u003e\u003c/div\u003e。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:17:2","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r伪类选择器伪类选择器用于选中某个特定状态的元素。这种状态可能是由于用户交互，也可能是由于元素相对于其父级或兄弟元素的位置。其优先级等于一个类选择器(0, 1, 0)。 :first-child——匹配的元素是其父元素的第一个子元素。 :last-child——匹配的元素是其父元素的最后一个子元素。 :only-child——匹配的元素是其父元素的唯一一个子元素（无兄弟元素）。 CSS Pseudo-classes: https://www.w3schools.com/css/css_pseudo_classes.asp ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:17:3","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r伪元素选择器伪元素匹配在文档中没有直接对应 HTML 元素的特定部分。伪元素选择器可能只匹配元素的一部分，甚至向 HTML 标记中未定义的地方插入内容。 此类选择器以双冒号开头，大多数浏览器也支持单冒号的语法以便向后兼容。伪元素选择器的优先级与元素选择器(0, 0, 1)相等。 ::before——创建一个伪元素，使其成为匹配元素的第一个子元素。该元素默认是行内元素，可用于插入文字、图片或其他形状。必须指定 content 属性才能让元素出现。例如: .menu::before。 ::after——创建一个伪元素，使其成为匹配元素的最后一个子元素。元素默认是行内元素，可用于插入文字、图片或其他形状。必须指定 content 属性才能让元素出现。例如: .menu::after。 ::first-letter——用于指定匹配元素的第一个文本字符的样式。例如: h2::first-letter。 ::first-line——用于指定匹配元素的第一行文本的样式。 ::selection——用于指定用户使用鼠标高亮选择的任意文本的样式。通常用于改变选中文本的background-color。只有少数属性可以用，包括color、background-color、cursor、text-decoration。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:17:4","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r属性选择器属性选择器用于根据 HTML 属性匹配元素。其优先级与一个类选择器(0,1,0)相等。 [attr]——匹配的元素拥有指定属性 attr，无论属性值是什么，例如: input[disabled]。 [attr=\"value\"]——匹配的元素拥有指定属性 attr，且属性值等于指定的字符串值，例如: input[type=\"radio\"]。 [attr^=\"value\"]——“开头”属性选择器。该选择器匹配的元素拥有指定属性 attr，且属性值的开头是指定的字符串值，例如: a[href^=\"https\"]。 [attr$=\"value\"]——“结尾”属性选择器。该选择器匹配的元素拥有指定属性 attr，且属性值的结尾是指定的字符串值，例如: a[href$=\".pdf\"]。 [attr*=\"value\"]——“包含”属性选择器。该选择器匹配的元素拥有指定属性 attr，且属性值包含指定的字符串值，例如: [class*=\"sprite-\"]。 [attr~=\"value\"]——“空格分隔的列表”属性选择器。该选择器匹配的元素拥有指定属性 attr，且属性值是一个空格分隔的值列表，列表中的某个值等于指定字符串值，例如: a[rel=\"author\"]。 [attr|=\"value\"]——匹配的元素拥有指定属性 attr，且属性值要么等于指定的字符串值，要么以该字符串开头且紧跟着一个连字符。例如: [lang|=\"es\"]。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:17:5","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r选择器速查表需要的话，可以收藏一下@Shefali__J的CSS Selectors Cheatsheet！ 高清图可在CheatSheets下载。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:17:6","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r预处理器预处理器的原理是把我们写的源文件转译成输出文件，即常规 CSS 样式表。对浏览器而言，最终输出的是常规 CSS，所以预处理器不会向语言添加任何新特性。但对于开发者来说，预处理器提供了许多便利。 比较流行的预处理器有 Sass 和 Less。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:18:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\rSass\r搭建环境使用npm init -y初始化一个新的 npm 项目。 使用npm install --save-dev node-sass安装node-sass包。 Sass 支持两种语法: Sass 和 SCSS。它们的语言特性一样，但 Sass 语法去掉了所有的大括号和分号，严格使用缩进来表示代码结构。SCSS 语法使用大括号和分号，因此看起来更像 CSS。 在项目目录下新建 sass 和 build 子目录，我们把源文件放在 sass 目录，生成的 CSS 文件将在 build 目录中。 在package.json中添加一条命令: \"scripts\": { \"sass\": \"node-sass sass/index.scss build/styles.css\" }, 之后运行npm run sass，可以看到在 build 目录中生成了 styles.css 文件。 理解 Sass 的核心特性\r变量在 Sass 中可以使用变量，在index.scss中添加如下代码: // 定义变量 $brand-blue: #0086b3; a:link { // 使用变量 color: $brand-blue; } body { font-family: Arial, Helvetica, sans-serif; color: black; } .page-heading { font-size: 1.6rem; // 使用变量 color: $brand-blue; } 运行npm run sass命令，输出文件build/styles.css内容如下: a:link { color: #0086b3; } body { font-family: Arial, Helvetica, sans-serif; color: black; } .page-heading { font-size: 1.6rem; color: #0086b3; } 变量已经被替换为了十六进制颜色值，浏览器可以直接加载。 行内计算Sass 支持使用+、-、*、/和%（模运算）进行行内计算，如此一来，我们就可以从一个初始值获得多个值。 $padding-left: 3em; .note-author { padding-left: $padding-left; font-weight: bold; } .note-body { padding-left: $padding-left * 2; } 使用npm run sass编译后生成如下结果: .note-author { padding-left: 3em; font-weight: bold; } .note-body { padding-left: 6em; } .note-body中的padding-left属性成功计算得到。 嵌套选择器Sass 允许在代码块内嵌套选择器，可以使用嵌套把有关联的代码分到一组: .site-nav { display: flex; \u003e li { margin-top: 0; // \u0026符号表示将插入外层选择器的位置 \u0026.is-active { display: block; } } } 编译如下: .site-nav { display: flex; } .site-nav \u003e li { margin-top: 0; } .site-nav \u003e li.is-active { display: block; } 默认情况下，外层的.site-nav选择器会自动添加到编译代码的每个选择器前面，拼接的位置会插入一个空格。使用\u0026符号代表外层选择器要插入的位置。 也可以在声明块内嵌套媒体查询用以避免重复书写相同选择器: html { font-size: 1rem; @media (min-width: 45em) { font-size: 1.25rem; } } 编译结果如下: html { font-size: 1rem; } @media (min-width: 45em) { html { font-size: 1.25rem; } } 这样一来，若修改选择器就不必再去媒体查询中修改对应的选择器。 局部文件(@import)局部文件允许我们将样式分割成多个独立的文件，Sass 将会把这些文件拼接在一起生成一个文件。 新建sass/button.scss文件，添加如下内容: .button { padding: 1em 1.25em; background-color: #265559; color: #333; } 在sass/index.scss文件中引入: @import \"button\"; html { font-family: Arial, Helvetica, sans-serif; } 编译结果如下: .button { padding: 1em 1.25em; background-color: #265559; color: #333; } html { font-family: Arial, Helvetica, sans-serif; } 局部文件会被编译，然后插入到@import规则指定的地方。 混入混入（mixin）是一小段 CSS 代码块，可以在样式表任意地方复用。如果有一段特定的字体样式在多个地方需要使用，使用混入就比较合适。 混入用@mixin规则来定义，用@include规则来调用。 清除浮动: @mixin clearfix { \u0026::before { display: table; content: \" \"; } \u0026::after { clear: both; } } .media { @include clearfix; background-color: #eee; } 预处理器会提取 mixin 中的代码，替换到@include规则所在位置。 .media { background-color: #eee; } .media::before { display: table; content: \" \"; } .media::after { clear: both; } 需要注意的是，最终编译生成的代码中没有了 clearfix。混入的内容只会添加到样式表中用到了它的地方。 我们还可以定义带参数的混入: @mixin alert-variant($color, $bg-color) { padding: 0.3em 0.5em; border: 1px solid $color; color: $color; background-color: $bg-color; } .alert-info { @include alert-variant(blue, lightblue); } .alert-danger { @include alert-variant(red, pink); } 每次调用混入，都可以传递不同的值。这些值指定为对应的两个变量，最终输出的 CSS 如下: .alert-info { padding: 0.3em 0.5em; border: 1px solid blue; color: blue; background-color: lightblue; } .alert-danger { padding: 0.3em 0.5em; border: 1px solid red; color: red; background-color: pink; } 扩展Sass 还支持@extend规则。和 mixin 类似，但编译方式有所不同。对于扩展，Sass 不会多次复制相同的声明，而是把选择器组合在一起，这样它们就会包含同样的规则。 .message { padding: 0.3em 0.5em; border-radius: 0.5em; } .message-info { @extend .message; color: blue; background-color: lightblue; } .message-danger { @extend .message; color: red; background-color: pink; } .message包含的规则被扩展到另外两个规则集中。 .message, .message-info, .message-danger { padding: 0.3em 0.5em; border-radius: 0.5em; } .message-info { color: blue; background-color: lightblue; } .message-danger { color: red; background-color: pink; } 使用mixin还是extend，需要具体情况具体分析。通常情况下，可能更倾向用mixin，只有需要减少 HTML 中填写的类名数量时才考虑使用@extend。 颜色处理Sass 还有一个特性就是颜色处理函数，如果需要两个同类的颜色（比如，同一种颜色的深浅版本），可以用如下代码来生成: $green: #63a53c; // 加深10% $green-dark: darken($green, 10%); $green-light: lighten($green, 10%); // 调整透明度 $green-transparent: rgba($green, 0.5); 通过这些函数，可以实现修改一个变量，同时修改相关联的其他颜色值。这样就","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:18:1","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\rPostCSSPostCSS 是另一种类型的预处理器。它编译源文件并输出一个处理过的 CSS 文件，这和 Sass 或者 Less 一样，但 PostCSS 是依靠插件工作的。若没有安装插件，输出文件就是没有任何变化的源文件副本。 搭建环境使用npm init -y初始化一个新的 npm 项目。 使用npm install --save-dev gulp安装gulp包。 AutoprefixerPostCSS 中最重要的插件可能就是 Autoprefixer，这个插件可以将相关的所有浏览器前缀都添加到 CSS 中。 为了使用Autoprefixer，我们使用命令npm install --save-dev gulp-atuoprefixer进行安装。 之后在项目根目录创建一个名为gulpfile.js的文件，添加如下内容: const gulp = require(\"gulp\"); const autoprefixer = require(\"gulp-autoprefixer\"); gulp.task(\"prefix\", () =\u003e { gulp .src(\"./css/*.css\") .pipe( autoprefixer({ cascade: false, }) ) .pipe(gulp.dest(\"./dist\")); }); 新建css目录，在其中的index.css文件中添加如下内容: .fullscreen a { display: flex; } 在package.json文件中加入以下内容: \"scripts\": { \"gulp\": \"gulp prefix\" }, \"browserslist\": [ \"last 99 versions\" ], 打开命令行执行npm run gulp。可以看到生成了一个新目录dist，其中有一个名为index.css的文件，内容如下: .fullscreen a { display: -webkit-box; display: -webkit-flex; display: -moz-box; display: -ms-flexbox; display: flex; } cssnextcssnext 是另一款非常流行的 PostCSS 插件。这款插件模拟那些还没有受所有浏览器支持的最新 CSS 语法。 cssnanocssnano 是基于 PostCSS 的压缩工具。可以从代码中剥离无关的空格，使代码体积尽可能变小，但同时依然保持相同的语法含义。 PreCSSPreCSS 是一款 PostCSS 插件包，提供了类似于 Sass 的特性，其中包含了$变量、行内计算、循环和混入等。 更多 PostCSS 插件，请看PostCSS Plugins。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:18:2","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r项目要想完全掌握书上内容还得不断练习回顾，以下为推荐练习项目。 Parallax scroll animation: https://codepen.io/isladjan/pen/abdyPBw Voyage Slider | GSAP: https://codepen.io/dev_loop/pen/MWKbJmO App Menu With Lock Screen: https://codepen.io/Hyperplexed/details/vYpXNJd Old Film Effect - Pure CSS Animation: https://codepen.io/josetxu/pen/yLjwOwQ How I recreated a Polaroid camera with CSS gradients only ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:19:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["细读经典"],"content":"\r参考《深入解析 CSS》 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:20:0","tags":["CSS","Web设计","前端开发","网页布局","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["JavaScript"],"content":"在用 JavaScript 编程时，我们会经常用到数组对象，本文我们就来盘点一下那些好用的数组方法吧！😁 为了方便演示，我们先创建两个数组： const a = ['JavaScript', 'Php', 'Python', 'Ruby', 'C++', 'Node.js', 'Java', 'C++']; const b = [1, 3, 8, 16, 32, 48, 5]; ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:0:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\revery()首先，我们想知道数组a中的所有元素长度都是大于 4 的吗？对于这个数组的而言，结果是显然的。我们可以用如下的for循环得到问题的答案， let result = true; for (let i = 0; i \u003c a.length; i++\u003e){ if (a[i].length \u003c= 4){ result = false; break } } console.log(result); 结果如下： 但用for循环的方式多少显得有些麻烦，我们可以更加简洁地得到结果，那就是使用every()方法。 a.every(word =\u003e word.length \u003e 4); 通过传入一个箭头函数，就将问题解决啦，而且代码变得简洁清晰多了 😉。 ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:1:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rsome()接下来，我们想知道数组b中是否有大于 10 的元素呢？看起来这问题似乎有点傻，但…… 如果数组b中有 1 万个元素呢？ 我们同样可以使用for循环得到问题的答案： let result = false; for (let i = 0; i \u003c b.length; i++){ if (b[i] \u003e 10){ result = true; break; } } console.log(result); 我们还可以用some()方法， b.some(elem =\u003e elem \u003e 10); 如上所示，我们总是可以通过every()方法检测数组中所有元素都满足某种要求，而通过some()方法检测数组中是否有某个元素满足某种要求。 ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:2:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rfilter()我们已经知道数组a中并不是所有元素的长度都是大于 4 的，那么具体是哪些元素的长度大于 4 呢？有没有什么办法可以把它们都找到呢？ 老规矩，我们依旧可以用for循环。 let words = []; for (let i = 0; i \u003c a.length; i++){ if (a[i].length \u003e 4){ words.push(a[i]); } } console.log(words); 但我们还是推荐更加简短的filter()方法， a.filter(word =\u003e word.length \u003e 4); 结果如下： ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:3:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rmap()接下来，我们来做另外一件事，那就是给数组a中的每个元素后追加一个字符串“ is awesome!”，我们可以怎么做呢？——用map()方法。 a.map(word =\u003e word + \" is awesome!\"); ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:4:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rforEach()如果我们想将数组a中长度大于 4 的元素每每追加一个字符串“ is awesome!”并依次打印输出怎么做？ 首先我们可以用filter()方法进行筛选，然后用map()方法进行追加，最后用forEach()方法进行迭代打印输出。 a.filter(word =\u003e word.length \u003e 4).map(word =\u003e word + \" is awesome!\").forEach(word =\u003e console.log(word)); 现在你可能发现了map()和filter()方法返回一个数组的好处了吧！😋 ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:5:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rreduce()如果想将数组b进行求和运算该怎么做呢？——用reduce()方法。 reduce()方法的原型如下： array.reduce(reducer [, initialValue]) reducer为一个回调函数，以及可选初始化参数initialValue。reduce()方法会在每个数组元素上调用reducer()函数，reducer()函数返回一个累积的值，这个值在下一次调用reducer()函数时作为参数传入。 reducer()函数的原型如下： function reducer(accumulator, currentValue, currentIndex, array){} 回到给数组b进行求和的问题，代码如下： b.reduce((accu, curr) =\u003e accu + curr); ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:6:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rincludes()假如我们想知道数组中是否包含某个元素怎么整？比如，数组a包含Julia吗？ 当然，我们可以用之前学到过的some()方法， a.some(word =\u003e word === 'Julia'); 但还是推荐使用includes()方法： a.includes('Julia'); 无它，简明而已！ ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:7:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rfind()filter()可以帮我们找到数组b中所有大于 8 的元素，但有时候我们要的不是所有，而是第一个。此时我们可以用find()方法。 b.find(elem =\u003e elem \u003e 8); ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:8:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rfindIndex()如果你对第一个元素（详见find()方法）不感兴趣，而是迫切想知道满足某条件的第一个元素的下标，那么可以用findIndex()方法。 b.findIndex(elem =\u003e elem \u003e 8); ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:9:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\r总结本文介绍了 9 个能让我们代码更加简洁的数组方法，分别是every()，some()，filter()，map()，forEach()，reduce()，includes()，find()和findIndex()，希望能让给你带来一点启发。 ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:10:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\r推荐最后，推荐几个网站！ JavaScript Tutorial: https://www.javascripttutorial.net/ MDN Web Docs: https://developer.mozilla.org/en-US/ 感兴趣的同学可以去瞅瞅 😍。 ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:11:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\r参考https://www.w3schools.com/jsref/jsref_obj_array.asp ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:12:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"Axios是一个基于 Promise 的 HTTP 客户端，我们可以在浏览器和 Node.js 中使用它。Axios 使向 REST 端点发送异步 HTTP 请求和执行 CRUD 操作变得更加容易。它可以在纯 JavaScript 中使用，也可以在 Vue 或者 React 之类的库中使用。 先看一个在浏览器中使用 Axios 的例子，我们发送一个请求到https://api.github.com/users/USERNAME，以获取到用户的一些信息。 新建一个名为 1.html 的文件，代码如下： \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e\u003c/head\u003e \u003ctitle\u003eAxios\u003c/title\u003e \u003cbody\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"main.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e main.js 代码如下： axios.get(\"https://api.github.com/users/andyfree96\").then(response =\u003e { console.log(response.data); }).catch(error =\u003e { console.log(\"ERROR!\"); }); 启动服务器， 如果您没有安装http-server的话，请自行安装一下。 打开浏览器，就可以看到： 成功获取到用户信息。 之后的教程将在 Node.js 中使用 Axios，而不是在浏览器。 ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:0:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\r安装 Axios本文使用的 Node.js 版本是： 初始化一个 Node.js 应用， npm init -y 在命令行中输入npm i axios安装即可。 ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:1:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\rAxios 的响应对象当我们发送一个请求给服务器后，它会返回一个响应。Axios 的响应对象包含如下内容： data - 服务器返回的响应主体数据 status - 服务器返回的响应状态码 statusText - 返回的状态信息 headers - 返回的头部信息 config - 请求的配置信息 request - 请求对象 ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:2:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\rAxios 的 GET 请求我们以回调函数或者 async/await 的方式发送 Get 请求。 回调函数： const axios = require(\"axios\"); axios.get(\"https://api.github.com/users/andyfree96\").then((response) =\u003e { console.log(response.status); console.log(response.statusText); console.log(response.data); }); 结果如下： async/await： const axios = require(\"axios\"); async function makeGetRequest() { let response = await axios.get(\"https://httpbin.org/get\"); let data = response.data; console.log(data); console.log(response.request._header); } makeGetRequest(); 结果如下： ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:3:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\rAxios 的 HEAD 请求HEAD 请求是一个没有消息体的 GET 请求。 const axios = require(\"axios\"); async function makeHeadRequest() { let response = await axios.head(\"http://www.baidu.com\"); console.log(`status: ${response.status}`); console.log(`server : ${response.headers.server}`); console.log(response.headers); } makeHeadRequest(); Axios 有两个基本的 API： axios(config) axios(url, config) const axios = require(\"axios\"); async function makeRequest() { const config = { method: \"get\", }; const url = \"http://httpbin.org/get\"; let response = await axios(url, config); console.log(response.data); } makeRequest(); ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:4:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\rAxios 自定义头部 const axios = require(\"axios\"); async function makeRequest() { const config = { method: \"get\", url: \"http://www.baidu.com\", headers: { \"User-Agent\": \"5.js\" }, }; let response = await axios(config); console.log(response.request._header); } makeRequest(); 这里我们自定义了一个请求头部： const config = { method: \"get\", url: \"http://www.baidu.com\", headers: { \"User-Agent\": \"5.js\" }, }; ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:5:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\rAxios 的 POST 请求 const axios = require(\"axios\"); async function makePostRequest() { let response = await axios.post(\"https://httpbin.org/post\"); console.log(response.data); } makePostRequest(); ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:6:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\r下载图片 const axios = require(\"axios\"); const fs = require(\"fs\"); async function getImage(url) { const config = { responseType: \"stream\", }; let response = await axios.get(url, config); response.data.pipe(fs.createWriteStream(\"./image.png\")); } getImage( \"https://himg.bdimg.com/sys/portraitn/item/856f6c656f73636f74743936f939\" ); 我们在 config 对象中指明返回类型。 ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:7:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\r多个请求我们可以用 Axios 一次性创建多个请求。 const axios = require(\"axios\"); async function makeRequests() { let [response1, response2] = await Promise.all([ axios.get(\"https://api.github.com/users/andyfree96\"), axios.get(\"https://api.github.com/users/google\"), ]); console.log(response1.data.created_at); console.log(response2.data.created_at); } makeRequests(); ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:8:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\rJSON ServerJSON Server 是一个很棒的工具，可以让我们轻松地伪造 REST API。 我们先安装json-server: npm i -g json-server 创建一个名为 employees.json 的文件，添加如下内容： { \"employees\": [ { \"id\": 1, \"first_name\": \"Sebastian\", \"last_name\": \"Eschweiler\", \"email\": \"sebastian@codingthesmartway.com\" }, { \"id\": 2, \"first_name\": \"Steve\", \"last_name\": \"Palmer\", \"email\": \"steve@codingthesmartway.com\" }, { \"id\": 3, \"first_name\": \"Ann\", \"last_name\": \"Smith\", \"email\": \"ann@codingthesmartway.com\" } ] } 关于 JSON Server 创建 REST API 可以看下文。 Create A REST API With JSON Server: https://medium.com/codingthesmartway-com-blog/create-a-rest-api-with-json-server-36da8680136d 接下来我们可以启动 JSON Server， json-server --watch employees.json 访问http://localhost:3000/employees可以看到： 接下来我们可以使用 Axios 添加员工， const axios = require(\"axios\"); async function makePostRequest() { const params = { id: 4, first_name: \"Andy\", last_name: \"Scott\", email: \"andyfree96@126.com\", }; let response = await axios.post(\"http://localhost:3000/employees/\", params); console.log(response.data); } makePostRequest(); 获取员工, const axios = require(\"axios\"); async function makeRequest() { let response = await axios.get(\"http://localhost:3000/employees\"); console.log(response.data); } makeRequest(); 删除员工, const axios = require(\"axios\"); async function makeDeleteRequest() { let response = axios.delete(\"http://localhost:3000/employees/4/\"); console.log(response.data); } makeDeleteRequest(); ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:9:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\r参考Axios tutorial: http://zetcode.com/javascript/axios/ ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:10:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["命令行"],"content":" 2024/11/12 更新: 推荐增加CLI tools you won’t be able to live without 🔧和40 个超有趣的 Linux 命令行彩蛋和游戏 在现代操作系统中，图形用户界面 (GUI) 让我们与计算机的交互变得直观和简单。然而，对于许多开发者、系统管理员和技术爱好者而言，Linux 命令行仍然是最为强大且不可替代的工具。通过它，我们能够精准地控制系统资源、自动化复杂任务，并快速处理各种系统操作。与 GUI 不同，命令行的操作不依赖于鼠标或其他外部设备，只需键入一行命令，便可在数秒内完成从文件管理到网络配置、从进程控制到系统监控等一系列操作。正因为其高效、灵活和可扩展性，Linux 命令行成为了技术专家首选的工作方式之一。本文，我们将逐步探索 Linux 命令行的基础知识，了解一些常用的命令，以及如何利用这些命令高效管理系统。无论你是新手还是经验丰富的用户，掌握这些命令都会让你在 Linux 世界中如鱼得水。 ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:0:0","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r1. 文件管理","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:1:0","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\rfind\r语法 find [-H] [-L] [-P] [-Olevel] [-D debugopts] [path...] [expression] 列出当前目录使用不带参数和选项的find会列出当前目录下的所有文件及目录： find 搜索特定目录通过指定目录可以让find命令特定目录。 find ~/work 在指定目录中搜索特定文件有时，我们会想在某个指定目录下搜索特定文件名，例如： sudo find /etc -name \"ssh_config\" 模糊搜索如果想搜索系统中所有以.config为文件名结尾的文件的话，我们可以使用*通配符进行模糊搜索。 sudo find / -name \"*.config\" 指定搜索深度通过-maxdepth和-mindepth选项可以分别指定搜索时的最大和最小深度。 sudo find / -maxdepth 2 -name \"*.config\" 或操作符通过使用或操作符可以组合搜索结果，该操作符如下例中所示，用-o或-or选项表示。 sudo find / -maxdepth 2 -name \"*.config\" -o -name \"ssh\" 指定搜索类型通过-type选项，我们可以指定搜索文件类型，例如-type f搜索文件，-type d搜索目录： 指定搜索文件大小通过-size选项，我们可以指定搜索文件大小。比如，-size 10k表示搜索大小为10k的文件，-size +10k表示搜索大小超过10k的文件，-size -10k表示搜索大小少于10k的文件。 https://man7.org/linux/man-pages/man1/find.1.html ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:1:1","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r2. 文档编辑","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:2:0","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\rgrepgrep 是Global Regular Expression Print 的缩写，用于在指定文件中搜索字符串，它会打印匹配到的行。 语法使用语法如下： grep [OPTION]... PATTERN [FILE]... PATTERN表示搜索模式。 单个文件搜索 如果我们想在log1文件中搜索andy这个模式，可以使用如下命令： grep andy log1 多个文件搜索若想在多个文件进行模式搜索，可以使用如下命令： grep andy log1 log2 搜索整个目录work目录中只有两个文件，如果有成百上千个文件，显然不能上例一样指明目录下所有的文件名，此时我们可以使用*通配符来搜索整个当前目录： grep andy * 按单词搜索以上的例子没有把andy当作整个单词搜索，只要单词中匹配到andy这部分就会被搜索到。若想按单词搜索，使用-w选项即可。 grep -w andy * 忽略大小写使用-i选项可以让grep命令忽略大小写对模式进行搜索。 grep -iw andy * 反转搜索若想查看没有匹配到的行，我们可以使用-v选项： grep -iwv andy * 按行搜索通过-x选项可以让grep按行进行搜索： grep -xi andy * 搜索子目录目录中可能包含子目录，若想进一步在子目录进行搜索，可以使用-r选项： grep -rwi andy * 统计匹配数通过使用-c选项可以统计每个文件的匹配数。 grep -ci andy * https://man7.org/linux/man-pages/man1/grep.1.html How To Use grep Command In Linux/UNIX: https://phoenixnap.com/kb/grep-command-linux-unix-examples ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:2:1","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r3. 文件传输","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:3:0","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r4. 磁盘管理","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:4:0","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r5. 磁盘维护","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:5:0","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r6. 网络通讯","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:6:0","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\rcurlcurl是一个用于与远端服务器进行信息交换的命令行工具。通过curl命令，可以十分方便地上传或者下载数据。本文我们将介绍如何在 Ubuntu 18.04.4 LTS 上使用curl命令。 安装在终端中输入： sudo apt update sudo apt install curl 即可安装。 语法curl命令的语法如下： curl [options...] \u003curl\u003e \u003curl\u003e表示 URL 是必须的，而[options...]表示选项可以有多个或者零个。如果不带任何选项，对应 URL 的资源数据会在标准输出设备中输出。例如： curl http://www.baidu.com 如上所示，百度主页的源代码正常在屏幕上打印输出了。 保存输出至文件通常我们需要将请求的数据保存到文件中，此时可以使用-O或者-o选项。 curl -O https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js -O选项会使用远端服务器上的文件名作为保存到本地文本的文本名。如不希望这样的话，可以-o选项自定义本地文件的文件名。 curl -o andy.js https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js 下载多个文件有时，我们会需要多个文件，除了不断运行curl -O url1，curl -O url2……命令外，我们也可以使用如下方式： curl -O https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js -O https://cdn.jsdelivr.net/npm/async@3.2.0/dist/async.min.js 设置请求 User-Agent 字段HTTP 请求报文中有一个 User-Agent 头部字段，我们可以通过使用-A选项对其进行设置： curl -A \"andyfree\" 获取 HTTP 响应头通过-I选项，我们可以获取到 HTTP 响应报文的头部信息。 curl -I https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js 使用代理为了能顺利访问到资源，有时我们需要用到代理，使用-x选项即可： curl -x 127.0.0.1:8100 http://httpbin.org/ip 恢复下载在下载大文件时，由于持续时间会比较长，网络可能会因为某些原因断开，此时我们可以用-C选项恢复下载而不用从头下载。 curl -C - -O https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/20.10/ubuntu-20.10-desktop-amd64.iso https://curl.se/docs/manual.html ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:6:1","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r7. 系统管理","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:7:0","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\rpsps命令是进程状态（Process Status）的缩写，能显示 Linux 系统当前运行进程的相关信息。 语法ps命令的语法如下： ps [options] 当前 shell 运行的进程不带任何选项的ps命令会显示当前 shell 运行的进程： ps PID指的是进程号 TTY指的是用户登录的终端类型 TIME指的是进程运行的时间 CMD指的是启动进程的命令 列出所有进程使用-A或-e选项可以列出所有进程： ps -A ps -e 列出与特定用户相关的进程如果想列出与特定用户相关的进程，可以使用-u选项。 ps -u user 例如： ps -u ubuntu 显示所选列通过-o选项后指定的参数可以选择想要显示的列。 搜索进程配合grep命令，我们可以十分方便的对进程进行搜索。 ps -ef | grep python https://man7.org/linux/man-pages/man1/ps.1.html https://www.journaldev.com/24613/linux-ps-command https://www.geeksforgeeks.org/ps-command-in-linux-with-examples/ ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:7:1","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\runame本节我们将介绍uname命令，该命令非常实用，可以打印输出系统相关信息。 语法 uname [OPTION]... 可选选项如下： -s, (--kernel-name)：打印输出内核名称 -n, (--nodename)：打印输出主机名（在网络中使用），此时输出和hostname命令一样 -r, (--kernel-release)：打印输出内核版本 -v, (--kernel-version)：打印输出内核版本和构建时间 -m, (--machine)：打印输出机器硬件名称 -p, (--processor)：打印输出处理器架构 -i, (--hardware-platform)：打印输出硬件平台 -o, (--operating-system)：打印输出操作系统名称 -a, (--all)：和-snrvmpio打印输出信息一样 uname命令不带任何选项时，打印输出内核名称，和uname -s一样： 为了方便使用，我们可以通常使用-a选项： 其中： Linux为内核名称 andyfree-ubuntu为主机名 4.15.0-88-generic为内核版本 ##88-Ubuntu SMP Tue Feb 11 20:11:34 UTC 2020为内核版本和构建时间 三个x86_64分别为硬件名称、处理器架构和硬件平台 GNU/Linux为操作系统名称 更改主机名如上图所示，本文所使用的机器的主机名为andyfree-ubuntu，我们可以使用hostnamectl命令自行更改主机名，例如：将主机名改为lucas： sudo hostnamectl set-hostname lucas ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:7:2","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r8. 系统设置","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:8:0","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r9. 备份压缩","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:9:0","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r10. 设备管理","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:10:0","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r推荐快乐的 Linux 命令行: https://billie66.github.io/TLCL/ the-art-of-command-line: Master the command line, in one page Linux Commands Cheat Sheet CLI tools you won’t be able to live without 🔧 40 个超有趣的 Linux 命令行彩蛋和游戏 ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:11:0","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r参考linux 命令分类: https://linux265.com/course/linux-commands.html Linux 命令大全: https://www.runoob.com/linux/linux-command-manual.html ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:12:0","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["网络爬虫"],"content":"BeautifulSoup是啥？它是一个可以从 HTML 或 XML 文件中提取数据的 Python 库。它能通过我们喜欢的转换器实现文档导航，查找和修改。 ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:0:0","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r安装 BeautifulSoup可以通过pip来安装，包的名字的是beautifulsoup4。 pip install -i https://pypi.douban.com/simple beautifulsoup4 ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:1:0","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r安装解析器BeautifulSoup除了支持 Python 标准库中的 HTML 解析器之外，还支持一些第三方的解析器，比如lxml。可以按下列方式来安装 lxml： pip install -i https://pypi.douban.com/simple lxml 另一个可供选择的解析器是纯 Python 实现的html5lib，可以按下列方式来安装 html5lib： pip install -i https://pypi.douban.com/simple html5lib 下表列出了主要的解析器以及它们的优缺点： ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:2:0","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r如何使用将一段文档传入BeautifulSoup的构造方法就能得到一个文档对象，可以传入一段字符串或一个文件句柄。 from bs4 import BeautifulSoup soup = BeautifulSoup(open(\"index.html\")) suop = BeautifulSoup(\"\u003chtml\u003edata\u003c/html\u003e\") 如果手动指定解析器的话，BeautifulSoup会选择指定的解析器来解析文档。 ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:3:0","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r对象的种类BeautifulSoup将复杂的 HTML 文档转换成一个复杂的树形结构，每个节点都是 Python 对象，所有对象可以归纳为 4 中：Tag，NavigableString，BeautifulSoup，Comment。 ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:4:0","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\rTagTag对象与 XML 或 HTML 文档中的 tag 相同： from bs4 import BeautifulSoup soup = BeautifulSoup('\u003cb class=\"boldest\"\u003eExtremely bold\u003c/b\u003e') tag = soup.b type(tag) # \u003cclass 'bs4.element.Tag'\u003e Tag有很多方法和属性，比如遍历文档树和搜索文档树。现在介绍一下 tag 中最重要的属性：name和attributes。 Name每个 tag 都有自己的名字，通过.name来获取： tag.name # 'b' 如果改变 tag 的 name 将会影响所有通过当前BeautifulSoup对象生成的 HTML 文档： tag.name = \"blockquote\" tag # \u003cblockquote class=\"boldest\"\u003eExtremely bold\u003c/blockquote\u003e tag.name = \"ironman\" tag # \u003cironman class=\"boldest\"\u003eExtremely bold\u003c/ironman\u003e Attributes一个 tag 可能有很多个属性。tag \u003cb class=\"boldest\"\u003e有一个名为class的属性，值为boldest。tag 的属性的操作方法与字典相同： tag['class'] # ['boldest'] 也可以直接.取属性，比如：.attrs： tag.attrs # {'class': ['boldest']} tag 的属性可以被添加，删除或修改，和字典一样。 In [13]: tag['class'] Out[13]: ['boldest'] In [14]: tag['class'] = 'verybold' In [15]: tag['id'] = 1 In [16]: tag Out[16]: \u003cironman class=\"verybold\" id=\"1\"\u003eExtremely bold\u003c/ironman\u003e In [17]: del tag['class'] In [18]: del tag['id'] In [19]: tag Out[19]: \u003cironman\u003eExtremely bold\u003c/ironman\u003e In [20]: tag['class'] KeyError In [21]: tag.get('class') 多值属性HTML 定义了一系列可以包含多个值的属性。最常见的多值属性是class（一个 tag 可以有多个 CSS 的class）。在BeautifulSoup中多值属性的返回类型是 list： In [22]: css_soup = BeautifulSoup('\u003cp class=\"body strikeout\"\u003e\u003c/p\u003e') In [23]: css_soup.p['class'] Out[23]: ['body', 'strikeout'] 如果某个属性看起来好像有多个值，但在任何版本的 HTML 定义中都没有被定义为多值属性，那么BeautifulSoup会将这个属性作为字符串返回 In [25]: id_soup = BeautifulSoup('\u003cp id=\"my id\"\u003e\u003c/p\u003e') In [26]: id_soup.p['id'] Out[26]: 'my id' ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:4:1","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\rNavigableString字符串常被包含在 tag 内。BeautifulSoup用NavigableString类来包装 tag 中的字符串： In [27]: tag Out[27]: \u003cironman\u003eExtremely bold\u003c/ironman\u003e In [28]: tag.string Out[28]: 'Extremely bold' In [29]: type(tag.string) Out[29]: bs4.element.NavigableString NavigableString 对象支持遍历文档树和搜索文档树中定义的大部分属性, 并非全部。 ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:4:2","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\rBeautifulSoupBeautifulSoup对象表示的是整个文档的内容。大部分时候，可以把它当作Tag对象，它支持遍历文档树和搜索文档树中定义的大部分方法。 ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:4:3","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\rCommentTag，NavigableString，BeautifulSoup几乎覆盖了 html 和 xml 中的所有内容，但是还有一些特殊对象。 In [30]: markup = \"\u003cb\u003e\u003c!--Hey, buddy. Want to buy a used parser?--\u003e\u003c/b\u003e\" In [31]: soup = BeautifulSoup(markup, 'lxml') In [32]: comment = soup.b.string In [34]: type(comment) Out[34]: bs4.element.Comment Comment对象是一个特殊类型的NavigableString对象。 soup = BeautifulSoup(markup, 'lxml')中的lxml用于指定解析器。 ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:4:4","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r搜索文档树BeautifulSoup定义了很多搜索方法，这里着重介绍 2 个：find_all()和select()。 以“爱丽丝”文档作为例子： In [40]: html_doc = \"\"\" ...: \u003chtml\u003e\u003chead\u003e\u003ctitle\u003eThe Dormouse's story\u003c/title\u003e\u003c/head\u003e ...: ...: \u003cp class=\"title\"\u003e\u003cb\u003eThe Dormouse's story\u003c/b\u003e\u003c/p\u003e ...: ...: \u003cp class=\"story\"\u003eOnce upon a time there were three little sisters; and their names were ...: \u003ca href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"\u003eElsie\u003c/a\u003e, ...: \u003ca href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"\u003eLacie\u003c/a\u003e and ...: \u003ca href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"\u003eTillie\u003c/a\u003e; ...: and they lived at the bottom of a well.\u003c/p\u003e ...: ...: \u003cp class=\"story\"\u003e...\u003c/p\u003e ...: \"\"\" In [41]: from bs4 import BeautifulSoup In [42]: soup = BeautifulSoup(html_doc, 'lxml') 使用find_all()类似的方法可以查找到想要查找的文档内容。 ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:5:0","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r过滤器在介绍find_all()方法之前，先介绍一下过滤器的类型，这些过滤器贯穿整个搜索的 API。过滤器可以被用在 tag 的 name 中，节点的属性中，字符串中或它们的混合中。 字符串最简单的过滤器是字符串。在搜索方法中传入也给字符串参数，BeautifulSoup会查找与字符串完整匹配的内容，下面的例子用于查找文档中所有\u003cb\u003e标签： In [43]: soup.find_all('b') Out[43]: [\u003cb\u003eThe Dormouse's story\u003c/b\u003e] 正则表达式如果传入正则表达式作为参数，BeautifulSoup会通过正则表达式的match()来匹配内容。下例中找出所有以 b 开头的标签，这意味着\u003cbody\u003e和\u003cb\u003e标签都应该被找到： In [44]: import re In [45]: for tag in soup.find_all(re.compile('^b')): ...: print(tag.name) ...: # body # b 列表如果传入列表参数BeautifulSoup会将领与列表中任一元素匹配的内容返回。下列代码将会找到文档中所有\u003ca\u003e和\u003cb\u003e标签： In [46]: soup.find_all(['a','b']) Out[46]: [\u003cb\u003eThe Dormouse's story\u003c/b\u003e, \u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] TrueTrue可以匹配任何值，以下代码查找到所有的 tag，但不会返回字符串节点： In [47]: for tag in soup.find_all(True): ...: print(tag.name) ...: # html # head # title # body # p # b # p # a # a # a p 方法如果没有合适的过滤器，还可以定义一个方法，方法只接受一个元素参数，如果这个方法返回True表示当前元素匹配并且被找到，若不是则返回False。 下列方法检验了当前元素，如果包含class属性却不包含id属性则返回True： def has_class_but_no_id(tag): return tag.has_attr('class') and not tag.has_attr('id') 将该方法作为参数传入find_all()方法将得到所有\u003cp\u003e标签： In [66]: soup.find_all(has_class_but_no_id) Out[66]: [\u003cp class=\"title\"\u003e\u003cb\u003eThe Dormouse's story\u003c/b\u003e\u003c/p\u003e, \u003cp class=\"story\"\u003eOnce upon a time there were three little sisters; and their names were \u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e and \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e; and they lived at the bottom of a well.\u003c/p\u003e, \u003cp class=\"story\"\u003e...\u003c/p\u003e] 返回结果中只有\u003cp\u003e标签没有\u003ca\u003e标签，因为\u003ca\u003e标签还定义了id，没有返回\u003chtml\u003e和\u003chead\u003e，因为\u003chtml\u003e和\u003chead\u003e中没有定义class属性。 下面代码找到所有被文字包含的节点内容： In [68]: from bs4 import NavigableString def surrounded_by_strings(tag): return isinstance(tag.next_element, NavigableString) and isinstance(tag.previous_element, NavigableString) In [70]: for tag in soup.find_all(surrounded_by_strings): ...: print(tag.name) ...: # p # a # a # a # p ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:5:1","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\rfind_all() find_all(name, attrs, recursive, text, **kwargs) find_all()方法搜索当前 tag 的所有 tag 子节点，并判断是否符合过滤器的条件。 name 参数name参数可以查找所有名字为name的 tag，字符串对象会被自动忽略掉。 例如： In [72]: soup.find_all(\"title\") Out[72]: [\u003ctitle\u003eThe Dormouse's story\u003c/title\u003e] name参数的值可以是任一类型的过滤器，字符串、正则表达式、列表、方法或是True。 keyword 参数如果一个指定名字的参数不是搜索内置的参数名，搜索时会把该参数当作指定名字 tag 的属性来搜索。如果包含一个名字为id参数，BeautifulSoup会搜索每个 tag 的id属性。 In [73]: soup.find_all(id=\"link2\") Out[73]: [\u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e] 如果传入href参数，BeautifulSoup会搜索每个 tag 的href属性： In [76]: soup.find_all(href=re.compile('elsie')) Out[76]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e] 搜索指定名字的属性时可以使用的参数值包括：字符串、正则表达式、列表、True。 下例在文档中查找所有包含id属性的 tag，无论id的值是什么： In [77]: soup.find_all(id=True) Out[77]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] 使用多个指定名字的参数可以同时过滤 tag 的多个属性： In [78]: soup.find_all(href=re.compile(\"elsie\"), id='link1') Out[78]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e] 有些 tag 属性在搜索时不能使用，比如 HTML5 中的data-*属性： In [79]: data_soup = BeautifulSoup('\u003cdiv data-foo=\"value\"\u003efoo!\u003c/div\u003e', 'lxml') In [80]: data_soup.find_all(data-foo=\"value\") File \"\u003cipython-input-80-a766c8a0cac6\u003e\", line 1 data_soup.find_all(data-foo=\"value\") ^ SyntaxError: keyword can't be an expression 可以通过find_all()方法attrs参数定义一个字典参数来搜索包含特殊属性的 tag： In [81]: data_soup.find_all(attrs={'data-foo':'value'}) Out[81]: [\u003cdiv data-foo=\"value\"\u003efoo!\u003c/div\u003e] 按 CSS 搜索可以通过class_参数搜索指定 CSS 类名的 tag： In [82]: soup.find_all('a', class_=\"sister\") Out[82]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] class_参数同样接受不同类型的过滤器，字符串，正则表达式，方法或True。 text 参数通过text参数可以搜索文档中的字符串内容。与name参数的可选值一样，text参数接受字符串，正则表达式，列表，True，方法。 In [83]: soup.find_all(text='Elsie') Out[83]: ['Elsie'] In [84]: soup.find_all(text=['Tillie','Elsie','Lacie']) Out[84]: ['Elsie', 'Lacie', 'Tillie'] In [85]: soup.find_all(text=re.compile('Dormouse')) Out[85]: [\"The Dormouse's story\", \"The Dormouse's story\"] def is_the_only_string_within_a_tag(s): \"\"\"Return True if this string is the only child of its parent tag.\"\"\" return (s == s.parent.string) In [87]: soup.find_all(text=is_the_only_string_within_a_tag) Out[87]: [\"The Dormouse's story\", \"The Dormouse's story\", 'Elsie', 'Lacie', 'Tillie', '...'] 虽然text参数用于搜索字符串，还可以与其它参数混合使用来过滤 tag。BeautifulSoup会找到.string属性与text参数值相符的 tag。以下代码用来搜索内容中包含Elsie的\u003ca\u003e标签： In [88]: soup.find_all('a', text=\"Elsie\") Out[88]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e] limit 参数find_all()方法返回全部的搜索结构，如果文档树很大那么搜索会很慢。如果我们不需要全部结果，可以使用limit参数限制返回结果的数量。当搜索结果的数量达到limit的限制时，就停止搜索返回结果。 In [89]: soup.find_all('a') Out[89]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] In [90]: soup.find_all('a',limit=2) Out[90]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e] recursive 参数调用 tag 的find_all()方法时，BeautifulSoup会检索当前 tag 的所有子孙节点，如果只想搜索 tag 的直接子节点，可以使用参数recursive=False。 有如下文档： \u003chtml\u003e \u003chead\u003e \u003ctitle\u003e The Dormouse's story \u003c/title\u003e \u003c/head\u003e ... 是否使用recursive参数的结果： In [95]: soup.html.find_all('title') Out[95]: [\u003ctitle\u003e The Dormouse's story \u003c/title\u003e] In [96]: soup.html.find_all('title', recursive=False) Out[96]: [] ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:5:2","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r像调用 find_all()一样调用 tagfind_all()几乎是BeautifulSoup中最常见的搜索方法，所以定义了它的简写方法。BeautifulSoup对象和Tag对象可以被当作一个方法来使用，这个方法的执行结果与调用这个对象的find_all()方法相同。 下面两行代码是等价的： soup.find_all(\"a\") soup(\"a\") 以下两行代码也是等价的： soup.title.find_all(text=True) soup.title(text=True) ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:5:3","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\rCSS 选择器BeautifulSoup支持大部分的 CSS 选择器，在Tag或BeautifulSoup对象的select()方法中传入字符串参数即可使用 CSS 选择器的语法找到 tag： In [1]: from bs4 import BeautifulSoup In [2]: html_doc = \"\"\" ...: \u003chtml\u003e\u003chead\u003e\u003ctitle\u003eThe Dormouse's story\u003c/title\u003e\u003c/head\u003e ...: \u003cbody\u003e ...: \u003cp class=\"title\"\u003e\u003cb\u003eThe Dormouse's story\u003c/b\u003e\u003c/p\u003e ...: ...: \u003cp class=\"story\"\u003eOnce upon a time there were three little sisters; and their names were ...: \u003ca href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"\u003eElsie\u003c/a\u003e, ...: \u003ca href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"\u003eLacie\u003c/a\u003e and ...: \u003ca href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"\u003eTillie\u003c/a\u003e; ...: and they lived at the bottom of a well.\u003c/p\u003e ...: ...: \u003cp class=\"story\"\u003e...\u003c/p\u003e ...: \"\"\" In [3]: soup = BeautifulSoup(html_doc, 'lxml') In [4]: soup.select('title') Out[4]: [\u003ctitle\u003eThe Dormouse's story\u003c/title\u003e] In [5]: soup.select('p:nth-of-type(3)') Out[5]: [\u003cp class=\"story\"\u003e...\u003c/p\u003e] 通过 tag 标签逐层查找： In [6]: soup.select('body a') Out[6]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] In [7]: soup.select('html head title') Out[7]: [\u003ctitle\u003eThe Dormouse's story\u003c/title\u003e] 找到某个 tag 标签下的直接子标签： In [8]: soup.select('head \u003e title') Out[8]: [\u003ctitle\u003eThe Dormouse's story\u003c/title\u003e] In [9]: soup.select('p \u003e a') Out[9]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] 找到兄弟节点标签： In [14]: soup.select('#link1 ~ .sister') Out[14]: [\u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] In [15]: soup.select('#link1 + .sister') Out[15]: [\u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e] 通过 CSS 的类名查找： In [16]: soup.select('.sister') Out[16]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] In [17]: soup.select('[class~=sister]') Out[17]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] 通过 tag 的 id 查找： In [18]: soup.select('#link1') Out[18]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e] In [19]: soup.select('a#link2') Out[19]: [\u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e] 通过是否存在某个属性来查找： In [20]: soup.select('a[href]') Out[20]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] 通过属性的值来查找： In [21]: soup.select('a[href=\"http://example.com/elsie\"]') Out[21]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e] In [22]: soup.select('a[href^=\"http://example.com/\"]') Out[22]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] In [23]: soup.select('a[href$=\"tillie\"]') Out[23]: [\u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] In [24]: soup.select('a[href*=\".com/el\"]') Out[24]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e] 更多有关 CSS 选择器的内容，请参考CSS 选择器参考手册。 ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:5:4","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r爬取豆瓣电影 TOP250 海报接下来，通过爬取豆瓣电影 TOP250 海报实践一下。访问豆瓣电影 Top 250 可以看到每部电影左侧都配有一张海报，我们的目的就是下载这些海报到本地。 多看几页，就会发现每个页面的 URL 和页号是有关系的。 URL 中start这个参数的值等于(页号 - 1) * 25。接下来，再审查一下元素 可以发现海报的地址包含在class值为pic的div元素下，我们可以用BeautifulSoup的select()方法获取到img元素，再提取src属性。代码如下所示： from urllib.request import urlopen from bs4 import BeautifulSoup from fake_useragent import UserAgent from urllib.request import Request import os BASE_URL = \"https://movie.douban.com/top250?start={page_id}\u0026filter=\" user_agent = UserAgent() def get_content(url): \"\"\" 根据url发送请求 :param url: 请求url :return: 响应内容 \"\"\" headers = { 'User-Agent': user_agent.random } request = Request(url, headers=headers) response = urlopen(request) return response.read() def parse_html(html): \"\"\" 解析HTML :param html: HTML文档字符串 :return: \"\"\" soup = BeautifulSoup(html, 'lxml') items = soup.select(\".pic img\") for item in items: yield item.get(\"src\") def save_image(image_url, file_name, folder='images'): \"\"\" 保存图片 :param image_url: 图片地址 :param file_name: 文件名 :param folder: 保存目录 \"\"\" image = get_content(image_url) if not os.path.exists(folder): os.mkdir(folder) file_name = \"{}/{}.jpg\".format(folder, file_name) with open(file_name, 'wb') as f_obj: f_obj.write(image) print(\"保存:\", file_name) def main(): total = 0 for i in range(20): url = BASE_URL.format(page_id=i * 25) html = get_content(url).decode('utf-8') for image in parse_html(html): print(\"下载:\", image) save_image(image, total) total += 1 if __name__ == '__main__': main() 运行结果如下： 最后，可以将所有的海报拼接起来： import math import PIL.Image as Image def merge_images(folder, size=1000): \"\"\" 将folder目录下的图片按尺寸size拼接 :param folder: 图片 :param size: 尺寸 \"\"\" images_count = len(os.listdir(folder)) each_size = int(math.sqrt(size * size / images_count)) - 1 lines_count = int(size / each_size) final_image = Image.new('RGB', (size, size), 'white') row, column = 0, 0 for i in range(images_count): image_path = \"{}/{}.jpg\".format(folder, i) try: image = Image.open(image_path) except IOError as e: print(image_path, \"出错啦！！！\") else: image = image.resize((each_size, each_size)) final_image.paste(image, (row * each_size, column * each_size)) column += 1 if column == lines_count: column = 0 row += 1 final_image.save(\"{}/{}.jpg\".format(folder, \"final_image\"))) 得到： ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:6:0","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r总结本文我们介绍了BeautifulSoup库的一些内容，它可以将 HTML/XML 文档进行解析，得到一个文档树 树中的每个节点都是BeautifulSoup四种对象中的一种。可以用find_all()或select()找到我们需要查找的节点。之后，可以通过节点的属性或者方法获取到我们需要的信息。 ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:7:0","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r参考 https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/ ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:8:0","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":" 2024/11/06 更新: 修改JSON 响应内容、定制请求头、POST 请求中的代码以及图片 我们可以使用 Python 内置的 urllib 包来请求网络资源。它用起来比较麻烦，而且缺少很多实用的高级功能。本文我们将会介绍一个更加方便的 Python 第三方库——Requests 的使用。 ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:0:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r安装 Requests要安装Requests，只要在终端中运行这个简单命令即可： pip install -i https://pypi.douban.com/simple requests 安装好Requests后，就可以开始尝试使用它啦！ ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:1:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r发送请求使用Requests发送网络请求非常简单。导入Requests模块： import requests 然后获取某个网页。我们来获取 Github 的公共时间线： r = requests.get('https://api.github.com/events') 现在，有了一个名为r的Response的对象。我们可以从这个对象中获取所有我们想要的信息。 ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:2:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r传递 URL 参数我们可能会想用 URL 的查询字符串传递某种数据。如果是手动构建 URL，那么数据会以键值对的形式置于 URL 中，跟在一个问号的后面。例如，http://httpbin.org/get?key=val。Requests允许我们使用params关键字参数，以一个字符串字典来提供这些参数。举例来说，如果想传递key1=value1和key2=value2到http://httpbin.org/get，那么可以使用如下代码： import requests payload = {'name':'anthony', 'cat':'ruby'} r = requests.get('http://httpbin.org/get', params=payload) 打印输出该 URL，能看到 URL 已被正确编码： print(r.url) # http://httpbin.org/get?name=anthony\u0026cat=ruby ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:3:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r响应内容我们能读取服务器响应内容。举个例子： import requests r = requests.get(\"http://httpbin.org/get\") print(r.text) 输出内容如下： Requests会自动节码来自服务器的内容。大多数 unicode 字符集都能被无缝地解码。 请求发出后，Requests会基于 HTTP 头部对响应的编码作出有根据的推测。当访问r.text时，Requests会使用其推测的文本编码。我们可以找出Requests使用了什么编码，并且能够使用r.encoding属性来改变它： import requests r = requests.get(\"http://httpbin.org/get\") print(r.encoding) r.encoding = 'utf-8' print(r.encoding) 如果改变了编码，每当访问r.text，Requests都将会使用r.encoding的新值。 ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:4:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r二进制响应内容对于非文本请求，也能以字节的方式访问请求响应体。例如，以请求返回的二进制数据创建一张图片，可以使用如下代码： import requests from PIL import Image from io import BytesIO r = requests.get(\"https://github.com/fluidicon.png\") im = Image.open(BytesIO(r.content)) im.show() ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:5:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\rJSON 响应内容Requests中有一个内置的 JSON 解码器，帮助我们处理 JSON 数据： import requests from pprint import pprint payload = {'name':\"anthony\", 'cat':'ruby'} r = requests.get(\"http://httpbin.org/get\", params=payload) pprint(r.json()) ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:6:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r定制请求头如果想为请求添加 HTTP 头部，只要简单地传递一个dict给headers参数就可。 import requests from pprint import pprint headers = {'User-Agent': 'anthony-agent'} r = requests.get(\"http://httpbin.org/get\", headers=headers) pprint(r.json()) 如下图所示，User-Agent字段的值已被更改为anthony-agent。 ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:7:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\rPOST 请求通常，我们会想要发送一些编码为表单形式的数据——非常像一个 HTML 表单。要实现这个，只需要简单地传递一个字典给data参数。字典数据在发出请求时会自动编码为表单形式： import requests payload = {\"name\":\"anthony\", \"actor\":\"peter\"} r = requests.post(\"http://httpbin.org/post\", data=payload) print(r.text) 还可以给data参数传入一个元组列表。在表单中多个元素使用同一 key 的时候，这种方式很有用： import requests payload = [(\"name\",\"anthony\"), (\"actor\",\"peter\"),(\"actor\",'marry')] r = requests.post(\"http://httpbin.org/post\", data=payload) print(r.text) ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:8:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r响应状态码我们可以查看响应状态码： import requests r = requests.get(\"http://httpbin.org/get\") print(r.status_code) # 200 为了方便使用，Requests附带了也给内置的状态码查询对象： r.status_code == requests.codes.ok # True 如果发送了一个错误请求(一个 4XX 客户端错误，或 5XX 服务器错误响应)，我们可以通过Response.raise_for_status()来抛出异常： In [1]: import requests In [2]: bad_r = requests.get('http://httpbin.org/status/404') In [3]: bad_r.status_code Out[3]: 404 In [4]: bad_r.raise_for_status() --------------------------------------------------------------------------- HTTPError Traceback (most recent call last) \u003cipython-input-4-cdf6910f7d4c\u003e in \u003cmodule\u003e() ----\u003e 1 bad_r.raise_for_status() c:\\python\\lib\\site-packages\\requests\\models.py in raise_for_status(self) 927 928 if http_error_msg: --\u003e 929 raise HTTPError(http_error_msg, response=self) 930 931 def close(self): HTTPError: 404 Client Error: NOT FOUND for url: http://httpbin.org/status/404 但由于我们的例子中r的status_code是 200，当我们调用raise_for_status()时，得到的是： In [6]: r.raise_for_status() # None ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:9:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r响应头我们可以查看以字典形式的服务器响应头： In [7]: r.headers Out[7]: {'Access-Control-Allow-Credentials': 'true', 'Access-Control-Allow-Origin': '*', 'Content-Encoding': 'gzip', 'Content-Type': 'application/json', 'Date': 'Thu, 03 Oct 2019 07:11:16 GMT', 'Referrer-Policy': 'no-referrer-when-downgrade', 'Server': 'nginx', 'X-Content-Type-Options': 'nosniff', 'X-Frame-Options': 'DENY', 'X-XSS-Protection': '1; mode=block', 'Content-Length': '184', 'Connection': 'keep-alive'} ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:10:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\rCookie如果某个响应中包含一些 cookie，可以快速访问它们： In [19]: r = requests.get('https://www.baidu.com') In [20]: r.cookies Out[20]: \u003cRequestsCookieJar[Cookie(version=0, name='BDORZ', value='27315', port=None, port_specified=False, domain='.baidu.com', domain_specified=True, domain_initial_dot=True, path='/', path_specified=True, secure=False, expires=1570173564, discard=False, comment=None, comment_url=None, rest={}, rfc2109=False)]\u003e In [21]: r.cookies['BDORZ'] Out[21]: '27315' 要想发送 cookies 到服务器，可以使用cookies参数： In [27]: url = 'http://httpbin.org/cookies' In [28]: cookies = dict(cookies_are=\"working\") In [29]: r = requests.get(url, cookies=cookies) In [30]: r.json() Out[30]: {'cookies': {'cookies_are': 'working'}} ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:11:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r超时可以告诉Requests在经过以timeout参数设定的秒数时间之后停止等待响应。 \u003e\u003e\u003e requests.get('http://github.com', timeout=0.001) Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e requests.exceptions.Timeout: HTTPConnectionPool(host='github.com', port=80): Request timed out. (timeout=0.001) ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:12:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r错误与异常遇到网络问题(如：DNS 查询失败、拒绝连接等)时，Requests会抛出一个ConnectionError异常。 如果 HTTP 请求返回了不成功的状态码， Response.raise_for_status()会抛出一个HTTPError异常。 若请求超时，则抛出一个Timeout异常。 若请求超过了设定的最大重定向次数，则会抛出一个TooManyRedirects异常。 所有Requests显式抛出的异常都继承自 requests.exceptions.RequestException 。 ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:13:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r代理如果需要使用代理，可以通过任意请求方法提供proxies参数来配置单个请求： import requests proxies = { 'https': 'https://127.0.0.1:1080' } r = requests.get('https://www.google.com', proxies=proxies) print(r.status_code) # 200 也可以通过环境变量HTTP_PROXY和HTTPS_PROXY来配置代理。 $ export HTTP_PROXY=\"http://10.10.1.10:3128\" $ export HTTPS_PROXY=\"http://10.10.1.10:1080\" $ python \u003e\u003e\u003e import requests \u003e\u003e\u003e requests.get(\"http://example.org\") ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:14:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r参考 https://requests-docs-cn.readthedocs.io/zh_CN/latest/index.html ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:15:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["数据科学"],"content":"在数据科学和分析领域，图表不仅是展示数据的工具，更是讲故事的语言。Matplotlib 是 Python 中历史最悠久且功能最全面的绘图库。无论你是想画一个简单的折线图，还是需要定制复杂的多图布局，Matplotlib 都能满足你的需求。这篇文章将带你快速上手，学会用代码画出数据的价值。 创建图与图表是很多分析项目中的一个重要步骤，它通常是项目开始时探索性数据分析（EDA）的一部分，或者在项目报告阶段向其他人介绍你的数据分析结果时使用。 matplotlib 是一个绘图库，创建的图形可达到出版的质量要求。它可以创建常用的统计图，包括条形图、箱线图、折线图、散点图和直方图等等图形。matplotlib 提供了对图形各个部分进行定制的功能。例如，它可以设置图形的形状和大小、x 轴与 y 轴的范围和标度、x 轴和 y 轴的刻度线和标签、图例以及图形的标题。更多关于定制图形的信息请查看：https://matplotlib.org/users/beginner.html 。 下面，我们就开始学习一些常见图形的绘制，使用的数据来自The Complete Pokemon Dataset。 先将数据导入， import numpy as np import pandas as pd import matplotlib.pyplot as plt plt.style.use('ggplot') %matplotlib inline data = pd.read_csv('../../Datasets/pokemon.csv') data.head() 数据每一列的含义如下， ","date":"2021-04-27","objectID":"/matplotlib%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:0","tags":["Python","Matplotlib","数据分析","数据可视化","数据科学"],"title":"Matplotlib简明教程","uri":"/matplotlib%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"\r条形图假如我们想查看一下每一代 Pokemon 的数量，并用条形图显示出来，该怎么办呢？ generation = data['generation'].value_counts() plt.bar(generation.index, generation.values) 可以看到如下结果： 如果我们想添加轴标签和标题的话，加上如下内容即可： plt.xlabel('generation') plt.ylabel('count') plt.title('Generation and Count') 为了方便起见，我们也可以为每个条加上数值标签， for x,y in enumerate(generation.values): plt.text(x+1,y,'%s' % y,ha='center') matplotlib.pyplot.bar函数详情： matplotlib.pyplot.bar(x, height, width=0.8, bottom=None, *, align='center', data=None, **kwargs) x: 指定图形横轴坐标 height: 指定条形图的高度 width: 指定条形图的宽度 color: 指定条形图前景色 edgecolor: 设置条形图边界颜色 linewidth: 设置条形图边界宽度 更多内容请查看：https://matplotlib.org/api/_as_gen/matplotlib.pyplot.bar.html 知道了上述参数的含义之后，我们就可以对之前的图形进行小小的改动啦！ generation = data['generation'].value_counts() plt.bar(generation.index, generation.values, facecolor='orange',edgecolor='green', linewidth=2) plt.xlabel('generation') plt.ylabel('count') plt.title('Generation and Count') for x,y in enumerate(generation.values): plt.text(x+1,y,'%s' % y,ha='center') ","date":"2021-04-27","objectID":"/matplotlib%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:1:0","tags":["Python","Matplotlib","数据分析","数据可视化","数据科学"],"title":"Matplotlib简明教程","uri":"/matplotlib%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"\r箱线图箱线图一般用来展示数据的分布（如上下四分位数、中位数等），同时，也可以用来反映数据的异常情况。 box = data[['defense','attack','hp']] plt.boxplot(box.values) plt.setp(plt.gca(),xticklabels=['defense','attack','hp']) matplotlib.pyplot.boxplot函数详情： matplotlib.pyplot.boxplot(x, notch=None, sym=None, vert=None, whis=None, positions=None, widths=None, patch_artist=None, bootstrap=None, usermedians=None, conf_intervals=None, meanline=None, showmeans=None, showcaps=None, showbox=None, showfliers=None, boxprops=None, labels=None, flierprops=None, medianprops=None, meanprops=None, capprops=None, whiskerprops=None, manage_xticks=True, autorange=False, zorder=None) x: 指定绘图的数据 notch: 是否是凹口的形式展示箱线图，默认为非凹口 sym: 指定异常点的形状 vert: 是否需要将图形垂直摆放，默认为垂直摆放 whis: 指定上下须与上下四分位数的距离，默认为 1.5 倍的四分位差 positions: 指定图形的位置，默认为[0,1,2……] widths: 指定图形的宽度，默认为 0.5 patch_artist: 是否填充箱体的颜色 meanline: 是否用线表示均值，默认用点表示 showmeans: 是否显示均值，默认不显示 showcaps: 是否显示图形顶端和末端的两条线，默认显示 showbox: 是否显示图形的箱体，默认显示 showfliers: 是否显示异常值，默认显示 boxprops: 设置箱体的属性，如边框色、填充色等 labels: 指定箱线图的标签 filerprops: 设置异常值的属性，如异常点的形状、大小等 medianprops: 设置中位数的属性，如线的类型、粗细等 meanprops: 设置均值的属性，如点的大小、颜色等 capprops: 设置图形顶端和末端线条的属性，如颜色、粗细等 whiskerprops: 设置须得属性，如颜色、粗细等 更多内容请查看：https://matplotlib.org/api/_as_gen/matplotlib.pyplot.boxplot.html ","date":"2021-04-27","objectID":"/matplotlib%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:2:0","tags":["Python","Matplotlib","数据分析","数据可视化","数据科学"],"title":"Matplotlib简明教程","uri":"/matplotlib%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"\r折线图我们不妨查看一下每一代 Pokemon 攻击力的走势， generation_attack = data.pivot('name', 'generation', 'attack').fillna(0) for col in generation_attack.columns: gene = generation_attack[generation_attack[col] \u003e 0][col].sort_values() plt.plot(range(gene.shape[0]),gene.values,label=col) plt.legend() plt.ylabel('Attack') matplotlib.pyplot.plot函数详情： matplotlib.pyplot.plot(*args, scalex=True, scaley=True, data=None, **kwargs) x: x 轴数据 y: y 轴数据 fmt: 格式化字符串 更多内容请查看：https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html ","date":"2021-04-27","objectID":"/matplotlib%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:3:0","tags":["Python","Matplotlib","数据分析","数据可视化","数据科学"],"title":"Matplotlib简明教程","uri":"/matplotlib%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"\r散点图将防御力和攻击力用散点图绘制出来， plt.scatter(data['attack'], data['defense']) plt.xlabel('attck') plt.ylabel('defense') matplotlib.pyplot.scatter函数详情： matplotlib.pyplot.scatter(x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, verts=None, edgecolors=None) x: 指定数据横坐标 y: 指定数据纵坐标 s: 指定标记大小 c: 指定标记颜色 marker: 设置标记样式 alpha: 设置透明度 linewidths: 设置标记边缘的线宽 edgecolors: 设置标记边缘的颜色 更多内容请查看：https://matplotlib.org/api/_as_gen/matplotlib.pyplot.scatter.html ","date":"2021-04-27","objectID":"/matplotlib%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:4:0","tags":["Python","Matplotlib","数据分析","数据可视化","数据科学"],"title":"Matplotlib简明教程","uri":"/matplotlib%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"\r直方图将防御力的分布用直方图绘制， plt.hist(data['defense'],bins=25) plt.xlabel('Defense') plt.ylabel('Frequency') matplotlib.pyplot.hist函数详情： matplotlib.pyplot.hist(x, bins=None, range=None, density=None, weights=None, cumulative=False, bottom=None, histtype='bar', align='mid', orientation='vertical', rwidth=None, log=False, color=None, label=None, stacked=False, normed=None) x: 指定每个 bin 分布的数据，对应 x 轴 bins: 指定 bin 的个数 range: 指定 bin 的分布范围 density: 是否将得到的直方图归一化 cumulative: 是否绘制累积频数图 bottom: 指定每个 bin 底部的基线位置 histtype: 指定直方图类型 align: 设置直方图的绘制方式，默认为 mid orientation: 指定方向，水平或垂直 log: 是否使用对数刻度 label: 设置图形的标签说明 stacked: 是否将图形堆叠 更多内容请查看：https://matplotlib.org/api/_as_gen/matplotlib.pyplot.hist.html ","date":"2021-04-27","objectID":"/matplotlib%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:5:0","tags":["Python","Matplotlib","数据分析","数据可视化","数据科学"],"title":"Matplotlib简明教程","uri":"/matplotlib%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"\r饼图接下来，我们可以看一下幻之宝可梦所占的比例， color = [\"aqua\", \"orange\"] leg = [data[data['is_legendary'] == 0].shape[0],data[data['is_legendary'] == 1].shape[0]] legPie = plt.pie(leg,labels=['Non Legendary', 'Legendary'],colors=color,shadow=True, autopct='%1.1f%%',startangle=45,explode=(0,0.1)) matplotlib.pyplot.pie函数详情： matplotlib.pyplot.pie(x, explode=None, labels=None, colors=None, autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1, startangle=None, radius=None, counterclock=True, wedgeprops=None, textprops=None, center=(0, 0), frame=False, rotatelabels=False) x: 指定绘图的数据 explode: 指定饼图某些部分突出显示 labels: 指定饼图的标签说明 colors: 指定饼图的填充色 autopct: 设置百分比格式 pctdistance: 设置百分比标签与圆心的距离 shadow: 是否添加阴影效果 labeldistance: 设置各扇形标签与圆心的距离 startangle: 设置饼图的初始摆放角度 radius: 设置饼图的半径大小 counterclock: 是否让饼图按逆时针显示 wedgeprops: 设置饼图内外边界属性，如边界线的粗细、颜色等 textprops: 设置饼图中文本的属性，如字体大小、颜色等 center: 指定饼图的中心位置 frame: 是否要显示饼图背后的图框 rotatelabels: 是否要让扇形标签跟着扇形角度旋转 更多内容请查看：https://matplotlib.org/api/_as_gen/matplotlib.pyplot.pie.html 如果感觉意犹未尽的话，可以到：https://matplotlib.org/gallery/index.html 学习各种图的绘制。 万一这都满足不了你对可视化的追求的话，可以参考10 Useful Python Data Visualization Libraries for Any Discipline，进行学习。 ","date":"2021-04-27","objectID":"/matplotlib%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:6:0","tags":["Python","Matplotlib","数据分析","数据可视化","数据科学"],"title":"Matplotlib简明教程","uri":"/matplotlib%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"\r绘制 NAB 球员出手位置接下来，我们将提取 NBA 球员投篮数据，然后用matplotlib和seaborn绘制出手位置图。 首先我们导入需要用到的包： import requests import matplotlib.pyplot as plt import pandas as pd import seaborn as sns %matplotlib inline NBA 有一个官方统计网站https://stats.nba.com/，可以在该网站到查到各种统计数据。 为了获取到James Harden在2018-2019赛季的投篮数据，可以使用以下地址： player_id = \"201935\" shot_chart_url = \"https://stats.nba.com/stats/shotchartdetail?CFID=33\u0026CFPARAMS=2018-19\u0026ContextFilter=\u0026ContextMeasure=FGA\u0026DateFrom=\u0026DateTo=\u0026GameID=\u0026GameSegment=\u0026LastNGames=0\u0026LeagueID=00\u0026Location=\u0026MeasureType=Base\u0026Month=0\u0026OpponentTeamID=0\u0026Outcome=\u0026PaceAdjust=N\u0026PerMode=PerGame\u0026Period=0\u0026PlayerID=\"+ player_id + \"\u0026PlusMinus=N\u0026Position=\u0026Rank=N\u0026RookieYear=\u0026Season=2018-19\u0026SeasonSegment=\u0026SeasonType=Regular+Season\u0026TeamID=0\u0026VsConference=\u0026VsDivision=\u0026mode=Advanced\u0026showDetails=0\u0026showShots=1\u0026showZones=0\u0026PlayerPosition=\" 其中player_id指的是球员的 ID，比如James Harden的 ID 就是201935。 每个球员的 ID 都可以在https://stats.nba.com/查到，比如Kobe Bryant, 搜索Kobe Bryant 地址栏中的977就是他的球员 ID 接下来，我们可以使用Requests包请求上述地址获取到数据： headers = {'User-Agent': \"Mozilla\"} response = requests.get(shot_chart_url, headers=headers) 请求返回的数据是 JSON 格式的，可以用Pandas创建一个DataFrame对象，方便后续处理。 column_names = response.json()['resultSets'][0]['headers'] shots = response.json()['resultSets'][0]['rowSet'] shot_df = pd.DataFrame(shots, columns=column_names) from IPython.display import display with pd.option_context('display.max_columns', None): display(shot_df.head()) 以上便是James Harden在2018-2019赛季常规赛的投篮数据。其中LOC_X,LOC_Y就是出手位置，可以用散点图将其绘制出来： sns.set_style(\"white\") sns.set_color_codes() plt.figure(figsize=(12,11)) plt.scatter(shot_df.LOC_X, shot_df.LOC_Y, alpha=0.3) plt.show() 为了更加直观，我们用以下代码把球场绘制出来： from matplotlib.patches import Circle, Rectangle, Arc def draw_court(ax=None, color='black', lw=2, outer_lines=False): if ax is None: ax = plt.gca() hoop = Circle((0, 0), radius=7.5, linewidth=lw, color=color, fill=False) backboard = Rectangle((-30, -7.5), 60, -1, linewidth=lw, color=color) outer_box = Rectangle((-80, -47.5), 160, 190, linewidth=lw, color=color, fill=False) inner_box = Rectangle((-60, -47.5), 120, 190, linewidth=lw, color=color, fill=False) top_free_throw = Arc((0, 142.5), 120, 120, theta1=0, theta2=180, linewidth=lw, color=color, fill=False) bottom_free_throw = Arc((0, 142.5), 120, 120, theta1=180, theta2=0, linewidth=lw, color=color, linestyle='dashed') restricted = Arc((0, 0), 80, 80, theta1=0, theta2=180, linewidth=lw, color=color) corner_three_a = Rectangle((-220, -47.5), 0, 140, linewidth=lw, color=color) corner_three_b = Rectangle((220, -47.5), 0, 140, linewidth=lw, color=color) three_arc = Arc((0, 0), 475, 475, theta1=22, theta2=158, linewidth=lw, color=color) center_outer_arc = Arc((0, 422.5), 120, 120, theta1=180, theta2=0, linewidth=lw, color=color) center_inner_arc = Arc((0, 422.5), 40, 40, theta1=180, theta2=0, linewidth=lw, color=color) court_elements = [hoop, backboard, outer_box, inner_box, top_free_throw, bottom_free_throw, restricted, corner_three_a, corner_three_b, three_arc, center_outer_arc, center_inner_arc] if outer_lines: outer_lines = Rectangle((-250, -47.5), 500, 470, linewidth=lw, color=color, fill=False) court_elements.append(outer_lines) for element in court_elements: ax.add_patch(element) return ax 绘制球场 plt.figure(figsize=(12, 11)) draw_court(outer_lines=True) plt.xlim(-300, 300) plt.ylim(-100, 500) plt.show() 将出手位置也加进去 plt.figure(figsize=(12, 11)) plt.scatter(shot_df.LOC_X, shot_df.LOC_Y, alpha=0.3) draw_court(outer_lines=True) plt.xlim(300,-300) plt.show() 使用Seaborn的jointplot绘制图像 joint_shot_chart = sns.jointplot(shot_df.LOC_X, shot_df.LOC_Y, space=0, alpha=0.5) joint_shot_chart.fig.set_size_inches(12,11) ax = joint_shot_chart.ax_joint draw_court(ax) ax.set_xlim(-250, 250) ax.set_ylim(422.5, -47.5) ax.set_xlabel(\"\") ax.set_ylabel(\"\") ax.tick_params(labelbottom=\"off\", labelleft=\"off\") 从中可以看到其出手位置的分布情况。 值得注意的是，shot_df中有一列SHOT_MADE_FLAG代表的是是否投中（1 为投中，0 为未投中），我们可以查看一下投中出手位置的分布： made_df = shot_df[shot_df['SHOT_MADE_FLAG']==1] joint_shot_chart = sns.jointplot(made_df.LOC_X, made_df.","date":"2021-04-27","objectID":"/matplotlib%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:7:0","tags":["Python","Matplotlib","数据分析","数据可视化","数据科学"],"title":"Matplotlib简明教程","uri":"/matplotlib%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"\r参考 https://liam.page/2014/09/11/matplotlib-tutorial-zh-cn/ https://blog.csdn.net/ScarlettYellow/article/details/80458797 https://wizardforcel.gitbooks.io/matplotlib-user-guide/content/ https://blog.csdn.net/qq_34337272/article/details/79555544 https://matplotlib.org/tutorials/index.html How to Create NBA Shot Charts in Python ","date":"2021-04-27","objectID":"/matplotlib%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:8:0","tags":["Python","Matplotlib","数据分析","数据可视化","数据科学"],"title":"Matplotlib简明教程","uri":"/matplotlib%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"众所周知，Pandas 是最受欢迎的 Python 数据科学与分析库。Numpy 用于较低级别的科学计算。Pandas 构建于 Numpy 之上，专为实际数据分析而设计。本文总结了一些常见、方便的功能。话不多说，让我们开始吧！ ","date":"2021-01-27","objectID":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:0","tags":["Python","Pandas","数据分析","数据科学"],"title":"Pandas简明教程","uri":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"\r数据集数据是数据科学与分析的“命根子”，我们需要从数据中寻找答案，从数据中发现模式……如果没有数据的话，就无从谈起。数据获取的方式有很多种，这里分享一些提供数据的平台。 pandas-videos：https://github.com/justmarkham/pandas-videos UCI Machine Learning Reposity：https://archive.ics.uci.edu/datasets ","date":"2021-01-27","objectID":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:1:0","tags":["Python","Pandas","数据分析","数据科学"],"title":"Pandas简明教程","uri":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"\r导入数据任何的数据分析工作都是从导入数据开始，Pandas提供了很多导入数据的方法。 pd.read_csv(filename) # From a CSV file pd.read_table(filename) # From a delimited text file (like TSV) pd.read_excel(filename) # From an Excel file pd.read_sql(query, connection_object) # Reads from a SQL table/database pd.read_json(json_string) # Reads from a JSON formatted string, URL or file pd.read_html(url) # Parses an html URL, string or file and extract tables to a list of dataframes pd.read_clipboard() # Takes the contents of your clipboard and passes it to read_table() pd.DataFrame(dict) # From a dict, keys for columns names, values for data as lists 不妨举个例子，我们想分析一下 IMDB 高分电影，经过一番搜索，发现 https://raw.githubusercontent.com/justmarkham/pandas-videos/master/data/imdb_1000.csv 上的数据就不错， 若想把它导入，使用pd.read_csv方法就行啦！ 具体来说，就是： dataURL = 'https://raw.githubusercontent.com/justmarkham/pandas-videos/master/data/imdb_1000.csv' df = pd.read_csv(dataURL) df.head() # Prints first 5 rows of the DataFrame 关于上述导入数据方法的更多详细内容，请查看IO Tools。 ","date":"2021-01-27","objectID":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:2:0","tags":["Python","Pandas","数据分析","数据科学"],"title":"Pandas简明教程","uri":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"\r探索数据一旦将数据导入到 DataFrame 中之后，就可以用以下方法来了解数据的情况。 df.index # Index Description df.columns # Columns in the DataFrame df.shape # Prints number of row and columns in DataFrame df.head(n) # Prints first n rows of the DataFrame df.tail(n) # Prints last n rows of the DataFrame df.info() # Index, DataType and Memory information df.describe() # Summary statistics for numerical columns s.value_counts(dropna=False) # Views unique values and counts df.apply(pd.Series.value_counts) # Unique value and counts for all columns df.mean() # Returns the mean of all columns df.corr() # Returns the correlation between columns in a DataFrame df.count() # Returns the number of non-null values in each DataFrame column df.max() # Returns the highest value in each column df.min() # Returns the lowest value in each column df.median() # Returns the median of each column df.std() # Returns the standard deviation of each column df.idxmax() # Index of the lowest value df.idxmin() # Index of the highest value 举个例子，在导入 IMDB 高分电影数据后统计一下每种电影类型的频数，我们就可以用: df['genre'].value_counts() ","date":"2021-01-27","objectID":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:3:0","tags":["Python","Pandas","数据分析","数据科学"],"title":"Pandas简明教程","uri":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"\r选择通常，我们可能需要选择单个元素或者数据的某个子集来进行深入分析。那么，这些方法就会大显身手： df[col] # Returns column with label col as Series df[[col1, col2]] # Returns columns as a new DataFrame s.iloc[0] # Selection by position (selects first element) s.loc[0] # Selection by index (selects element as index 0) df.iloc[0, :] # First row df.iloc[0, 0] # First element of first column df.iat[0, 0] # First element of first column. Access a single value for row/column pair by integer position df.at[row_label, col_label] # Access a single value for row/column label pair 更多内容，请查看Indexing and Selecting Data。 ","date":"2021-01-27","objectID":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:4:0","tags":["Python","Pandas","数据分析","数据科学"],"title":"Pandas简明教程","uri":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"\r数据清理实际上，我们拿到数据后，往往需要清理它。以下就是一些非常有用的方法： df.columns = ['a', 'b', 'c'] # Renames columns pd.isnull() # Checks for null values, return Boolean Array pd.notnull() # Opposite of pd.isnull() df.dropna() # Drops all rows that contain null values df.dropna(axis=1) # Drops all columns that contain null values df.dropna(axis=1, thresh=n) # Drops all rows hava less than non null values df.fillna(x) # Replaces all null values with x s.fillna(s.mean()) # Replaces all null values with the mean s.astype(float) # Converts the datatype of the series to float s.replace(1, 'one') # Replaces all values equal to 1 with 'one' s.replace([1, 3], ['one', 'three']) # Replace all 1 with 'one' and 3 with 'three' df.rename(columns=lambda x: x + 1) # Mass renaming of columns df.rename(columns={'old_name': 'new_name'}) # Selective renaming df.set_index('column_one') # Changes the index df.rename(index=lambda x: x + 1) # Mass renaming of index df.drop(labels) # Drop specified labels from rows or columns df.drop_duplicates(subset) # Return DataFrame with duplicate rows removed, optionally only considering certain columns 更多内容，请查看Working with missing data。 ","date":"2021-01-27","objectID":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:5:0","tags":["Python","Pandas","数据分析","数据科学"],"title":"Pandas简明教程","uri":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"\r过滤，排序和分组一些对数据过滤、排序和分组的方法： df[df[col] \u003e 0.5] # Rows where the col column is greater than 0.5 df[(df[col] \u003e 0.5) \u0026 (df[col] \u003c 0.7)] # Rows where 0.5 \u003c col \u003c 0.7 df.sort_values(col1) # Sorts values by col1 in ascending order df.sort_values(col2, ascending=False) # Sorts values by col2 in descending order df.sort_values([col1, col2], ascending=[True, False]) # Sorts values by col1 in ascending order then col2 in descending order df.groupby(col) # Returns a groupby object for values from one column df.groupby([col1,col2]) # Returns a groupby object values from multiple columns df.groupby(col1)[col2].mean() # Returns the mean of the values in col2, grouped by the values in col1 (mean can be replaced with almost any function from the statistics section) df.pivot_table(index=col1, values= col2,col3], aggfunc=mean) # Creates a pivot table that groups by col1 and calculates the mean of col2 and col3 df.groupby(col1).agg(np.mean) # Finds the average across all columns for every unique column 1 group df.apply(np.mean) # Applies a function across each column df.apply(np.max, axis=1) # Applies a function across each row 更多内容，请查看Group By: split-apply-combine。 ","date":"2021-01-27","objectID":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:6:0","tags":["Python","Pandas","数据分析","数据科学"],"title":"Pandas简明教程","uri":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"\r导出数据最后，当需要将分析结果导出时，也有几种方便的发方： df.to_csv(filename) # Writes to a CSV file df.to_excel(filename) # Writes to an Excel file df.to_sql(table_name, connectiion_object) # Writes to a SQL table df.to_json(filename) # Writes to a file in JSON format df.to_html(filename) # Saves as an HTML table df.to_clipboard() # Writes to the clipboard 详情请查看IO Tools。 ","date":"2021-01-27","objectID":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:7:0","tags":["Python","Pandas","数据分析","数据科学"],"title":"Pandas简明教程","uri":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"\r连接和合并合并两个 DataFrame 的方法： pd.concat([df1, df2], axis=1) # Adds the columns in df1 to the end of df2 pd.merge(df11, df2) # SQL-style merges df1.append(df2) # Adds the rows in df1 to the end of df2 (columns should be identical) df1.join(df2,on=col1,how='inner') # SQL-style joins 更多内容，请查看Merge, join, and concatenate。 ","date":"2021-01-27","objectID":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:8:0","tags":["Python","Pandas","数据分析","数据科学"],"title":"Pandas简明教程","uri":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"\r创建测试对象通用用于测试代码段。 pd.DataFrame(np.random.rand(20,5)) # 5 columns and 20 rows of random floats pd.Series(my_list) # Create a series from an iterable my_list df.index = pd.data_range('1900/1/30', periods=df.shape[0]) # Add a date index ","date":"2021-01-27","objectID":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:9:0","tags":["Python","Pandas","数据分析","数据科学"],"title":"Pandas简明教程","uri":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"\rbitly_usagov 数据集分析或许我们可以从一个实例（来源于书籍《Python for Data Analysis》）出发，当作一个小练习。选用的是bitly_usagov数据集。 该数据集可以在：https://github.com/wesm/pydata-book 处找到。 ","date":"2021-01-27","objectID":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:10:0","tags":["Python","Pandas","数据分析","数据科学"],"title":"Pandas简明教程","uri":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"\r导入数据假如将数据下载到了本地，我们可以尝试将其导入并得到 DataFrame 对象，便于之后的分析工作。 import pandas as pd file_path = '../../Datasets/bitly_usagov/example.txt' # Local file path df = pd.read_json(file_path, lines=True) df.info() ","date":"2021-01-27","objectID":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:10:1","tags":["Python","Pandas","数据分析","数据科学"],"title":"Pandas简明教程","uri":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"\r对时区计数df对象有一列名为tz，表示的是时区。我们可以对所有数据的时区进行统计， tz_counts = df['tz'].value_counts() tz_counts.head(10) 我们可以将结果可视化，但在此之前，可以将未知或者缺失的时区补上一个替代值。 fillna函数可以替换缺失值（NA），而未知值（空字符串）则可以通过布尔数组索引进行替换： clean_tz = df['tz'].fillna('Missing') clean_tz[clean_tz == ''] = 'Unknown' tz_counts = clean_tz.value_counts() 之后，我们可以用seaborn包创建水平柱状图： df对象名为a的列中含有浏览器、设备、应用程序的相关信息，我们可以简单地将浏览器信息提取出来： df.a.str.split(' ').str.get(0).head(10) 类似地，我们也可以将浏览器的统计信息可视化： ","date":"2021-01-27","objectID":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:10:2","tags":["Python","Pandas","数据分析","数据科学"],"title":"Pandas简明教程","uri":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["数据科学"],"content":"\r参考 https://paulovasconcellos.com.br/28-useful-pandas-functions-you-might-not-know-de42c59db085 https://elitedatascience.com/python-cheat-sheet https://www.dataquest.io/blog/pandas-cheat-sheet/ http://pandas.pydata.org/pandas-docs/stable/10min.html ","date":"2021-01-27","objectID":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:11:0","tags":["Python","Pandas","数据分析","数据科学"],"title":"Pandas简明教程","uri":"/pandas%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["搜索"],"content":"搜索引擎是我们日常学习工作最常使用的服务之一。你可能每天都在用它，但是却仍旧不知道“搜索”。高效地使用搜索引擎可以事半功倍，下面就盘点一下那些年我们可能错过的实用 Google 搜索技巧吧！ ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:0:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r使用加号(或空格)表示与不需要使用“+”来表示逻辑与，只要空格就可以了。什么意思呢？简单地说就是，当我们在搜索框输入A B搜索时，就是告诉 Google，我们要搜索的内容与 A 并且和 B 有关。比如说，我们想要搜索与 java 和 python 有关的内容，就可以用java python进行搜索。 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:1:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r使用双引号搜索短语如果想要搜索一些短语，比如我们想要搜索与purpose of education有关的内容，而在搜索框输入purpose of education进行搜索，这显然不是很对。因为我们知道 Google 会把它理解成三个关键字的逻辑与，而不是把三个关键字整体当成一个短语。这个时候，就有必要使用双引号，告诉 Google 需要把双引号中的内容看成一个短语。 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:2:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r使用星号星号*是常用的通配符，也可以在搜索中使用，代表任意文字。具体来说，假如有一天，突然想起了朋友们之前在谈论金庸先生的一部叫什么八部的小说，小说的名字却怎么都想不起来，只依稀记得八部两个字，这个时候我们就可以使用星号*表示所有可能的文字进行搜索。 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:3:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r使用减号我们可能想要过滤掉一些不太感兴趣的信息，这个时候就可以使用-。 我们对盗梦空间这部电影不太感兴趣，于是可以使用减号（-），将其从搜索结果中排除。 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:4:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r使用波浪号把波浪号~加在某个词前面，告诉 Google：要搜索与波浪号~后面的那个词相关的近义词。比如，我们要搜索关于大学（college）测验分数（test scores）但不是 SAT 入学分数的相关内容。 college 的近义词，比如 higher education, university 也会一起搜索出来。 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:5:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r列出相似网页有一天你发现了一个非常喜欢的网站，比如 Coursera，于是乎你想知道还有没有类似的网站。我们可以使用操作符related:来解决这件事。 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:6:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r搜索数字范围可以使用..表示数字范围。具体来说， ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:7:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r使用OR表示或用OR表示逻辑或。比如，搜索詹姆斯或科比，或者二者都有的网页。 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:8:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r其他指令 操作符 用途 用法 allinanchor: 限制搜索的词是网页中链接中包含的关键字（可使用多个关键词） allinanchor:keyword1 keyword2 allintext: 限制搜索的词是网页内文包含的关键词（可使用多个关键词） allintext:keyword1 keyword2 allintitle: 限制搜索的词是网页标题中包含的关键词（可使用多个关键词） allintitle:keyword1 keyword2 allinurl: 限制搜索的词是网页网址中包含的关键词（可使用多个关键词） allinurl:keyword1 keyword2 filetype: 限制所搜索的文件一个特定的格式 filetype:extension inanchor: 限制搜索的词是网页中链接中包含的关键词 inanchor:keyword intext: 限制搜索的词是网页内文中包含的关键词 intext:keyword intitle: 限制搜索的词是网页标题中包含的关键词 intitle:keyword inurl: 限制搜索的词是网页网址中包含的关键词 inurl:keyword site: 限制所进行的搜索在指定的域名或网站中 site:domain 举个例子，假如我们要搜索在伯乐在线上的有关 Java 的文章，就可以使用site:操作符，如下所示： ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:9:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r番外篇Google 还包含了许多其他实用有趣的功能。比如： ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:10:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r查看天气 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:10:1","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r股票报价 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:10:2","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r单词含义 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:10:3","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r计算器 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:10:4","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r画函数图像 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:10:5","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r页面旋转 更多有趣的内容，可查看阅读下列文章。 15 fun things to type into Google 20 Really Cool Google Features You Probably Don’t Know About 8 Hidden (And Useful) Features in Google Search ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:10:6","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r参考 Ten Tips for Smarter Google Searches 15 fun things to type into Google ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:11:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["Tkinter"],"content":"本文我们将学习如何使用Tkinter包编写一些图形用户界面程序。Tkinter是 Python 的一个标准包，因此我们并不需要安装它。我们将从创建一个窗口开始，然后我们在其之上加入一些小组件，比如按钮，复选框等，并使用它们的一些属性。话不多说，让我们开始吧！ ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r创建一个窗口首先，我们导入Tkinter包，然后创建一个窗口，最后给这个窗口设置标题。 from tkinter import * window = Tk() window.title(\"First Window\") window.mainloop() 结果如下： 最后一行我们调用了mainloop函数，这个函数将让窗口等待用户与之交互，直到我们关闭它。如果忘记调用mainloop函数的话，将不会向用户显示任何内容（没有窗口）。 ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:1:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r添加一个标签组件为了给之前的例子增加一个标签组件，我们可以使用Label类： lbl = Label(window, text=\"Hello\") 我们可以通过grid函数设置其在窗口的位置： lbl.grid(column=0, row=0) 完整代码如下所示： from tkinter import * window = Tk() window.title(\"First Window\") lbl = Label(window, text=\"Hello\") lbl.grid(column=0, row=0) window.mainloop() 结果如下： 值得注意的是lbl没有调用grid函数的话是不会显示的。 ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:2:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r设置标签字体大小我们可以使用font参数设置标签字体大小： lbl = Label(window, text=\"Hello\", font=(\"Arial Bold\", 50)) font参数不光可以在标签组件中用，其他组件也可以使用呢！ 可是，现在窗口貌似太小了，连窗口的标题都看不全，如何设置窗口大小呢？ ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:2:1","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r设置窗口大小我们可以用geometry函数来设置窗口大小： window.geometry(\"350x200\") 以上代码将会把窗口设置成 350 个像素宽，200 个像素高。 ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:2:2","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r添加一个按钮组件让我们给窗口增加一个按钮组件，它的创建和添加方式和标签组件差不多： btn = Button(window, text=\"Click Me\") btn.grid(column=1, row=0) 完整代码如下所示： from tkinter import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") lbl = Label(window, text=\"Hello\") lbl.grid(column=0, row=0) btn = Button(window, text=\"Click Me\") btn.grid(column=1, row=0) window.mainloop() 结果如下： ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:3:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r更改按钮前景和背景颜色我们可以用fg参数设置按钮或其他组件的前景色。 我们可以用bg参数设置按钮或其他组件的背景色。 btn = Button(window, text=\"Click Me\", bg=\"orange\", fg=\"red\") 现在，如果点击按钮，什么都不会发生，因为我们没有写处理点击事件的代码。 ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:3:1","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r处理按钮点击事件首先，我们编写一个当按钮点击后需要执行的函数： def clicked(): lbl.configure(text=\"Button was clicked!\") 然后，我们注明一下点击时要调用的函数： btn = Button(window, text=\"Click Me\", command=clicked) 完整代码如下所示： from tkinter import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") lbl = Label(window, text=\"Hello\") lbl.grid(column=0, row=0) def clicked(): lbl.configure(text=\"Button was clicked!\") btn = Button(window, text=\"Click Me\", command=clicked) btn.grid(column=1, row=0) window.mainloop() 当我们点击按钮后，结果如下： ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:3:2","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r添加一个文本框在之前的例子中我们了解了如何添加一些简单组件，现在我们将通过Tkinter的Entry类获取到用户输入。我们可以这样用Entry类创建一个文本框： txt = Entry(window, width=10) 然后可以用grid函数像之前那样添加到窗口中。 from tkinter import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") lbl = Label(window, text=\"Hello\") lbl.grid(column=0, row=0) txt = Entry(window, width=10) txt.grid(column=1, row=0) def clicked(): lbl.configure(text=\"Button was clicked!\") btn = Button(window, text=\"Click Me\", command=clicked) btn.grid(column=2, row=0) window.mainloop() 此时点击按钮，标签组件内的内容没有变化，如何将文本框中输入的信息在标签组件中显示呢？ 我们可以用get函数获取到文本框中输入的信息，然后如下更改clicked函数来设置窗口大小： def clicked(): res = \"Welcome to \" + txt.get() lbl.configure(text=res) 如果我们在文本框中输入信息并点击按钮组件，标签组件将会显示Welcome to 文本框输入信息 。 以下是完整代码： from tkinter import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") lbl = Label(window, text=\"Hello\") lbl.grid(column=0, row=0) txt = Entry(window, width=10) txt.grid(column=1, row=0) def clicked(): res = \"Welcome to \" + txt.get() lbl.configure(text=res) btn = Button(window, text=\"Click Me\", command=clicked) btn.grid(column=2, row=0) window.mainloop() 运行结果为： 但每次我们运行代码后，我们都需要通过点击文本框来设置输入焦点才能输入信息，有什么办法可以自动设置输入焦点吗？ ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:4:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r设置输入焦点很简单，我们只需要调用focus函数来设置窗口大小： txt.focus() 当我们运行代码后，会发现可以直接在文本框中输入信息而不需要点击文本框。 ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:4:1","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r添加一个组合框为了添加一个组合框，可以使用Combobox类： from tkinter.ttk import * combo = Combobox(window) 然后可以给组合框添加一些值。 from tkinter import * from tkinter.ttk import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") combo = Combobox(window) combo['values'] = (1,2,3,4,5,\"Text\") combo.current(1) combo.grid(column=0, row=0) window.mainloop() 如上所示，我们可以用元组设置组合框选项。 我们可以通过传递期望被选中选项的索引给current函数用以设置被选中的选项。 我们可以通过get函数获取到被选中的选项。 combo.get() ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:5:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r添加复选框我们可以用Checkbutton类来创建一个复选框组件： chk = Checkbutton(window, text=\"Choose\") 能通过传递值设置复选框的状态： from tkinter import * from tkinter.ttk import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") chk_state = BooleanVar() chk_state.set(True) # Set check state chk = Checkbutton(window, text=\"Choose\", var=chk_state) chk.grid(column=0, row=0) window.mainloop() 上例我们用的是BooleanVar变量用来设置复选框的状态，也可以使用IntVar变量进行设置。 chk_state = IntVar() chk_state.set(1) # Check chk_state.set(0) # Uncheck 结果和用BooleanVar一样。 ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:6:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r添加单选框添加单选框可以用Radiobutton类创建一个文本框： rad1 = Radiobutton(window, text=\"First\", value=1) 我们需要给每个单选框设置不同的值，否则会不起作用。 from tkinter import * from tkinter.ttk import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") rad1 = Radiobutton(window, text=\"First\", value=1) rad2 = Radiobutton(window, text=\"Second\", value=2) rad3 = Radiobutton(window, text=\"Third\", value=3) rad1.grid(column=0, row=0) rad2.grid(column=1, row=0) rad3.grid(column=2, row=0) window.mainloop() 当然，我们可以给这些单选框设置command参数指定一个函数，当用户点击它们时就会运行该函数。 rad1 = Radiobutton(window, text=\"First\", value=1, command=clicked) def clicked(): # Do what you need pass ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:7:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r获取单选框值为获取到选中单选框的值，我们可以将IntVar变量传给单选框的variable参数，之后用IntVar变量的get函数就可以获取到其值啦！ from tkinter import * from tkinter.ttk import * window = Tk() window.title(\"First Window\") selected = IntVar() lbl = Label(window, text=\"Show Value\") rad1 = Radiobutton(window, text=\"First\", value=1, variable=selected) rad2 = Radiobutton(window, text=\"Second\", value=2, variable=selected) rad3 = Radiobutton(window, text=\"Third\", value=3, variable=selected) def clicked(): lbl.configure(text=selected.get()) btn = Button(window, text=\"Click Me\", command=clicked) rad1.grid(column=0, row=0) rad2.grid(column=1, row=0) rad3.grid(column=2, row=0) btn.grid(column=4, row=0) lbl.grid(column=0, row=1) window.mainloop() 每次我们选中一个单选框，并点击按钮，标签框中就会显示其值： ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:7:1","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r添加文本区添加文本区可以用ScrolledText类创建一个文本框： from tkinter import scrolledtext txt = scrolledtext.ScrolledText(window, width=40, height=10) 我们需要指定一个文本区的宽度和高度，否则它会占住整个窗口： from tkinter import * from tkinter import scrolledtext window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") txt = scrolledtext.ScrolledText(window, width=40, height=10) txt.grid(column=0, row=0) window.mainloop() 用以下方法可以在文本区中插入文本： txt.insert(INSERT, \"Text goes here\") 用以下方法可以将文本区中的文本删除： txt.delete(1.0, END) ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:8:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r创建消息框我们可以按如下方式创建一个消息框： from tkinter import messagebox messagebox.showinfo(\"Message title\", \"Message content\") 我们创建一个按钮，当它被点击时显示一个消息框： from tkinter import * from tkinter import messagebox window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") def clicked(): messagebox.showinfo(\"Message title\", \"Message content\") btn = Button(window, text=\"Click here\", command=clicked) btn.grid(column=0, row=0) window.mainloop() ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:9:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r添加 SpinboxSpinbox是输入控件；与Entry类似，但是可以指定输入范围值。 spin = Spinbox(window, from_=0, to=100) 通过from_和to参数指定范围，也可以用width参数指定控件宽度。 from tkinter import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") spin = Spinbox(window, from_=0, to=100, width=5) spin.grid(column=0, row=0) window.mainloop() 也可以指定某些特定的值，而不是整个范围： from tkinter import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") spin = Spinbox(window, values=(3,8,11), width=5) spin.grid(column=0, row=0) window.mainloop() 这样，Spinbox控件就只会显示 3 个数字即 3，8，11。 可以用如下方式给Spinbox控件设置默认值： var = IntVar() var.set(36) spin = Spinbox(window, from_=0, to=100, width=5, textvariable=var) 运行代码就可以看到 36 作为Spinbox控件的默认值显示了。 ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:10:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r添加进度条我们可以用Progressbar类创建进度条： from tkinter.ttk import Progressbar bar = Progressbar(window, length=200) 设置一下进度条的值： bar['value'] = 70 改变进度条的颜色可以按如下步骤进行： from tkinter import * from tkinter.ttk import Progressbar from tkinter import ttk window = Tk() window.title(\"First Window\") window.geometry('350x200') style = ttk.Style() style.theme_use('default') style.configure(\"black.Horizontal.TProgressbar\", background='black') bar = Progressbar(window, length=200, style='black.Horizontal.TProgressbar') bar['value'] = 70 bar.grid(column=0, row=0) window.mainloop() ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:11:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r添加文件对话框我们可以按如下方式创建一个文件对话框： from tkinter import filedialog file = filedialog.askopenfilename() 当你选择一个文件并点击打开，file变量将会保存该文件的路径。 如果想一次选择多个文件并打开，我们可以用： files = filedialog.askopenfilenames() 用filetypes参数指定文件对话框的文件类型，只需在元组中指定扩展名即可。 file = filedialog.askopenfilename(filetypes = ((\"Text files\",\"*.txt\"),(\"all files\",\"*.*\"))) askdirectory函数可以让我们请求目录： dir = filedialog.askdirectory() 可以用initialdir参数指定打开的初始目录： from tkinter import * from tkinter import filedialog import os window = Tk() window.title(\"First Window\") window.geometry('350x200') def clicked(): file = filedialog.askopenfilenames(initialdir=os.path.dirname(__file__)) btn = Button(window, text=\"Click Me\", command=clicked) btn.grid(column=0, row=0) window.mainloop() ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:12:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r参考 https://likegeeks.com/python-gui-examples-tkinter-tutorial/ ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:13:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["OpenCV"],"content":"无论我们想要学习如何将面部识别应用于视频流，还是用深度学习构建图像分类器，或者做其他一些有关图像识别的有趣项目，可能都会需要学一些 OpenCV 的知识，本文将做简单介绍。 ","date":"2019-01-07","objectID":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:0","tags":["OpenCV","Python"],"title":"OpenCV简明教程","uri":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["OpenCV"],"content":"\r加载和显示图像 保存上面的图片，打开你最爱的编辑器，输入以下代码： import cv2 image = cv2.imread('demo.jpg') cv2.imshow('Image', image) cv2.waitKey() 第 3 行，使用cv2.imread()导入图像。 第 4 行，使用cv2.imshow()显示图像。窗口会自动调整为图像大小。第一个参数是窗口的名字，然后是我们的图像。 第 5 行，使用cv2.waitKey()等待键盘输入。 运行一下，结果如下所示： ","date":"2019-01-07","objectID":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:1:0","tags":["OpenCV","Python"],"title":"OpenCV简明教程","uri":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["OpenCV"],"content":"\r获取并修改像素值我们可以先查看一下图像的形状， print(image.shape) # (600,400,3) image.shape可以获取图像的形状。返回的是一个包含行数（高），列数（宽），通道数的元组。 可以根据像素的行、列坐标获取其像素值。对于 BGR 图像来说，返回值为 B，G，R 的值。对灰度图像来说，返回值为其灰度值。 B,G,R = image[320,15] print('B={}, G={}, R={}'.format(B,G,R)) # B=150, G=172, R=197 可以用类似的方式修改像素值， image[320,15] = [52,26,16] B,G,R = image[320,15] print('B={}, G={}, R={}'.format(B,G,R)) # B=52, G=26, R=16 ","date":"2019-01-07","objectID":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:2:0","tags":["OpenCV","Python"],"title":"OpenCV简明教程","uri":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["OpenCV"],"content":"\r图像 ROI有时我们需要对一幅图像的感兴趣的区域（Regions of Interest，ROI）进行操作。比如，我们要检测一幅图像中眼睛的位置，我们首先应该在图像中找到脸，再在脸的区域中找眼睛，而不是直接在一幅图像中搜素。ROI 也是通过索引获得，其实就相当于数组切片。 import cv2 image = cv2.imread('demo.jpg') head = image[27:124,159:260] image[200:297,299:400] = head cv2.imshow('New', image) cv2.waitKey() 结果如下： ","date":"2019-01-07","objectID":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:3:0","tags":["OpenCV","Python"],"title":"OpenCV简明教程","uri":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["OpenCV"],"content":"\r图像缩放OpenCV 提供的函数cv2.resize()可以改变图像的尺寸大小。 import cv2 image = cv2.imread('demo.jpg') resized = cv2.resize(image, (200,400)) cv2.imshow('Image', resized) cv2.waitKey() ","date":"2019-01-07","objectID":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:4:0","tags":["OpenCV","Python"],"title":"OpenCV简明教程","uri":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["OpenCV"],"content":"\r旋转图像 对一个图像旋转角度 $\\theta$，需要用到下面形式的旋转矩阵。 OpenCV 允许我们在任意地方进行旋转，于是旋转矩阵的形式应该改为： 其中： 为了构建这个旋转矩阵，OpenCV 提供了一个函数：cv2.getRotationMatrix2D()。 以下便是在不缩放的情况下将图像旋转 90 度。 import cv2 image = cv2.imread('demo1.jpg') rows,cols,depth = image.shape M = cv2.getRotationMatrix2D((rows // 2, cols // 2), 90, 1) dst = cv2.warpAffine(image,M,(cols,rows)) cv2.imshow('Image', dst) cv2.waitKey() 第 5 行，第一个参数为旋转中心，第二个参数为旋转角度，第三个为旋转后的缩放因子。 第 6 行，第三个参数是输出图像的尺寸。 ","date":"2019-01-07","objectID":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:5:0","tags":["OpenCV","Python"],"title":"OpenCV简明教程","uri":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["OpenCV"],"content":"\r图像模糊在许多的图像处理过程中，我们必须模糊图像以减少高频噪声，使算法更容易检测和理解图像的实际内容。在 OpenCV 中模糊图像非常容易，有很多方法可以用。 import cv2 image = cv2.imread('demo1.jpg') blurred = cv2.GaussianBlur(image, (11, 11), 0) cv2.imshow('Blurred', blurred) cv2.waitKey() 第 4 行，我们使用了高斯模糊，用了11 x 11的核。 较大的核会产生更模糊的图像，较小的核将产生没那么的模糊图像。 ","date":"2019-01-07","objectID":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:6:0","tags":["OpenCV","Python"],"title":"OpenCV简明教程","uri":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["OpenCV"],"content":"\r绘图函数本节我们将在导入的图像上画矩形，圆，线以及添加文字。但值得注意的是，这些操作会影响到原始导入的image，为了避免这样，我们可以用image的副本进行操作。 import cv2 image = cv2.imread('demo.jpg') output = image.copy() cv2.rectangle(output, (163, 30), (244, 124), (0, 0, 255), 2) cv2.imshow('Rectangle', output) cv2.waitKey() 第 5 行，设置的参数如下： img：想要绘制图像的那幅图像，这里是output。 pt1：矩形左上角坐标，这里是(163, 30)。 pt2：矩形右下角坐标，这里是(244, 124)。 color：BGR 元组，这里是红色(0,0,255)。 thickness：线条粗细（如果一个闭合图形设置为负数，那么这个图形就会被填充），这里是2。 结果如下： 接下来，我们在猫咪的图像上画一个圆。 import cv2 image = cv2.imread('demo1.jpg') output = image.copy() cv2.circle(output, (32, 25), 20, (255,0,0),-1) cv2.imshow('Circle', output) cv2.waitKey() 要画圆的话，需要指定圆形的圆心坐标和半径大小。 第 5 行，我们指定圆心为(35,25)，半径大小为20。其他参数含义，和画矩形时一样。 画线的话，我们只需要指定起点和终点即可。 import cv2 image = cv2.imread('demo1.jpg') output = image.copy() cv2.line(output, (35,25),(125,69),(255,0,0),5) cv2.imshow('Line', output) cv2.waitKey() 第 5 行，我们指定起点为(35,25)，终点为(125,69)。 结果如下： 我们可能经常需要在图像上添加文字，比如在进行人脸识别的时候，需要在人的脸上绘制出他们的名字。可以使用 OpenCV 的cv2.putText()函数在图像上添加文字。 import cv2 image = cv2.imread('demo.jpg') output = image.copy() cv2.putText(output, 'Sasaki Nozomi', (10, 25), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2) cv2.imshow('Text', output) cv2.waitKey() 第 5~6 行，设置的参数如下： img：想要绘制图像的那幅图像，这里是output。 text：要绘制的文字内容，这里是Sasaki Nozomi。 pt：绘制的位置，这里是(10,25)。 font：字体类型，这里是cv2.FONT_HERSHEY_SIMPLEX。 scale：字体大小乘数，这里是0.7。 color：字体颜色，这里是红色(0,0,255)。 thickness：字体粗细，这里是2。 如下图所示，“Sasaki Nozomi”绘制在图像上， ","date":"2019-01-07","objectID":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:7:0","tags":["OpenCV","Python"],"title":"OpenCV简明教程","uri":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["OpenCV"],"content":"\r参考 https://opencv-python-tutroals.readthedocs.io/en/latest/ https://www.pyimagesearch.com/2018/07/19/opencv-tutorial-a-guide-to-learn-opencv/ ","date":"2019-01-07","objectID":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:8:0","tags":["OpenCV","Python"],"title":"OpenCV简明教程","uri":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"}]