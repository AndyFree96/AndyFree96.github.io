[{"categories":null,"content":" 2024Stanford CS107 Programming Paradigms 编程范式 清华大学 操作系统 清华大学 经济学原理 耶鲁大学 聆听音乐 Machine Learning 2022 Spring Deep Learning for Human Language Processing 2020 Spring 6.824 Schedule: Spring 2022 ","date":"2024-02-25","objectID":"/opencourse/:1:0","tags":null,"title":"","uri":"/opencourse/"},{"categories":null,"content":" 2024","date":"2024-02-25","objectID":"/book/:1:0","tags":null,"title":"","uri":"/book/"},{"categories":null,"content":" 计算机JavaScript 高级程序设计 第 4 版 Unix\u0026Linux 大学教程 学习 JavaScript 数据结构与算法 第 3 版 Hands-on Machine Learning with Scikit-Learn, Keras \u0026 TensorFlow 2nd Edition 编写可读代码的艺术 ","date":"2024-02-25","objectID":"/book/:1:1","tags":null,"title":"","uri":"/book/"},{"categories":null,"content":" 文学红楼梦 金瓶梅 ","date":"2024-02-25","objectID":"/book/:1:2","tags":null,"title":"","uri":"/book/"},{"categories":null,"content":" 传记王安石传 毛泽东传 ","date":"2024-02-25","objectID":"/book/:1:3","tags":null,"title":"","uri":"/book/"},{"categories":null,"content":" 经济经济学原理 ","date":"2024-02-25","objectID":"/book/:1:4","tags":null,"title":"","uri":"/book/"},{"categories":null,"content":" 饮食一日一果 ","date":"2024-02-25","objectID":"/book/:1:5","tags":null,"title":"","uri":"/book/"},{"categories":null,"content":" 写作文心 ","date":"2024-02-25","objectID":"/book/:1:6","tags":null,"title":"","uri":"/book/"},{"categories":null,"content":" 哲学哲学家们都干了些什么 苏菲的世界 理想国 ","date":"2024-02-25","objectID":"/book/:1:7","tags":null,"title":"","uri":"/book/"},{"categories":null,"content":" 政治政治学通识 ","date":"2024-02-25","objectID":"/book/:1:8","tags":null,"title":"","uri":"/book/"},{"categories":null,"content":" 电影认识电影 ","date":"2024-02-25","objectID":"/book/:1:9","tags":null,"title":"","uri":"/book/"},{"categories":null,"content":" 历史明朝那些事儿 万历十五年 ","date":"2024-02-25","objectID":"/book/:1:10","tags":null,"title":"","uri":"/book/"},{"categories":null,"content":" 2024 # 标题 年份 论文 代码 状态 1 You Only Look Once: Unified, Real-Time Object Detection 2015 Link Link ❎ 2 YOLOv4: Optimal Speed and Accuracy of Object Detection 2020 Link Link ❎ 3 A Neural Algorithm of Artistic Style 2015 Link Link ❎ ","date":"2024-02-25","objectID":"/paper/:1:0","tags":null,"title":"","uri":"/paper/"},{"categories":null,"content":" 简介一个热爱学习的东尼君 ","date":"2024-02-25","objectID":"/about/:1:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":" 联系Twitter: @IRONAnthony96 微博: IRONAnthony 知乎: IRONAnthony 豆瓣: IRONAnthony 稀土掘金: AndyFree96 CSDN: AndyFree96 CodenPen: IRONAnthony CodeSandBox: AndyFree96 ","date":"2024-02-25","objectID":"/about/:2:0","tags":null,"title":"","uri":"/about/"},{"categories":["计算机网络"],"content":" 2023/1/17 更新: 增加进程间通信 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:0:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 理解网络编程和套接字","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 理解网络编程和套接字网络编程中接受连接请求的套接字创建过程如下: 调用socket函数创建套接字 调用bind函数分配 IP 地址和端口号 调用listen函数转为可接收请求和状态 调用accpet函数受理连接请求 客户端程序只有“调用 socket 函数创建套接字”和“调用 connect 函数向服务器发送连接请求”两个步骤。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:1","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 基于 Linux 的文件操作对 Linux 而言，socket 操作与文件操作没有区别，socket 被认为是文件的一种，因此在网络数据传输过程中自然可以使用文件 I/O 的相关函数。Windows 和 Linux 不同，区分二者。 文件描述符只不过是为了方便称呼操作系统创建的文件或套接字而赋予的数而已。文件描述符有时也称为句柄，但“句柄”主要是 Windows 中的术语。 在项目中，为了给基本数据类型赋予别名，一般会添加大量的typedef声明。为了与程序员定义的新数据类型加以区分，操作系统定义的数据类型会添加后缀_t，例如size_t、ssize_t等。 文件描述符从 3 开始由小到大顺序编号，因为 0、1、2 分配给标准 I/O 的描述符。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:2","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 基于 Windows 平台的实现Windows 套接字（简称 Winsock）大部分是参考 BSD 系列的 UNIX 套接字设计的。 为了在 Windows 基础上开发网络程序，需要做如下准备。 导入头文件winsock2.h 链接ws2_32.lib库 Winsock 编程时必须首先调用WSAStartup函数，设置程序中用到的 Winsock 版本，并初始化相应版本的库。 注销该库使用如下函数: ##include \u003ciostream\u003e ##include \u003cWinSock2.h\u003e int main() { WSADATA wsaData; if (WSAStartup(MAKEWORD(2, 2), \u0026wsaData) != 0) { std::cout \u003c\u003c \"WSAStartup ERROR!\" \u003c\u003c std::endl; } WSACleanup(); return 0; } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:3","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 套接字类型与协议设置协议是计算机对话使用的通信规则。 ##include \u003csys/socket.h\u003e int socket(int domain, int type, int protocol); // 成功返回文件描述符，失败时返回-1 domain套接字使用的协议族信息 type套接字数据传输类型信息 protocol计算机间通信中使用的协议信息 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 协议族套接字通信中的协议有一些分类，通过socket函数的第一个参数传递套接字中使用的协议分类信息。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:1","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 套接字类型套接字类型指的是套接字的数据传输方式，通过socket函数的第二个参数传递，只有这样才能决定创建的套接字的数据传输方式。为什么通过第一个参数传递了协议族信息，还要决定数据传输方式？这是因为决定了协议族并不能同时决定数据传输方式，换而言之，socket函数第一个参数PF_INET协议族中也存在多种数据传输方式。 面向连接的套接字（SOCK_STREAM）可靠的、按序传递的、基于字节的面向连接的数据传输方式的套接字。（传送带传输，收和发套接字都有缓存，多次write可能只需要一次read，即二者的次数可以不等，传输的数据不存在数据边界） 面向消息的套接字（SOCK_DGRAM）不可靠的、不按序传递的、以数据的高速传递为目的的套接字（摩托车传输，发一次得收一次，传输的数据存在数据边界）。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:2","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 协议的最终选择socket函数的前两个参数传递了协议族的信息和套接字数据传输方式，这些信息还不足以决定采用的协议吗？为什么还需要传递第 3 个参数？ 前两个参数即可创建所需套接字。所以大部分情况下可以向第三个参数传递 0，除非遇到以下情况: 同一个协议族中存在多个传输方式相同的协议 数据传输方式相同，但协议不同。此时需要通过第三个参数具体指定协议信息。 比如，创建“IPv4 协议族面向连接的套接字”。 参数PF_INET指 IPv4 网络协议族，SOCK_STREAM是面向连接的数据传输。满足这两个条的协议只有IPPROTO_TCP，这种套接字称为 TCP 套接字。 int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); 再比如，创建“IPv4 协议族面向消息的套接字”。 满足上述条件的协议只有IPPROTO_UDP，这种套接字称为 UDP 套接字。 int udp_socket = socket(PF_INET, SOCKET_STREAM, IPPROTO_UDP); ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:3","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 地址族与数据序列","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 分配给套接字的 IP 地址和端口号IP 是 Internet Protocol（网络协议）的简写，是为收发网络数据而分配给计算机的值。端口号并非赋予计算机的值，而是为区分程序中创建的套接字而分配给套接字的序号。 网络地址（Internet Address）为让计算机连接到网络并收发数据，需向其分配 IP 地址。IP 地址分为两类。 IPv4（Internet Protocol version 4） 4 字节地址族 IPv6（Internet Protocol version 6） 16 字节地址族 网络地址（网络 ID）是为区分网络而设置的一部分 IP 地址。传输数据时，并非一开始就浏览所有 4 字节 IP 地址，进而找到目标主机；而是仅浏览 4 字节 IP 地址的网络地址，向把数据传到网络。网络（构成网络的路由器（Router）或交换机（Switch））接到数据后，浏览传输数据的主机地址（主机 ID）并将数据传给目标计算机。 构建网络需要一种物理设备完成外网与本网主机之间的数据交换，这种设备便是路由器或交换机。它们也是一种计算机，只不过为了特殊目的而设计运行的，因而有了别名。我们可在自己的计算机中安装适当的软件，也可以将其作为交换机。交换机的功能比路由器简单一些，实际差别不大。 网络地址分类与主机地址边界只需通过 IP 地址的第一个字节即可判断网络地址占用的字节数: 用于区分套接字的端口号计算机中一般配有 NIC（Network Interface Card，网络接口卡）数据传输设备。通过 NIC 向计算机内部传输数据时会用到 IP。操作系统负责把传递到内部的数据适当分配给套接字，这时就要利用端口号。也就是说，通过 NIC 收到的数据内有端口号，操作系统参考此端口号把数据传输给相应端口的套接字。 端口号是在同意操作系统内为区分不同套接字而设置的，因此无法将一个端口号分配给不同套接字。端口号由 16 位构成，可分配的端口号范围是 0~65535。但 0~1023 是知名端口号（Wll-known PORT），一般分配给特定应用程序。TCP 套接字和 UDP 套接字不会公用端口号，所以允许重复。 数据传输目标地址同时包含 IP 地址和端口号，只有这样，数据才会被传输到最终的目的应用程序（应用程序套接字）。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:1","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 地址信息的表示 表示 IPv4 地址的结构体 struct sockaddr_in { sa_family_t sin_family; // 地址族(Address Family) uint16_t sin_port; // 16位TCP/UDP端口号 struct in_addr sin_addr; // 32位IP地址 char sin_zero[8]; // 不使用 } in_addr定义如下: struct in_addr { In_addr_t s_addr; // 32位IPv4地址 }; 结构体sockaddr_in的成员分析","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:2","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 网络字节序与地址转换 字节序（Order）与网络字节序CPU 向内存保存数据的方式有两种: 大端序（Big Endian）: 高位字节放到低位地址 小端序（Little Endian）: 高位字节放到高位地址 主流的 Intel 系列 CPU 以小端序方式保存数据。 在通过网络传输数据时约定统一的方式，称为网络字节序（Network Byte Order），非常简单——统一为大端序。即，先把数据数组转化为大端序格式再进行网络传输。 字节序转换（Endian Conversions） 除了向sockaddr_in结构体变量填充数据外，其他情况无需考虑字节序问题。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:3","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 网络地址的初始化与分配 将字符串信息转换为网络字节序的整数型使用inet_addr函数可以将字符串形式的 IP 地址转换为 32 为整型数据。 ##include\u003carpa/inet.h\u003e in_addr_t inet_addr(const char* string); // 成功返回32位大端序整型值，失败时返回INADDR_NONE。 char* inet_ntoa(struct in_addr adr); // 成功返回转换的字符串地址值，失败时返回-1 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:4","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 基于 TCP 的服务器端/客户端(1)","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 实现基于 TCP 的服务器端/客户端 TCP 服务器端的默认函数调用顺序 进入等待连接请求状态我们已调用bind函数给套接字分配了地址，接下来就要通过listen函数进入等待连接请求状态。只有调用了listen函数，客户端才能进入可发出连接请求的状态。这时客户端才能调用connect函数（若提前调用将发生错误）。 ##include \u003csys/socket.h\u003e int listen(int sock, int backlog); // 成功返回0，失败返回-1 // sock 希望进入等待连接状态的套接字文件描述符，传递的描述符套接字参数成为服务器端套接字（监听套接字） // backlog 连接请求等待队列的长度，若为5，则队列长度为5，表示最多使5个连接请求进入队列 受理客户端连接请求服务器端套接字是做门卫的。如果与客户端的数据交换使用门卫，那谁来守门呢？因此需要另外一个套接字，但没必要亲自创建。accpet函数将自动创建套接字，并连接到发起请求的客户端。 ##include \u003csys/socket.h\u003e int accpet(int sock, struct sockaddr* addr, socklen_t* addrlen); // 成功时返回创建的套接字文件描述符，失败返回-1 // sock 服务器套接字的文件描述符 // addr 保存发起连接请求的客户端地址信息的变量地址值，调用函数后向传递来的地址变量参数填充客户端地址信息 // addrlen 第二个参数addr结构体的长度，但是存有长度的变量地址。函数调用完成后，该变量即被填入客户端地址长度 TCP 客户端的默认函数调用顺序 服务器调用listen函数后创建连接请求等待队列，之后客户端即可请求连接。通过如下函数即可发起请求连接: ##include \u003csys/socket.h\u003e int connect(int sock, struct sockaddr* servaddr, socklen_t addrlen); // 成功时返回0，失败时返回-1 // sock 客户端套接字文件描述符 // servaddr 保存目标服务器端地址信息的变量地址值 // addrlen 以字节为单位传递已传递给第二个结构体参数servaddr的地址变量长度 客户端调用connect函数后，发生以下情况之一才会返回（完成函数调用）。 服务器端接收连接请求 发生断网等异常情况而中断连接请求 接收连接并不意味着服务器端调用accpet函数，其实是服务器端把连接请求信息记录到等待队列。因此connect函数返回后并不立即进行数据交换。 客户端套接字何时、何地、如何分配地址呢？调用connect函数时。操作系统，准确地说是在内核中。IP 用主机的 IP，端口随机。客户端的 IP 地址和端口在调用connect函数时自动分配，无需调用bind函数进行分配。 基于 TCP 和服务器端/客户端函数调用关系 服务器端创建套接字后连续调用bind和listen函数进入等待状态，客户端通过调用connect函数发起连接请求。客户端只能等到服务器端调用listen函数后才能调connect函数。客户端调用connect函数前，服务器端有可能率先调用accpet函数。此时服务器端在调用accpet函数时进入阻塞状态，直到客户端调用connect函数为止。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:1","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 实现迭代服务器端/客户端 实现迭代服务器端插入循环语句反复调用accept函数。 从上图可看出，调用accept函数后紧接着调用 I/O 相关的read和write函数，之后调用close函数。这并非针对服务器端套接字，而是针对accept函数调用时创建的套接字。 调用close函数就意味着结束了针对某一客户端的服务。此时如果还想服务于其他客户端，就要重新调用accpet函数。同一时刻只能服务于一个客户端，学完进程和线程后，就可以编写同时服务多个客户端的服务器了。 迭代回声服务器/客户端 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:2","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 基于 Windows 的实现 基于 Windows 的回声服务器端 ##include \u003ciostream\u003e ##include \u003ccstdlib\u003e ##include \u003ccstring\u003e ##include \u003cwinsock2.h\u003e ##include \u003ccstdio\u003e ##define BUF_SIZE 1024 void ErrorHandling(const char* message); int main(int argc, char* argv[]) { WSADATA wsaData; SOCKET hServerSocket, hClientSocket; char message[BUF_SIZE]; int strlen, i; int clientAddrSize; SOCKADDR_IN serverAddr, clientAddr; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } if (WSAStartup(MAKEWORD(2, 2), \u0026wsaData) != 0) ErrorHandling(\"WSAStartup() error!\"); hServerSocket = socket(PF_INET, SOCK_STREAM, 0); if (hServerSocket == INVALID_SOCKET) ErrorHandling(\"socket() error!\"); memset(\u0026serverAddr, 0, sizeof(serverAddr)); serverAddr.sin_family = AF_INET; serverAddr.sin_addr.s_addr = htonl(INADDR_ANY); serverAddr.sin_port = htons(atoi(argv[1])); if (bind(hServerSocket, (sockaddr*)\u0026serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) { ErrorHandling(\"bind() error!\"); } if (listen(hServerSocket, 5) == SOCKET_ERROR) { ErrorHandling(\"listen() error!\"); } clientAddrSize = sizeof(clientAddr); for (i = 0; i \u003c 5; i++) { hClientSocket = accept(hServerSocket, (sockaddr*)\u0026clientAddr, \u0026clientAddrSize); if (hClientSocket == -1) ErrorHandling(\"accept() error!\"); else std::cout \u003c\u003c \"Connected client \" \u003c\u003c i + 1 \u003c\u003c \"\\n\"; while ((strlen = recv(hClientSocket, message, BUF_SIZE, 0)) != 0) { send(hClientSocket, message, strlen, 0); } closesocket(hClientSocket); } closesocket(hServerSocket); WSACleanup(); return 0; } void ErrorHandling(const char* message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } 基于 Windows 的回声客户端 ##include \u003ciostream\u003e ##include \u003ccstdlib\u003e ##include \u003ccstring\u003e ##include \u003cwinSock2.h\u003e ##include \u003ccstdio\u003e ##pragma warning(disable:4996) ##define BUF_SIZE 1024 void ErrorHandling(const char* message); int main(int argc, char* argv[]) { WSADATA wsaData; SOCKET hSocket; char message[BUF_SIZE]; int strLen; SOCKADDR_IN serverAddr; if (argc != 3) { printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e\\n\", argv[0]); exit(1); } if (WSAStartup(MAKEWORD(2, 2), \u0026wsaData) != 0) ErrorHandling(\"WSAStartup() error!\"); hSocket = socket(PF_INET, SOCK_STREAM, 0); if (hSocket == INVALID_SOCKET) ErrorHandling(\"socket() error\"); memset(\u0026serverAddr, 0, sizeof(serverAddr)); serverAddr.sin_family = AF_INET; serverAddr.sin_addr.s_addr = inet_addr(argv[1]); serverAddr.sin_port = htons(atoi(argv[2])); if (connect(hSocket, (sockaddr*)\u0026serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) { ErrorHandling(\"connect() error!\"); } while (1) { fputs(\"Input message (Q to quit): \", stdout); fgets(message, BUF_SIZE, stdin); if (!strcmp(message, \"q\\n\") || !strcmp(message, \"Q\\n\")) break; send(hSocket, message, strlen(message), 0); strLen = recv(hSocket, message, BUF_SIZE - 1, 0); message[strLen] = 0; printf(\"Message from server : %s\", message); } closesocket(hSocket); WSACleanup(); return 0; } void ErrorHandling(const char* message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:3","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 基于 TCP 的服务器端/客户端(2)","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 回声客户端的完美实现 ##include \u003cstdio.h\u003e ##include \u003cstdlib.h\u003e ##include \u003cstring.h\u003e ##include \u003cunistd.h\u003e ##include \u003carpa/inet.h\u003e ##include \u003csys/socket.h\u003e ##define BUF_SIZE 1024 void error_handling(char *message); int main(int argc, char *argv[]) { int sock; char message[BUF_SIZE]; int str_len, recv_len, recv_cnt; struct sockaddr_in serv_addr; if (argc != 3) { printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e \\n\", argv[0]); exit(1); } sock = socket(PF_INET, SOCK_STREAM, 0); if (sock == -1) { error_handling(\"socket() error\"); } memset(\u0026serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = inet_addr(argv[1]); serv_addr.sin_port = htons(atoi(argv[2])); if (connect(sock, (struct sockaddr *)\u0026serv_addr, sizeof(serv_addr)) == -1) { error_handling(\"connect() error\"); } else { puts(\"connected....\"); } while (1) { fputs(\"Input message (Q to quit): \", stdout); fgets(message, BUF_SIZE, stdin); if (!strcmp(message, \"q\\n\") || !strcmp(message, \"Q\\n\")) { break; } str_len = write(sock, message, strlen(message)); recv_len = 0; while (recv_len \u003c str_len) { recv_cnt = read(sock, \u0026message[recv_len], BUF_SIZE - 1); if (recv_cnt == -1) { error_handling(\"read() error\"); } recv_len += recv_cnt; } message[recv_len] = 0; printf(\"Message from server : %s\", message); } close(sock); return 0; } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:1","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" TCP 原理 TCP 套接字中的 I/O 缓冲TCP 套接字的数据收发无边界。服务器端即使调用 1 次write函数传输 40 字节的数据，客户端也有可能通过 4 次read函数调用每次读取 10 字节。write函数调用后并非立即传输数据，read函数调用后也并非马上接收数据。write函数调用瞬间，数据将移至输出缓冲；read函数调用瞬间，从输入缓冲读取数据。 如上图所示，调用write函数时，数据将移到输出缓冲，在适当的时候（不管是分别传送还是一次性传送）传向对方的输入缓冲。这时对方将调用read函数从输入缓冲读取数据。这些 I/O 缓冲特性可整理如下。 I/O 缓冲在每个 TCP 套接字中单独存在 I/O 缓冲在创建套接字时自动生成 即使关闭套接字也会继续传递输出缓冲中遗留的数据 关闭套接字将丢失输入缓冲中的数据 不会发生超过输入缓冲大小的数据传输，因为 TCP 会控制数据流。TCP 中有滑动窗口（Sliding Window）协议。数据收发也是如此，TCP 不会因为缓冲溢出而丢失数据。 TCP 内部工作原理 1：与对方套接字的连接TCP 套接字从创建到消失分为以下 3 步。 与对方套接字建立连接 与对方套接字进行数据交换 断开与对方套接字的连接 连接过程中实际交换的信息格式如下: 该过程又称 Tree-way handhshaking（三次握手）。 TCP 内部工作原理 2：与对方主机的数据交换 ACK 号 -\u003e SEQ 号 + 传递字节数 + 1 TCP 内部工作原理 3：断开与套接字的连接 数据包内的 FIN 表示断开连接。即双方各发送 1 次 FIN 消息后断开连接。该过程经历了 4 个阶段，因此又称四次握手（Four-way handshaking）。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:2","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 基于 Windows 实现服务器端op_server.c ##include \u003ccstdio\u003e ##include \u003ccstdlib\u003e ##include \u003ciostream\u003e ##include \u003cWinSock2.h\u003e ##include \u003ccstring\u003e ##define BUF_SIZE 1024 ##define OPZS 4 void ErrorHandling(const char* message); int calculate(int opnum, int opnds[], char op); int main(int argc, char* argv[]) { WSADATA wsData; SOCKET serverSocket, clientSocket; SOCKADDR_IN serverAddr, clientAddr; char opinfo[BUF_SIZE]; int clientAddrSize, i; int result, opndCount; int recvCount, recvLen; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } if (WSAStartup(MAKEWORD(2, 2), \u0026wsData) != 0) ErrorHandling(\"WSAStartup() error!\"); serverSocket = socket(PF_INET, SOCK_STREAM, 0); if (serverSocket == INVALID_SOCKET) ErrorHandling(\"socket() error!\"); memset(\u0026serverAddr, 0, sizeof(serverAddr)); serverAddr.sin_family = PF_INET; serverAddr.sin_port = htons(atoi(argv[1])); serverAddr.sin_addr.s_addr = htonl(INADDR_ANY); if (bind(serverSocket, (SOCKADDR*)\u0026serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) ErrorHandling(\"bind() error!\"); if (listen(serverSocket, 5) == SOCKET_ERROR) ErrorHandling(\"listen() error!\"); clientAddrSize = sizeof(clientAddr); for (i = 0; i \u003c 5; i++) { opndCount = 0; clientSocket = accept(serverSocket, (SOCKADDR*)\u0026clientAddr, \u0026clientAddrSize); recv(clientSocket, (char*)\u0026opndCount, 1, 0); recvLen = 0; while ((opndCount * OPZS + 1) \u003e recvLen) { recvCount = recv(clientSocket, opinfo, BUF_SIZE - 1, 0); recvLen += recvCount; } result = calculate(opndCount, (int*)opinfo, opinfo[recvLen - 1]); send(clientSocket, (char*)\u0026result, sizeof(result), 0); closesocket(clientSocket); } closesocket(serverSocket); WSACleanup(); return 0; } void ErrorHandling(const char* message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } int calculate(int opnum, int opnds[], char op) { int result = opnds[0], i; switch (op) { case '+': for (i = 1; i \u003c opnum; i++) result += opnds[i]; break; case '-': for (i = 1; i \u003c opnum; i++) result -= opnds[i]; break; case '*': for (i = 1; i \u003c opnum; i++) result *= opnds[i]; break; } return result; } 客户端op_client.c ##include \u003ciostream\u003e ##include \u003cWinSock2.h\u003e ##include \u003ccstdlib\u003e ##include \u003ccstdio\u003e ##pragma warning(disable:4996) ##define BUF_SIZE 1024 ##define RLT_SIZE 4 ##define OPSZ 4 void ErrorHandling(const char* message); int main(int argc, char* argv[]) { WSADATA wsData; SOCKET hSocket; char opmsg[BUF_SIZE]; int result, opndCount, i; SOCKADDR_IN serverAddr; if (argc != 3) { printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e\\n\", argv[0]); exit(1); } if (WSAStartup(MAKEWORD(2, 2), \u0026wsData) != 0) { ErrorHandling(\"WSAStartup() error!\"); } hSocket = socket(PF_INET, SOCK_STREAM, 0); if (hSocket == INVALID_SOCKET) ErrorHandling(\"socket() error!\"); memset(\u0026serverAddr, 0, sizeof(serverAddr)); serverAddr.sin_addr.s_addr = inet_addr(argv[1]); serverAddr.sin_family = AF_INET; serverAddr.sin_port = htons(atoi(argv[2])); if (connect(hSocket, (SOCKADDR*)\u0026serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) ErrorHandling(\"socket() error!\"); else puts(\"Connected ......\"); fputs(\"Operand count : \", stdout); scanf(\"%d\", \u0026opndCount); opmsg[0] = (char)opndCount; for (i = 0; i \u003c opndCount; i++) { printf(\"Operand %d : \", i + 1); scanf(\"%d\", (int*)\u0026opmsg[i * OPSZ + 1]); } fgetc(stdin); fputs(\"Operator : \", stdout); scanf(\"%c\", \u0026opmsg[opndCount * OPSZ + 1]); send(hSocket, opmsg, opndCount * OPSZ + 2, 0); recv(hSocket, (char*)\u0026result, RLT_SIZE, 0); printf(\"Operation result : %d \\n\", result); closesocket(hSocket); WSACleanup(); return 0; } void ErrorHandling(const char* message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:3","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 推荐File Transfer using TCP Socket in C: https://idiotdeveloper.com/file-transfer-using-tcp-socket-in-c/ ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:4","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 基于 UDP 的服务器端/客户端","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:6:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 理解 UDP UDP 内部工作原理 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:6:1","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 实现基于 UDP 的服务器端/客户端 UDP 中的服务器端和客户端没有连接UDP 服务器端和客户端不像 TCP 那样在连接状态下交换数据，因此与 TCP 不同，无需经过连接过程。即，不必调用 TCP 连接过程中调用的listen函数和accept函数。UDP 中只有创建套接字的过程和数据交换过程。 UDP 服务器端和客户端均只需 1 个套接字TCP 中，套接字之间应该是一对一的关系。若要向 10 个客户端提供服务，则除了守门的服务器套接字外，还需要 10 个服务器端套接字。但在 UDP 中，不管是服务器端还是客户端都只需要 1 个套接字。 只需 1 个 UDP 套接字就可以向任意主机传输数据（类似收发信件的邮筒）。只需 1 个 UDP 套接字就能和多台主机通信。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:6:2","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 基于 Windows 实现 ##include \u003cwinsock2.h\u003e int sendto(SOCKET s, const char* buf, int len, int flags, const struct sockaddr* to, int tolen); // 成功返回传输的字节数，失败返回SOCKET_ERROR int recvfrom(SOCKET s, char* buf, int len, int flag, struct sockaddr* from, int* fromlen); // 成功返回接收的字节数，失败返回SOCKET_ERROR ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:6:3","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 优雅地断开套接字连接","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:7:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 基于 TCP 的半关闭 套接字和流（Stream）两台主机通过套接字建立连接后进入可交换数据的状态，又称“流形成的状态”。也就是把建立套接字后可交换数据的状态看作一种流。此处的流可以比作水流。水朝着一个方向流动，同样，在套接字的流中，数据也只能向一个方向流动。为了进行双向通信，就需要如下图所示的 2 个流。 一旦两台主机建立了套接字连接，每个主机机会拥有单独的输入流和输出流。其中一个主机的输入流与一台主机的输出流相连，而输出流则与另一主机的输入流相连。优雅地断开连接方式指的是只断开其中一个流，而非同时断开两个流。Linux 的close和 Windows 的closesocket函数将同时断开这两个流，因此不够优雅。 针对优雅断开的shutdown函数shutdown函数可以用来关闭其中 1 个流。 ##include \u003csys/socket.h\u003e int shutdown(int sock, int howto); // 成功返回0，失败返回-1 调用上述函数时，第二个参数决定断开连接的方式，其可能值如下: SHUT_RD: 断开输入流 SHUT_WR: 断开输出流 SHUT_RDWR: 同时断开 I/O 流 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:7:1","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 基于 Windows 的实现Windows 平台调用的shutdown函数传递的参数略有不同。 ##include \u003cwinsock2.h\u003e int shutdown(SOCKET sock, int howto); // 成功返回0，失败返回SOCKET_ERROR // sock 要断开的套接字句柄 // howto 断开方式的信息 调用上述函数时，第二个参数的可能值如下: SD_RECEIVE: 断开输入流 SD_SEND: 断开输出流 SD_BOTH: 同时断开 I/O 流 服务器端file_server_win.cpp: ##include \u003cWinSock2.h\u003e ##include \u003ccstdio\u003e ##include \u003ccstdlib\u003e ##pragma warning(disable:4996) ##define BUF_SIZE 30 void ErrorHandling(const char* message); int main(int argc, char* argv[]) { WSADATA wsaData; SOCKET serverSocket, clientSocket; FILE* fp; char buf[BUF_SIZE]; int readCount; SOCKADDR_IN serverAddr, clientAddr; int clientAddrSize; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } if (WSAStartup(MAKEWORD(2, 2), \u0026wsaData) != 0) ErrorHandling(\"WSAStartup() error!\"); fp = fopen(\"file_server_win.cpp\", \"rb\"); serverSocket = socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serverAddr, 0, sizeof(serverAddr)); serverAddr.sin_family = AF_INET; serverAddr.sin_addr.s_addr = htonl(INADDR_ANY); serverAddr.sin_port = htons(atoi(argv[1])); bind(serverSocket, (SOCKADDR*)\u0026serverAddr, sizeof(serverAddr)); listen(serverSocket, 5); clientAddrSize = sizeof(clientAddr); clientSocket = accept(serverSocket, (SOCKADDR*)\u0026clientAddr, \u0026clientAddrSize); while (true) { readCount = fread((void*)buf, 1, BUF_SIZE, fp); if (readCount \u003c BUF_SIZE) { send(clientSocket, (char*)\u0026buf, readCount, 0); break; } send(clientSocket, (char*)\u0026buf, BUF_SIZE, 0); } shutdown(clientSocket, SD_SEND); recv(clientSocket, (char*)buf, BUF_SIZE, 0); printf(\"Message from client : %s \\n\", buf); fclose(fp); closesocket(clientSocket); closesocket(serverSocket); WSACleanup(); return 0; } void ErrorHandling(const char* message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } 客户端file_client_win.cpp: ##include \u003ciostream\u003e ##include \u003cWinSock2.h\u003e ##include \u003ccstdlib\u003e ##include \u003ccstdio\u003e ##pragma warning(disable:4996) ##define BUF_SIZE 30 void ErrorHandling(const char* message); int main(int argc, char* argv[]) { WSADATA wsData; SOCKET hSocket; char buf[BUF_SIZE]; int readCount; SOCKADDR_IN serverAddr; FILE* fp; if (argc != 3) { printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e\\n\", argv[0]); exit(1); } if (WSAStartup(MAKEWORD(2, 2), \u0026wsData) != 0) { ErrorHandling(\"WSAStartup() error!\"); } fp = fopen(\"receive.dat\", \"wb\"); hSocket = socket(PF_INET, SOCK_STREAM, 0); if (hSocket == INVALID_SOCKET) ErrorHandling(\"socket() error!\"); memset(\u0026serverAddr, 0, sizeof(serverAddr)); serverAddr.sin_addr.s_addr = inet_addr(argv[1]); serverAddr.sin_family = AF_INET; serverAddr.sin_port = htons(atoi(argv[2])); if (connect(hSocket, (SOCKADDR*)\u0026serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) ErrorHandling(\"socket() error!\"); else puts(\"Connected ......\"); while ((readCount = recv(hSocket, buf, BUF_SIZE, 0)) != 0) { fwrite((void*)buf, 1, readCount, fp); } puts(\"Received file data\"); send(hSocket, \"Thank you\", 10, 0); fclose(fp); closesocket(hSocket); WSACleanup(); return 0; } void ErrorHandling(const char* message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:7:2","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 域名及网络地址","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:8:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 套接字的多种可选项","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:9:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 多进程服务器端","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 进程概念及应用 并发服务器的的实现方法 多进程服务器: 通过创建多个进程提供服务 多路复用服务器: 通过绑定并统一管理 I/O 对象提供服务 多线程服务器: 通过生成与客户端等量的线程提供服务 第一种方法: 多进程服务器。不适合在 Windows 平台下（Windows 不支持），因此将重点放在 Linux 平台。 理解进程（Process）定义如下: 占用内存空间的正在运行的程序 进程 ID无论进程是如何创建的，所有进程都会从操作系统分配到 ID。此 ID 称为进程 ID，其值为大于 2 的整数。1 要分配给操作系统启动后（用于协助操作系统）首个进程，因此用户进程无法得到 ID 值 1。 通过 ps 命令可以查看当前运行的所有进程。 通过调用 fork 函数创建进程 ##include \u003cunistd.h\u003e pid_t fork(void); // 成功返回进程ID，失败返回-1 fork函数将创建调用的进程副本。即并非根据完全不同的程序创建进程，而是复制正在运行的、调用fork函数的进程。两个进程都将执行fork函数调用后的语句（准确说是在fork函数返回后）。但因为通过同一个进程、复制相同的内存空间，之后的程序流要根据fork函数的返回值加以区分。fork函数的特点如下: 父进程: fork函数返回子进程 ID 子进程: fork函数返回 0 这里的父进程（Parent Process）指的是原进程，即调用fork函数的主体，而子进程（Child Process）是通过父进程调用fork函数复制出的进程。 从上图可以看到，父进程调用fork函数的同时复制出子进程，并分别得到fork函数的返回值。在父进程和子进程中gval和lval互不影响。因此fork函数调用后分成了完全不同的进程，只是二者共享同一代码而已。 ##include \u003cstdio.h\u003e ##include \u003cunistd.h\u003e int gval = 10; int main(int argc, char* argv[]){ pid_t pid; int lval = 20; gval++, lval+=5; pid = fork(); if (pid == 0) gval += 2, lval += 2; else gval -= 2, lval -= 2; if (pid == 0) printf(\"Child Proc : [%d, %d] \\n\", gval, lval); else printf(\"Parent Proc : [%d, %d] \\n\", gval, lval); return 0; } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:1","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 进程和僵尸进程进程销毁和进程创建同等重要。如果未认真进程销毁，它们将变成僵尸进程。 僵尸（Zombie）进程进程完成工作后（执行完main函数中的程序后）应被销毁，但有时这些进程将变成僵尸进程，占用系统中的重要资源。这种状态下的进程称作“僵尸进程”，也是给系统带来负担的原因之一。 产生僵尸进程的原因调用fork函数产生子进程的终止方式: 传递参数并调用exit函数 main函数中执行return语句并返回值 向exit函数传递的参数值和main函数的return语句返回的值都会传递给操作系统。而操作系统不会销毁子进程，直到把这些值传递给产生该子进程的父进程。处在这种状态下的进程就是僵尸进，将子进程变成僵尸进程的正是操作系统。那么如何销毁僵尸进程呢？向父进程传递exit函数的参数值或return的返回值即可。如何向父进程传递这些值呢？操作系统不会主动传递给父进程，只有父进程主动发起请求（函数调用）时，操作系统才会传递该值。换言之，如果父进程未主动要求获得子进程的结束状态值，操作系统将一直保存，并让子进程长时间处于僵尸进程状态。 ##include \u003cstdio.h\u003e ##include \u003cunistd.h\u003e int main(int argc, char* argv[]){ pid_t pid = fork(); if (pid == 0) puts(\"Child Process\"); else { printf(\"Child Process ID : %d \\n\", pid); sleep(30); // Sleep 30 sec } if (pid == 0) puts(\"End Child Process\"); else puts(\"End Parent Process\"); return 0; } 销毁僵尸进程 1：利用 wait 函数为了销毁子进程，父进程应主动请求获取子进程的返回值。发起请求的方法有两种，其中之一就是调用如下函数。 ##include \u003csys/wait.h\u003e pid_t wait(int* statloc); // 成功返回终止的子进程ID，失败返回-1 调用此函数时如果已有子进程终止，那么子进程终止时传递的返回值（exit函数的参数值、main函数的return返回值）将保存到该函数的参数所指内存空间。但函数参数指向的单元中还包含其他信息，因此需要通过下列宏进行分离。 WIFEXITED子进程正常终止时返回真（True） WEXITSTATUS返回子进程的返回值 向wait函数传递变量status的地址时，调用wait函数后应编写如下代码: if (WIFEXITED(status)) // 是正常终止吗？ { puts(\"Normal termination!\"); printf(\"Child pass num: %d\", WEXITSTATUS(status)); // 返回值是多少？ } 根据上述内容编写示例，此示例不会再让子进程变成僵尸进程。 ##include \u003cstdio.h\u003e ##include \u003cstdlib.h\u003e ##include \u003cunistd.h\u003e ##include \u003csys/wait.h\u003e int main(int argc, char* argv[]){ int status; pid_t pid = fork(); if (pid == 0) { return 3; } else { printf(\"Child PID %d \\n\", pid); pid = fork(); if (pid == 0) { exit(7); } else { printf(\"Child PID %d \\n\", pid); wait(\u0026status); if (WIFEXITED(status)){ printf(\"Child send one : %d\\n\", WEXITSTATUS(status)); } wait(\u0026status); if (WIFEXITED(status)){ printf(\"Child send two : %d\\n\", WEXITSTATUS(status)); } sleep(30); } } return 0; } 调用wait函数时，如果没有已终止的子进程，那么程序将阻塞（Blocking）直到有子进程终止，因此需谨慎调用该函数。 销毁僵尸进程 2：使用 waitpid 函数wait函数会引起程序阻塞，可以考虑调用waitpid函数。这是防止僵尸进程的第二种方法，也是防止阻塞的方法。 ##include \u003csys/wait.h\u003e pid_t waitpid(pid_t pid, int* statloc, int options); // 成功返回终止的子进程ID（或0），失败返回-1 // pid 等待终止的目标子进程ID，若传递-1，则与wait函数相同，可以等待任意子进程终止 // statloc 与wait函数的statloc参数具有相同含义 // options 传递头文件sys/wait.h中声明的常量WNOHANG，即使没有终止的子进程也不会进入阻塞状态，而是返回0并退出函数 示例如下: ##include \u003cstdio.h\u003e ##include \u003cstdlib.h\u003e ##include \u003cunistd.h\u003e ##include \u003csys/wait.h\u003e int main(int argc, char *argv[]) { int status; pid_t pid = fork(); if (pid == 0) { sleep(15); return 24; } else { while (!waitpid(-1, \u0026status, WNOHANG)) { sleep(3); puts(\"Sleep 3sec.\"); } if (WIFEXITED(status)) { printf(\"Child send %d \\n\", WEXITSTATUS(status)); } } return 0; } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:2","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 信号处理我们已经直到子进程的创建及销毁方法，但还有一个问题没解决。 子进程究竟何时终止？调用waitpid函数后要无休止地等待吗？ 父进程往往与子进程一样繁忙，因此不能只调用waitpid函数以等待子进程终止。 向操作系统求助子进程终止的识别主体是操作系统。如果操作系统能把子进程终止的消息告诉正忙于工作的父进程，将有助于构建高效的程序。 此时父进程暂时放下工作，处理子进程终止相关事宜。为了实现该想法，引入信号处理（Signal Handling）机制。此处的“信号”是在特定时间发生时由操作系统向进程发送的消息。为了响应该消息，执行与消息相关的自定义操作的过程“处理”或“信号处理”。 信号与 signal 函数信号注册函数，请求操作系统当子进程结束时调用某函数。 ##include \u003csignal\u003e void (*signal(int signo, void(*func)(int)))(int) 上述函数的返回值类型为函数指针。第一个参数为特殊情况信息，第二个参数为特殊情况下将要调用的函数的地址值（指针）。发生第一个参数代表的情况时，调用第二个参数所指的函数。可以在signal函数中注册的部分特殊情况和对应常数如下: SIGALRM: 已到通过调用alarm函数注册的时间 SIGNIT: 输入CTRL + C SIGCHLD: 子进程终止 比如，编写调用signal函数完成“子进程终止则调用 myChild 函数”的请求，语句如下: signal(SIGCHILD, myChild); 以上就是信号注册过程。注册好信号后，发生注册信号时（注册的情况发生时），操作系统将调用该信号对应的函数。 先介绍alarm函数。 ##include \u003cunistd.h\u003e unsigned int alarm(unsigned int seconds); // 返回0或者以秒为单位的距SIGALRM信号发生所剩时间 如果调用该函数的同时向它传递一个正整型函数，相应时间后（以秒为单位）将产生 SIGALRM 信息。若向该函数传递 0，则之前对 SIGALRM 信号预约将取消。如果通过该函数预约信号后为指定该信号对应的处理函数，则（通过调用signal函数）终止进程，不做任何处理。 示例如下: ##include \u003csignal.h\u003e ##include \u003cunistd.h\u003e ##include \u003cstdio.h\u003e void timeout(int sig) { if (sig == SIGALRM) puts(\"Time out!\"); alarm(2); } void keycontrol(int sig) { if (sig == SIGINT) puts(\"CTRL + C pressed\"); } int main(int argc, char *argv[]) { int i; signal(SIGALRM, timeout); signal(SIGINT, keycontrol); alarm(2); for (i = 0; i \u003c 3; i++) { puts(\"wait...\"); sleep(100); } return 0; } 发生信号时将唤醒由于调用sleep函数而进入阻塞状态的进程。调用函数的主体是操作系统，但进程处于睡眠状态无法调用函数。因此，产生信号时，为了调用信号处理器 ，将唤醒由于调用sleep函数而进入阻塞状态的进程。而且，进程一旦被唤醒，就不会再进入睡眠状态。即使还未到sleep函数中规定的时间也如此。所以上述示例运行不到 10 秒就会结束，连续输入CTRL + C可能 1 秒都不到。 利用 sigaction 函数进行信号处理sigaction函数类似于signal函数，且完全可以代替它，也更稳定。稳定的原因是signal函数在 UNIX 系列的不同操作系统中可能存在区别，但sigaction函数完全相同。 ##include \u003csignal.h\u003e int sigaction(int signo, const struct sigaction* act, struct sigaction* oldact); // 成功时返回0，失败时返回-1 // signo 与signal函数相同，传递信号信息 // act 对于与第一个参数的信号处理函数（信号处理器）信息 // oldact 通过参数获取之前注册的信号处理函数指针，若不需要则传递0 声明并初始化sigaction结构体变量以调用上述函数，该结构体定义如下: 结构体的sa_handler成员保存信号处理函数的指针值（地址值）。 示例如下: ##include \u003csignal.h\u003e ##include \u003cstdio.h\u003e ##include \u003cunistd.h\u003e void timeout(int sig) { if (sig == SIGALRM) { puts(\"Time out!\"); } alarm(2); } int main(int argc, char *argv[]) { int i; struct sigaction act; act.sa_handler = timeout; sigemptyset(\u0026act.sa_mask); act.sa_flags = 0; sigaction(SIGALRM, \u0026act, 0); alarm(2); for (i = 0; i \u003c 3; i++) { puts(\"wait...\"); sleep(100); } return 0; } 利用信号处理技术消灭僵尸进程进程终止时将产生SIGCHLD信号。 ##include \u003cstdio.h\u003e ##include \u003cstdlib.h\u003e ##include \u003cunistd.h\u003e ##include \u003csignal.h\u003e ##include \u003csys/wait.h\u003e void read_childproc(int sig) { int status; pid_t pid = waitpid(-1, \u0026status, WNOHANG); if (WIFEXITED(status)) { printf(\"Removed proc id : %d\\n\", pid); printf(\"Child send : %d \\n\", WEXITSTATUS(status)); } } int main(int argc, char *argv[]) { pid_t pid; struct sigaction act; act.sa_handler = read_childproc; sigemptyset(\u0026act.sa_mask); act.sa_flags = 0; sigaction(SIGCHLD, \u0026act, 0); pid = fork(); if (pid == 0) // 子进程执行区域 { puts(\"Hi! I am child process\"); sleep(10); return 12; } else // 父进程执行区域 { printf(\"Child proc is : %d\\n\", pid); pid = fork(); if (pid == 0) // 另一子进程执行区域 { puts(\"Hi! I am child process\"); sleep(10); exit(24); } else { int i; printf(\"Child proc is : %d\\n\", pid); for (i = 0; i \u003c 5; i++) { puts(\"wait...\"); sleep(5); } } } return 0; } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:3","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 基于多任务的并发服务器 基于进程的并发服务器模型此前的回声服务器端每次都只能向一个客户端提供服务。因此，我们可以扩展回声服务器端，使其可以同时向国歌客户端提供服务，实现模型如下。 每当有客户端请求服务（连接请求）时，回声服务器都创建子进程以提供服务。请求服务的客户端若有 5 个，则将创建 5 个子进程提供服务。过程如下: 第一阶段：回声服务器端（父进程）通过调用accept函数受理连接请求 第二阶段：此时获取的套接字文件描述符创建并传递给子进程 第三阶段：子进程利用传递来的文件描述符提供服务 子进程会复制父进程拥有的所有资源，实际上根本不哦那个另外传递文件描述符的过程。 实现并发服务器 // echo_mpserv.c ##include \u003cstdio.h\u003e ##include \u003cstdlib.h\u003e ##include \u003cstring.h\u003e ##include \u003cunistd.h\u003e ##include \u003csignal.h\u003e ##include \u003csys/wait.h\u003e ##include \u003carpa/inet.h\u003e ##include \u003csys/socket.h\u003e ##define BUF_SIZE 30 void error_handling(char *message); void read_childproc(int sig); int main(int argc, char *argv[]) { int serv_sock, clnt_sock; struct sockaddr_in serv_adr, clnt_adr; pid_t pid; struct sigaction act; socklen_t adr_sz; int str_len, state; char buf[BUF_SIZE]; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } act.sa_handler = read_childproc; sigemptyset(\u0026act.sa_mask); act.sa_flags = 0; state = sigaction(SIGCHLD, \u0026act, 0); serv_sock = socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family = AF_INET; serv_adr.sin_addr.s_addr = htonl(INADDR_ANY); serv_adr.sin_port = htons(atoi(argv[1])); if (bind(serv_sock, (struct sockaddr *)\u0026serv_adr, sizeof(serv_adr)) == -1) { error_handling(\"bind() error\"); } if (listen(serv_sock, 5) == -1) { error_handling(\"listen() error\"); } while (1) { adr_sz = sizeof(clnt_adr); clnt_sock = accept(serv_sock, (struct sockaddr *)\u0026clnt_adr, \u0026adr_sz); if (clnt_sock == -1) { continue; } else { puts(\"new client connected...\"); } pid = fork(); if (pid == -1) { close(clnt_sock); continue; } if (pid == 0) // 子进程运行区域 { close(serv_sock); while ((str_len = read(clnt_sock, buf, BUF_SIZE)) != 0) { write(clnt_sock, buf, str_len); } close(clnt_sock); puts(\"client disconnected...\"); return 0; } else { close(clnt_sock); } } close(serv_sock); return 0; } void read_childproc(int sig) { pid_t pid; int status; pid = waitpid(-1, \u0026status, WNOHANG); printf(\"removed proc id %d \\n\", pid); } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } 启动服务器后，可以发现服务器可以向多个客户端提供服务。 通过 fork 函数复制文件描述符echo_mpserv.c中父进程将 2 个套接字（一个服务器端套接字，一个是与客户端连接的套接字）文件描述符复制给子进程。 只复制文件描述符吗？是否也复制了套接字？ 调用fork函数时复制父进程的所有资源，但套接字并非进程所有——严格意义上说，套接字属于操作系统——只是进程拥有代表相应套接字的文件描述符。 调用fork函数后，2 个文件描述符指向同一套接字。 1 个套接字中存在 2 个文件描述符时，只有 2 个文件描述符都终止（销毁）后，才能销毁套接字。如果维持上图中的连接状态，即使子进程销毁了与客户端连接的套接字文件描述符，也无法完全销毁套接字（服务器端套接字同样如此）。因此，调用fork函数后，要将无关的套接字文件描述符关掉，如下图所示。 为了将文件描述符整理成上图形式，echo_mpserv.c调用了close函数。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:4","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 分割 TCP 的 I/O 程序 分割 I/O 程序的优点已经实现的回声客户端的数据回声方式如下： 向服务器端传输数据，并等待服务器端回复。无条件等待，直到接受完服务器端的回声数据后，才能传输下一批数据。 传输数据后需等待服务器端返回的数据，因为程序代码中重复调用了read和write函数。这么写的原因是，程序在 1 个进程中运行。现在可创建多个进程，因此可以分割数据收发过程。分割模型如下: 如此实现的一个重要原因是程序实现更简单。父进程中只需编写接收数据的代码，子进程中只需编写发送数据的代码，所以会简化。 另一个好处是可以提高频繁交换数据的性能。 分割 I/O 后的客户端发送数据时不必考虑接收数据的情况，因此可以连续发送数据，由此提高同一时间内传输的数据量。这种差异在网络较慢时尤为明显。 回声客户端的 I/O 程序分割 // echo_mpclient.c ##include \u003cstdio.h\u003e ##include \u003cstdlib.h\u003e ##include \u003cstring.h\u003e ##include \u003cunistd.h\u003e ##include \u003carpa/inet.h\u003e ##include \u003csys/socket.h\u003e ##define BUF_SIZE 30 void error_handling(char *message); void read_routine(int sock, char *buf); void write_routine(int sock, char *buf); int main(int argc, char *argv[]) { int sock; char buf[BUF_SIZE]; pid_t pid; struct sockaddr_in serv_addr; if (argc != 3) { printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e \\n\", argv[0]); exit(1); } sock = socket(PF_INET, SOCK_STREAM, 0); if (sock == -1) { error_handling(\"socket() error\"); } memset(\u0026serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = inet_addr(argv[1]); serv_addr.sin_port = htons(atoi(argv[2])); if (connect(sock, (struct sockaddr *)\u0026serv_addr, sizeof(serv_addr)) == -1) { error_handling(\"connect() error\"); } else { puts(\"connected....\"); } pid = fork(); if (pid == 0) { write_routine(sock, buf); } else { read_routine(sock, buf); } close(sock); return 0; } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } void read_routine(int sock, char *buf) { while (1) { int str_len = read(sock, buf, BUF_SIZE); if (str_len == 0) { return; } buf[str_len] = 0; printf(\"Message from server : %s\", buf); } } void write_routine(int sock, char *buf) { while (1) { fgets(buf, BUF_SIZE, stdin); if (!strcmp(buf, \"q\\n\") || !strcmp(buf, \"Q\\n\")) { shutdown(sock, SHUT_WR); return; } write(sock, buf, strlen(buf)); } } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:5","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 进程间通信","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:11:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 进程间通信的基本概念进程间通信（Inter Process Communication）意味着两个不同进程间可以交换数据，为了完成这一点，操作系统中应提供两个进程可以同时访问的内存空间。 对进程通信的基本理解只要有两个进程可以同时访问的内存空间，就可以通过此空间交换数据。但进程具有完全独立的内存结构。连通过fork函数创建的子进程也不会与父进程共享内存空间。因此，进程间通信只能通过其他特殊方法完成。 通过管道实现进程间通信 为了完成进程间通信，需要创建管道。管道并非属于进程的资源，而是和套接字一样，属于操作系统（也就不是fork函数的复制对象）。所以，两个进程通过操作系统提供的内存空间进行通信。创建管道的函数如下: ##include \u003cunistd.h\u003e int pipe(int filedes[2]); // 成功返回0，失败返回-1 // filedes[0] 通过管道接收数据时使用的文件描述符，即管道出口 // filedes[1] 通过管道传输数据时使用的文件描述符，即管道入口 以长度为 2 的 int 数组地址值作为参数调用上述函数时，数组中存有两个文件描述符，它们将被用作管道的出口和入口。父进程调用该函数时将创建管道，同时获取对应于出入口的文件描述符，此时父进程可以读写同一管道。由于父进程的目的是与子进程进行数据交换，因此需要将入口或出口中的 1 个文件描述符传递给子进程。 // pipe1.c ##include \u003cstdio.h\u003e ##include \u003cunistd.h\u003e ##define BUF_SIZE 30 int main(int argc, char *argv[]) { int fds[2]; char str[] = \"Who are you?\"; char buf[BUF_SIZE]; pid_t pid; pipe(fds); pid = fork(); if (pid == 0) { write(fds[1], str, sizeof(str)); } else { read(fds[0], buf, BUF_SIZE); puts(buf); } return 0; } 上例中的通信方法如下。父子进程都可以访问管道 I/O 路径，但子进程仅用输入路径，父进程仅用输出路径。 通过管道进程进程间双向通信创建 2 个进程通过 1 个管道进程双向数据交换，通信方式如下: // pipe2.c ##include \u003cstdio.h\u003e ##include \u003cunistd.h\u003e ##define BUF_SIZE 30 int main(int argc, char *argv[]) { int fds[2]; char str1[] = \"Who are you?\"; char str2[] = \"Thank you for your message\"; char buf[BUF_SIZE]; pid_t pid; pipe(fds); pid = fork(); if (pid == 0) { write(fds[1], str1, sizeof(str1)); sleep(2); read(fds[0], buf, BUF_SIZE); printf(\"Child proc output : %s\\n\", buf); } else { read(fds[0], buf, BUF_SIZE); printf(\"Parent proc output : %s\\n\", buf); write(fds[1], str2, sizeof(str2)); sleep(3); } return 0; } 运行结果: 向管道传递数据时，先读的进程会把数据取走。简而言之，数据进入管道后称为无主数据。通过read函数先读取数据的进程将得到数据，即使是该进程将数据传到了管道。 只用 1 个管道进行双向通信并非易事。为了实现这点，程序需要预测并控制运行流程，这在每种系统中都不同，可以视为不可能完成的任务。我们可以通过创建 2 个管道进行双向通信。各自负责不同的数据流动即可。 ##include \u003cstdio.h\u003e ##include \u003cunistd.h\u003e ##define BUF_SIZE 30 int main(int argc, char *argv[]) { int fds1[2], fds2[2]; char str1[] = \"Who are you?\"; char str2[] = \"Thank you for your message\"; char buf[BUF_SIZE]; pid_t pid; pipe(fds1); pipe(fds2); pid = fork(); if (pid == 0) { write(fds1[1], str1, sizeof(str1)); read(fds2[0], buf, BUF_SIZE); printf(\"Child proc output : %s\\n\", buf); } else { read(fds1[0], buf, BUF_SIZE); printf(\"Parent proc output : %s\\n\", buf); write(fds2[1], str2, sizeof(str2)); sleep(3); } return 0; } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:11:1","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 运用进程间通信 保存消息的回声服务器端扩展echo_mpserv.c，将回声客户端传输得的字符串按序保存到文件中。 我们可以将该任务委托给另外的进程。换言之，另行创建进程，从向客户端提供服务的进程读取字符串信息。当然，该过程中需要创建用于接收数据的管道。 // echo_storeserv.c ##include \u003cstdio.h\u003e ##include \u003cstdlib.h\u003e ##include \u003cstring.h\u003e ##include \u003cunistd.h\u003e ##include \u003csignal.h\u003e ##include \u003csys/wait.h\u003e ##include \u003carpa/inet.h\u003e ##include \u003csys/socket.h\u003e ##define BUF_SIZE 30 void error_handling(char *message); void read_childproc(int sig); int main(int argc, char *argv[]) { int serv_sock, clnt_sock; struct sockaddr_in serv_adr, clnt_adr; int fds[2]; pid_t pid; struct sigaction act; socklen_t adr_sz; int str_len, state; char buf[BUF_SIZE]; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } act.sa_handler = read_childproc; sigemptyset(\u0026act.sa_mask); act.sa_flags = 0; state = sigaction(SIGCHLD, \u0026act, 0); serv_sock = socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family = AF_INET; serv_adr.sin_addr.s_addr = htonl(INADDR_ANY); serv_adr.sin_port = htons(atoi(argv[1])); if (bind(serv_sock, (struct sockaddr *)\u0026serv_adr, sizeof(serv_adr)) == -1) { error_handling(\"bind() error\"); } if (listen(serv_sock, 5) == -1) { error_handling(\"listen() error\"); } pipe(fds); pid = fork(); if (pid == 0) { FILE *fp = fopen(\"echomsg.txt\", \"wt\"); char msgbuf[BUF_SIZE]; int i, len; for (i = 0; i \u003c 10; i++) { len = read(fds[0], msgbuf, BUF_SIZE); fwrite((void *)msgbuf, 1, len, fp); } fclose(fp); return 0; } while (1) { adr_sz = sizeof(clnt_adr); clnt_sock = accept(serv_sock, (struct sockaddr *)\u0026clnt_adr, \u0026adr_sz); if (clnt_sock == -1) { continue; } else { puts(\"new client connected...\"); } pid = fork(); if (pid == -1) { close(clnt_sock); continue; } if (pid == 0) // 子进程运行区域 { close(serv_sock); while ((str_len = read(clnt_sock, buf, BUF_SIZE)) != 0) { write(clnt_sock, buf, str_len); write(fds[1], buf, str_len); } close(clnt_sock); puts(\"client disconnected...\"); return 0; } else { close(clnt_sock); } } close(serv_sock); return 0; } void read_childproc(int sig) { pid_t pid; int status; pid = waitpid(-1, \u0026status, WNOHANG); printf(\"removed proc id %d \\n\", pid); } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:11:2","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" I/O 复用","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:12:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 多种 I/O 函数","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:13:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 多播与广播","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:14:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 套接字和标准 I/O","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:15:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 关于 I/O 流分离的其他内容","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:16:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 由于 select 和 epoll","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:17:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 多线程服务器端的实现","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:18:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" Windows 平台下的线程的使用","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:19:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" Windows 中的线程同步","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:20:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 异步通知的 I/O 模型","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:21:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 重叠 I/O 模型","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:22:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 制作 HTTP 服务器端","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:23:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 进阶内容","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:24:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 推荐Windows Sockets 2: https://learn.microsoft.com/en-us/windows/win32/api/_winsock/ 《计算机网络 自顶向下》 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:25:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":" 参考《TCP/IP 网络编程》 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:26:0","tags":["网络编程"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["CSS"],"content":" 2022/11/10 更新: 增加背景、阴影和混合模式 2022/11/14 更新: 增加选择器和预处理器 2022/11/23 更新: 增加 4 个练习项目 2022/12/13 更新: 增加Polaroid Camera练习项目 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:0:0","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 准备随书代码: https://github.com/CSSInDepth/css-in-depth Node.js: https://nodejs.org/en/ Visual Studio Code: https://code.visualstudio.com/ Git: https://git-scm.com/ ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:1:0","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 层叠、优先级和继承","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:2:0","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 层叠当声明冲突时，层叠会依据三种条件解决冲突。 样式表的来源: 样式是从哪里来的，包括你的样式和浏览器默认样式。 选择器优先级: 哪些选择器比另一些选择器更重要。 源码顺序: 样式在样式表里的声明顺序。 选择器和声明块一起构成了规则集（ruleset）。一个规则集也简称一个规则。 @规则（at-rules）是指用@符号开头的语法，比如@import规则或者@media查询。 样式表的来源自己的样式表属于作者样式表，除此之外还有用户代理样式表，即浏览器默认样式。用户代理样式表优先级低，自己的样式会覆盖它们。 标记了!important的声明会被当作更高优先级的来源，因此总体的优先级按照由高到低排列如下所示: 作者的!important 作者 用户代理 理解优先级如果无法用来源解决冲突声明，浏览器会尝试检查它们的优先级。 浏览器将优先级分为两部分: HTML 的行内样式和选择器样式。 优先级的规则如下： 如果选择器的 ID 数量更多，则它会胜出。 如果 ID 数量一致，那么拥有更多类的选择器胜出。 如果以上两次比较都一致，那么拥有最多标签名的选择器胜出。 伪类选择器（如:hover）和属性选择器（如[type=\"input\"]）与一个类选择器的优先级相同。通用选择器（*）和组合器（\u003e、+、~）对优先级没有影响。 我们可以用优先级标记来比较不同选择器的优先级: 通常最好让优先级尽可能低，这样当需要覆盖一些样式时，才能有选择空间。 源码顺序如果两个声明的来源和优先级相同，其中一个声明在样式表中出现比较晚，或者位于页面较晚引入的样式表中，则该声明胜出。 两条经验法则 在选择器中不要使用 ID。就算只用一个 ID，也会大幅度提升优先级。但需要覆盖整个选择器时，通常找不到另一个有意义的 ID，于是就会复制原来的选择器，然后加上另一个类，以区别想要覆盖的选择器。 不要使用!important。它比 ID 更难覆盖，一旦用了它，想要覆盖原先的声明，就需要加上一个!important，而且依然要处理优先级的问题。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:2:1","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 继承只有特定的属性能被继承，通常是我们希望被继承的那些。它们主要是跟文本相关的属性: color font font-family font-size font-weight font-variant font-style line-height letter-spacing text-align text-indent text-transform white-space word-spacing 列表属性也可以被继承: list-style list-style-type list-style-position list-style-image 活用开发者工具了解具体情况: ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:2:2","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 特殊值有两个特殊值可以赋给任意属性，用户控制层叠: inherit和initial。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:2:3","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 简写属性https://developer.mozilla.org/zh-CN/docs/Web/CSS/Shorthand_properties ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:2:4","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 相对单位相对单位会根据外部因素发生变化。例如，2em的具体值会更具它作用到的元素（有时甚至是根据属性）而变化。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:0","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 相对单位的好处响应式: 能够根据浏览器窗口的大小有不同的“响应”。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:1","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" em 和 rem在 CSS 中，1em等于当前元素的字号，其准确值取决于作用的元素。 浏览器会根据相对单位的值计算出绝对值，称作计算值（computed value）。 使用 em 定义字号如果声明font-size: 1.2em，这个font-size是根据继承的字号来计算的。 body { font-size: 16px; } .slogan { font-size: 1.2em; /* 19.2px */ padding: 1.2em; /* 23.04px */ } 字体缩小问题 body { font-size: 16px; } ul { font-size: .8em; } 会导致嵌套的列表字体越来越小。纠正方法如下: ul { font-size: .8em; } ul ul { font-size: 1em; } 使用 rem 设置字号根节点有一个伪类选择器（:root），可以用来选中它自己。这等价于类型选择器html，但html的优先级相当于一个类名，而不是标签。 rem是 root em 的缩写。rem 不是相当于当前元素，而是相对于根元素的单位。 :root { font-size: 1em; /* 使用浏览器的默认字号(16px) */ } ul { font-size: .8rem; /* 12.8px */ } 提示: 拿不准的时候，用 rem 设置字号，用 px 设置边框，用 em 设置其他大部分属性。 通过这种策略，可以轻松构建响应式面板: .panel { padding: 1em; border-radius: 0.5em; border: 1px solid #999; } .panel \u003e h2 { margin-top: 0; font-size: 0.8rem; font-weight: bold; text-transform: uppercase; } 使用媒体查询改变根元素的字号。这样就可以基于不同用户的屏幕尺寸，渲染出不同大小的面板。 :root { font-size: 0.75em; } @media (min-width: 800px) { /* 宽度800px以上 */ :root { font-size: 0.875em; } } @media (min-width: 1200px) { /* 宽度1200px以上 */ :root { font-size: 1em; } } 充分体现了使用em的优势。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:2","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 视口的相对单位视口: 浏览器窗口中网页可见部分的边框区域。不包括浏览器的地址栏、工具栏、状态栏。 vh: 视口高度的 1/100 vw: 视口宽度的 1/100 vmin: 视口宽、高中较小一方的 1/100 vmax: 视口宽、高中较大一方的 1/100 使用 vw 定义字号给一个元素加上font-size: 2vw在一个 1200px 的显示器上计算值为 24px。在一个 768px 宽的平板上，计算值约为 15px。这样做的好处在于元素能够在这两种大小之间平滑地过渡， 这意味着不会在某个断点突然开始改变。当视口大小改变时，元素会逐渐过渡。 使用 calc()定义字号calc()函数内可以对两个及其以上的值进行基本运算。支持的运算包括加减乘除。 :root { font-size: calc(0.5em + 1vw); } https://gist.github.com/basham/2175a16ab7c60ce8e001 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:3","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 自定义属性(即 CSS 变量)定义一个自定义属性: :root { --main-font: Helvetica, Arial, sans-serif; } p { font-family: var(--main-font); } 变量名用两个连字符用来和 CSS 属性区分。 变量必须在一个声明块内声明。这里用了:root选择器，所以可以在整个网页使用。 var()函数接受第二个参数，它指定了备用值。如果第一个参数指定的变量未定义，那么就会使用第二个值。 若 var()函数算出来的是一个非法值，对应的属性就会设置为其初始值。 动态改变自定义属性自定义属性的声明能够层叠和继承：可以再多个选择器中定义相同的变量，这个变量在网页的不同地方有不同的值。 如下所示: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003e导航\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"style.css\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003cheader class=\"page-header\"\u003e \u003ch1 class=\"title\" id=\"page-title\"\u003eWombat Coffe Roasters\u003c/h1\u003e \u003cnav\u003e \u003cul class=\"nav\" class=\"main-nav\"\u003e \u003cli\u003e\u003ca href=\"/\"\u003eHome\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/coffees\"\u003eCoffes\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/brewers\"\u003eBrewers\u003c/a\u003e\u003c/li\u003e \u003cli\u003e \u003ca href=\"/specials\" class=\"featured\"\u003eSpecials\u003c/a\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/nav\u003e \u003c/header\u003e \u003cmain\u003e \u003cdiv class=\"panel\"\u003e\u003c/div\u003e \u003cdiv class=\"panel dark\"\u003e\u003c/div\u003e \u003c/main\u003e \u003c/body\u003e \u003c/html\u003e :root { font-size: calc(0.5em + 0.5vw); --bg-color: #368; } h1 { font-family: sans-serif; } ##page-title { font-family: sans-serif; } .title { font-family: monospace; } .panel { width: 5em; height: 5em; background-color: var(--bg-color); margin: 1em; } .dark { --bg-color: #000; } 使用 JavaScript 改变自定义属性 const rootElement = document.documentElement; const styles = getComputedStyle(rootElement); const bgColor = styles.getPropertyValue(\"--bg-color\"); console.log(String(bgColor).trim()); rootElement.style.setProperty(\"--bg-color\", \"red\"); ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:4","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 盒模型 调整盒模型在 CSS 中可以使用box-sizing属性调整盒模型的行为。其默认值为content-box，任何指定的宽或高都只会设置内容盒子的大小。将其值设为border-box后，height和width属性会设置内容、内边距以及边框的大小总和。 全局设置 border-box通用选择器*可以选中页面上所有元素，并用两个选择器选中网页的所有伪元素。 *, ::before, ::after { box-sizing: border-box; } 如果用了第三方组件，使用上述方式可能会破坏其中一些组件的布局。我们可以利用继承改一下修改盒模型的方式。 :root { box-sizing: border-box; } *, ::before, ::after { box-sizing: inherit; } ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:5","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 元素高度的问题通常最好避免给元素指定明确的高度。普通文档流是为限定的宽度和无限的高度设计的。内容会填满视口的高度，然后在必要的时候折行。因此，容器的高度由内容天然地决定，而不是容器自己决定。 普通文档流——指的是网页元素的默认布局行为。行内元素跟随文字的方向从左到右排列，当到达容器边缘时会换行。块级元素会占据完整的一行，前后都有换行。 控制溢出行为当明确设置一个元素的高度时，内容可能会溢出。当内容在限定区域放不下渲染到父元素外面时，就会发生这种现象。 用 overflow 属性可以控制溢出内容的行为，该属性支持以下 4 个值。 visible（默认值）——所有内容可见，即使溢出容器边缘。 hidden——溢出容器内边距边缘的内容被裁剪，无法看见。 scroll——容器出现滚动条。 auto——只有内容溢出时容器才会出现滚动条。 百分比高度的备选方案用百分比指定高度存在问题。百分比参考的事元素容器块的大小，但是容器的高度通常是由子元素的高度决定的。这样会造成死循环，浏览器处理不了，因此它会忽略这个声明。想要让百分比高度生效，必须给父元素明确定义一个高度。 CSS 表格布局 给容器设置display: table，给每一列设置display: table-cell。这里没有table-row元素，因为 CSS 表格不像 HTML 表格那样必须有行元素。 不像block的元素，默认情况下，显示为table的元素宽度不会扩展到 100%，因此需要明确指定宽度。但外边距不会作用于table-cell元素。 可以用表格元素border-spacing属性来定义单元格的间距。该属性接受两个长度值: 水平间距和垂直间距。可以给容器加上border-spacing: 1.5em 0，但这会产生一个副作用: 这个值也会作用于表格的外边缘。如此一来就无法和头部左右对齐。 我们可以使用负外边距解决这个问题，但这需要给整个表格包裹一层新的容器。代码如下: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003e盒模型\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"style.css\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003cheader\u003e \u003ch1\u003eFranklin Running Club\u003c/h1\u003e \u003c/header\u003e \u003cdiv class=\"wrapper\"\u003e \u003cdiv class=\"container\"\u003e \u003cmain class=\"main\"\u003e \u003cp\u003e The Franklin Running Club meets at 6:00pm every Thursday at the town square. Runs are three to five miles, at your own pace. \u003c/p\u003e \u003c/main\u003e \u003caside class=\"sidebar\"\u003e \u003cdiv class=\"widget\"\u003e\u003c/div\u003e \u003cdiv class=\"widget\"\u003e\u003c/div\u003e \u003c/aside\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 样式设置如下: :root { box-sizing: border-box; } *, ::before, ::after { box-sizing: inherit; } .wrapper { margin-left: -1.5em; margin-right: -1.5em; } .container { display: table; border-spacing: 1.5em 0; width: 100%; } body { background-color: #eee; font-family: Helvetica, Arial, sans-serif; } header { color: #fff; background-color: #0072b0; border-radius: 0.5em; } main { display: block; } .main { display: table-cell; width: 70%; background-color: #fff; border-radius: 0.5em; } .sidebar { display: table-cell; margin-left: 1.5em; width: calc(30% - 1.5em); padding: 1.5em; background-color: #fff; border-radius: 0.5em; } Flexbox 还可以用 Flexbox 实现两列等高布局。Flexbox 不需要一个额外的 div 包裹元素，它默认会产生等高的元素，也不需要使用负外边距。 :root { box-sizing: border-box; } *, ::before, ::after { box-sizing: inherit; } .container { display: flex; } body { background-color: #eee; font-family: Helvetica, Arial, sans-serif; } header { color: #fff; background-color: #0072b0; border-radius: 0.5em; } main { display: block; } .main { width: 70%; background-color: #fff; border-radius: 0.5em; } .sidebar { width: 30%; padding: 1.5em; margin-left: 1.5em; background-color: #fff; border-radius: 0.5em; } 弹性容器（Flex Container）子元素默认等高。 使用 min-height 和 max-height可以用这两个属性指定最小或最大值，而不是明确定义高度，这样元素就可以再这些界限内自动决定高度。 可以用min-height指定一个最小高度，而不指定它的明确高度。这意味着元素至少等于指定的高度，如果内容太多，浏览器就会允许元素自己扩展高度，以免内容溢出。 max-height允许元素自然地增加到一个特定界限。如果到达这个界限，元素就不再增高，内容会溢出。 还有类似属性min-width和max-width。 垂直居中给块级元素设置vertical-align: middle后，通常不能垂直居中，因为浏览器会忽略这个声明。 vertical-align声明只会影响行内元素或table-cell元素。 垂直居中指南 http://howtocenterincss.com/ ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:6","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 负外边距https://www.educba.com/negative-margin-css/ ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:7","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 外边距折叠在没有其他 CSS 的影响下，所以相邻的顶部和底部外边距都会折叠。 只有上下外边距会产生折叠，左右外边距不会折叠。 如下方法可以防止外边距折叠： ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:8","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 容器内的元素间距猫头鹰选择器 body * + * { margin-top: 1.5em; } ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:9","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 理解浮动","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:4:0","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 浮动的设计初衷浮动能将一个元素（通常是一张图片）拉到容器的一侧，这样文档流就能包围它。 浮动元素会被移除正常文档流，并被拉到容器边缘。文档流会重新排列，但是它会包围浮动元素此刻所占据的空间。 如果让多个元素向同侧浮动，它们就会挨着排列。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:4:1","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 容器折叠和清楚浮动 理解容器折叠 \u003c!doctype html\u003e \u003chead\u003e \u003cstyle\u003e :root { box-sizing: border-box; } *, ::before, ::after { box-sizing: inherit; } body { background-color: #eee; font-family: Helvetica, Arial, sans-serif; } body * + * { margin-top: 1.5em; } header { padding: 1em 1.5em; color: #fff; background-color: #0072b0; border-radius: .5em; margin-bottom: 1.5em; } .main { padding: 0 1.5em; background-color: #fff; border-radius: .5em; } .container { max-width: 1080px; margin: 0 auto; } .media { float: left; width: 50%; padding: 1.5em; background-color: #eee; border-radius: 0.5em; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"container\"\u003e \u003cheader\u003e \u003ch1\u003eFranklin Running Club\u003c/h1\u003e \u003c/header\u003e \u003cmain class=\"main clearfix\"\u003e \u003ch2\u003eRunning tips\u003c/h2\u003e \u003cdiv\u003e \u003cdiv class=\"media\"\u003e \u003cimg class=\"media-image\" src=\"runner.png\"\u003e \u003cdiv class=\"media-body\"\u003e \u003ch4\u003eStrength\u003c/h4\u003e \u003cp\u003e Strength training is an important part of injury prevention. Focus on your core\u0026mdash; especially your abs and glutes. \u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"media\"\u003e \u003cimg class=\"media-image\" src=\"shoes.png\"\u003e \u003cdiv class=\"media-body\"\u003e \u003ch4\u003eCadence\u003c/h4\u003e \u003cp\u003e Check your stride turnover. The most efficient runners take about 180 steps per minute. \u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"media\"\u003e \u003cimg class=\"media-image\" src=\"shoes.png\"\u003e \u003cdiv class=\"media-body\"\u003e \u003ch4\u003eChange it up\u003c/h4\u003e \u003cp\u003e Don't run the same every time you hit the road. Vary your pace, and vary the distance of your runs. \u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"media\"\u003e \u003cimg class=\"media-image\" src=\"runner.png\"\u003e \u003cdiv class=\"media-body\"\u003e \u003ch4\u003eFocus on form\u003c/h4\u003e \u003cp\u003e Run tall but relaxed. Your feet should hit the ground beneath your hips, not out in front of you. \u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/main\u003e \u003c/div\u003e \u003c/body\u003e 效果如下： 容器白色的背景没有延伸到媒体盒子后面。这是因为浮动元素不同于普通文档流的元素，它们的高度不会加到父元素上。 一个解决的办法是使用和浮动配套的clear属性。将一个元素放在主容器末尾，并对其使用clear，这会让容器扩展到浮动元素下面。 \u003cmain class=\"main\"\u003e ... \u003cdiv style=\"clear: both;\"\u003e\u003c/div\u003e \u003c/main\u003e 因为空div本身没有浮动，所以容器就会扩展，直到包含它。 理解清除浮动 伪元素——特殊的选择器，可以选中文档的特定部分。伪元素以双冒号开头，大部分浏览器为了向后兼容也支持单冒号形式。 .clearfix::after { display: block; content: \" \"; clear: both; } 要给包含浮动的元素清除浮动。 https://learningnow.com.tw/css-float/ ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:4:2","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" Flexbox","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:5:0","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" Flexbox 的原则给元素添加display: flex，该元素就变成了一个弹性容器（Flex Container），它的直接子元素就变成了弹性子元素（Flex Item）。弹性子元素默认是在同一行按照从左到右的顺序并排排列。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:5:1","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 弹性子元素的大小flex属性控制弹性子元素在主轴方向上的大小（宽度）。 .column-main { flex: 2; } .column-sidebar { flex: 1; } flex属性是三个不同大小属性的简写：flex-grow、flex-shrink和flex-basis。 flex: 2等价于flex: 2 1 0%，也可以分别声明: .column-main { flex-grow: 2; flex-shrink: 1; flex-basis: 0%; } 使用flex-basis属性flex-basis定义了元素大小的基准值，即一个初始的主尺寸。flex-basis属性可以设置为任意的 width 值，包括 px、em、百分比。它的初始值是auto，此时浏览器会检查元素是否设置了width属性值。如果有，则使用width的值作为flex-basis的值；如果没有，则用元素内容自身的大小。使用flex-basis的值不是 auto，width 属性会被忽略。 使用flex-grow属性每个弹性子元素的flex-basis值计算出来后，它们（加上子元素之间的外边距）加起来会占据一定的宽度。加起来的宽度不一定正好填满弹性容器的宽度，多出来的留白会按照 flex-grow 的值分配每个弹性子元素。 flex-grow 的值为非负数。若一个弹性子元素的值 flex-grow 值为 0，那么它的宽度不会超过 flex-basis 的值；如果某个弹性子元素的 flex-grow 非 0，那么这些元素会增长到所有的剩余空间被分配完。 使用flex-shrink属性计算出弹性子元素的初始主尺寸后，它们的累加值可能会超出弹性容器的可用宽度。如果不用flex-shrink，就会导致溢出。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:5:2","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 弹性方向 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:5:3","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 对齐、间距等细节通常情况下，创建一个弹性盒子方法如下: 选择一个容器及其子元素，给容器设置display: flex 如有必要，给容器设置flex-direction 给弹性子元素设置外边距和/或 flex 值，用来控制它们的大小 理解弹性容器的属性弹性容器的属性: 弹性子元素的属性: ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:5:4","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 网格布局","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:6:0","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 网页布局开启新纪元和 Flexbox 类似，设置为display: grid的元素成为一个网格容器。它的子元素变成网格元素。 .grid { display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr; grid-gap: 0.5em; } .grid \u003e * { background-color: darkgray; color: white; padding: 2em; border-radius: 0.5em; } grid-template-columns和grid-template-rows定义了网格每列每行的大小。使用了一个新单位fr，代表每一列（或每一行）的分数单位（fraction unit）。 这个单位和 Flexbox 中flex-grow因子的表现一样。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:6:1","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 网络剖析 repeat()函数，在声明多个网格轨道时提供了简写方式。grid-template-rows: repeat(4, auto);定义了四个水平网格轨道。轨道大小设置为auto，轨道会根据自身内容扩展。 用repeat()符号还可以定义不同的重复模式，比如repeat(3, 2fr, 1fr)会重复三遍这个模式，从而定义 6 个网格轨道。 可以给网格线或网格区域命名。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:6:2","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 显式和隐式网格使用grid-template-*属性定义网格轨道时，创建的是显式网格。 可以给网格容器设置grid-auto-columns和grid-auto-rows为隐式网格轨道指定一个大小。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:6:3","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 对齐 CSS Grid 网格布局教程: https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html 最强大的 CSS 布局 —— Grid 布局: https://juejin.cn/post/6854573220306255880 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:6:4","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 定位和层叠上下文position属性可以用来构建下拉菜单、模态框以及现代 Web 应用程序的一些基本效果。 position属性的初始值是static。如果把它改成其他值，就说元素被定位了。若元素使用了静态定位，那么就说它未被定位。 定位将元素彻底从文档流中移走，允许将元素放在屏幕的任意位置。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:7:0","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 固定定位给一个元素设置position: fixed就能将元素放在视口的任意位置。这需要搭配四种属性一起使用：top、right、bottom和left。 这些属性的值决定了固定定位的元素与浏览器视口边缘的距离。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:7:1","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 绝对定位绝对定位不是相对视口，而是相对最近的祖先定位元素。 如果祖先元素都没有定位，那么绝对定位的元素会基于初始包含块来定位。初始包含块和视口一样大，固定在网页的顶部。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:7:2","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 相对定位相对定位会让元素从原来的位置移走。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:7:3","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 层叠上下文和z-index拥有较高z-index的元素出现在拥有较低z-index的元素前面。拥有负数z=index的元素出现在静态元素后面。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:7:4","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 响应式设计响应式设计的三大原则: 移动优先。在实现桌面布局之前先构建移动版的布局。 @media 规则。使用该样式规则，可以为不同大小的视口定制样式。通常叫作媒体查询，写的样式只有在特定条件下才会生效。 流式布局。这种方式允许容器根据视口宽度缩放尺寸。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:8:0","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 移动优先构建桌面版之前要先构建移动端布局。 移动端布局一般是很朴素的设计。主要关注的是内容，在大屏上，可以把页面的大块区域拿来做头部、主图和菜单。在移动设备上，用户通常有更明确的目标。 做响应式设计时，要确保 HTML 包含各种屏幕尺寸所需的全部内容。可以对每个屏幕尺寸应用不同的 CSS，但必须共享同一份 HTML。 断点（breakpoint）：一个特殊的临界值。屏幕尺寸到达这个值时，网页的样式会发生改变，以便给当前屏幕尺寸提供最佳的布局。 视口meta标签。该 HTML 标签告知移动设备，已特意将网页适配了小屏设备。如果不加该标签，移动浏览器会假定网页不是响应式的，并且会尝试模拟桌面浏览器，那之前的移动端设计就白做了。 为了避免这种情况，我们将meta标签包含进去。 \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /\u003e \u003ctitle\u003eWombat Coffee Roasters\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"./style.css\" /\u003e \u003c/head\u003e meta标签的content属性里包含两个选项。首先，它告诉浏览器当解析 CSS 时将设备宽度作为假定宽度，而不是一个全屏的桌面浏览器宽度。其次，当页面加载时，它使用initial-scale将缩放比设置为 100%。 现代浏览器的开发者工具提供了模拟移动浏览器的功能。 Using the viewport meta tag to control layout on mobile browsers: https://udn.realityripple.com/docs/Mozilla/Mobile/Viewport_meta_tag ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:8:1","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 媒体查询媒体查询允许某些样式只在页面满足特定条件时才生效。这样就可以根据屏幕大小定制样式。可以针对小屏设备定义一套样式，针对中等屏幕设备定义另一套样式，针对大屏幕设备再定义一套样式，这样就可以让页面的内容拥有多种布局。 媒体查询使用@media规则选择满足条件的设备。一条简单的媒体查询如下所示: @media (min-width: 560px) { .title \u003e h1 { font-size: 2.25rem; } } 在最外层的大括号内可以定义任意的样式规则。@media规则会对条件进行见检查，只有满足所有的条件时，才会让这些样式应用到页面上。上例中浏览器会检查min-width: 560px。只有当设备的视口宽度大于等于 560px 时，才会给标题设置2.25rem的字号，否则将会被忽略。 在媒体查询里更适合用 em，如: .title \u003e h1 { color: #333; text-transform: uppercase; font-size: 1.5rem; margin: 0.2em 0; } @media (min-width: 35em) { .title \u003e h1 { font-size: 2.25rem; } } 媒体查询的类型可以进一步将两个条件用and关键字联合起来组成一个媒体查询，如下所示: @media (min-width: 20em) and (max-width: 35em) {...} 这种联合媒体查询只在设备同时满足两个条件时生效。若设备只需满足多个条件之一，可以用逗号分隔: @media (max-width: 20em), (min-width: 35em) {...} 还有一些别的媒体特征，参考: https://developer.mozilla.org/en-US/docs/Web/CSS/@media 给网页添加断点在任何媒体查询之前，最先写的是移动端样式，然后设置越来越大的断点。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:8:2","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 流式布局流式布局（Fluid Layout），有时被称作液体布局（Liquid Layout），指的是使用的容器随视口宽度而变化。它和固定布局相反，固定布局的列都是用 px 或 em 单位定义。固定容器（例如，设定了width: 800px的元素）在小屏上会超出视口范围，导致需要水平滚动条，而流式容器会自动缩小以适应视口。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:8:3","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 响应式图片创建不同分辨率的图片副本，利用媒体查询发送合适的图片。或者使用srcset提供对应的图片。 The anatomy of responsive images: https://jakearchibald.com/2015/anatomy-of-responsive-images/ ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:8:4","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 推荐RWD 是什么？: https://welly.tw/serp-rank-optimization/what-is-rwd-and-how-to-use The Beginner’s Guide to Responsive Web Design: https://kinsta.com/blog/responsive-web-design/ ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:8:5","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 模块化 CSS","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:9:0","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 基础样式: 打好基础每个样式表的开头都要写一些给整个页面使用的通用规则。这些规则通常被称为基础样式，其他样式是构建在这些基础样式之上的。 :root { box-sizing: border-box; } *, *::before, *::after { box-sizing: inherit; } body { font-family: Helvetica, Arial, sans-serif; } normalize.css库，可以协助消除不同客户端浏览器上的不一致。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:9:1","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 模式库","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:10:0","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 背景、阴影和混合模式","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:11:0","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 渐变background属性还有很多功能等着我们去探索，实际上，它是以下八个属性的简写。 background-image: 指定一个文件或生成的颜色渐变作为背景图片 background-position: 设置背景图片的初始位置 background-size: 指定元素内背景图片的渲染尺寸 background-repeat: 决定在需要填充整个元素时，是否平铺图片 background-origin: 决定背景相对于元素的边框盒、内边距框盒（初始值）或内容盒子来定位 background-clip: 指定背景是否应该填充边框盒（初始值）、内边距框盒或内容盒子 background-attachment: 指定背景图片是随着元素上下滚动（初始值），还是固定在视口区域。使用fixed值会对页面性能产生负面影响 background-color: 指定纯色背景，渲染到背景图片下方 使用简写属性background可以设置指定的值，同时把其他属性重置为初始值。因此，在需要用到多个属性时，可以考虑用单独的值。 background-image可以接受一个图片 URL 路径，例如background-image: url(coffee-beans.jpg)。也可以接受一个渐变函数，例如一个从白色过渡到蓝色的渐变。 线性渐变 .fade { height: 200px; width: 400px; background-image: linear-gradient(to right, white, blue); } linear-gradient函数使用三个参数来定义行为: 角度、起始颜色和终止颜色。上例的角度是to right（也可以是to left、to top、to bottom，或者是to bottom right），意思是渐变从元素的左侧开始平滑过渡到右侧。也可以使用其他的颜色表示方法，比如#0000ff、rgb(0,0,255)或者transparent关键字。 可以用确切的单位（比如度）更精确地控制角度。值0deg代表垂直向上，更大的值会颜色顺时针变化，90deg代表向右渐变。 度是最常用的单位，还有一些其他单位可用来表示角度: rad: 弧度，完整的圆是 2Π turn: 代表环绕圆周的圈数 gad: 百分度，一个完整的圆是 400 百分度 可以定义包含多个颜色的渐变，其中每个颜色可以称为颜色节点（Color Stop）。下面例子包含三个颜色节点的渐变: .fade { height: 200px; width: 400px; background-image: linear-gradient(90deg, red, white, blue); } 一个渐变可以接受任意数量的颜色节点，节点之间用逗号分隔。渐变会自动均匀地平铺这些颜色节点。本例中，最左侧（0%）从红色开始，过渡到中间（50%）的白色，到最右侧的蓝色（100%）。我们也可以在渐变函数中为每个颜色节点明确指定位置。 .fade { height: 200px; width: 400px; background-image: linear-gradient(90deg, red 0%, white 50%, blue 100%); } 使用repeating-linear-gradient()可以实现重复渐变，对于重复渐变最好使用特定的长度而不是百分比，因为设置的值决定了要重复图片大小。 条纹进度条示例: .fade { height: 1em; width: 400px; background-image: repeating-linear-gradient( -45deg, #57b, #57b 10px, #148 10px, #148 20px ); border-radius: 0.3em; } 更多例子，请看 Stripes in CSS: https://css-tricks.com/stripes-css/ 径向渐变线性渐变是从元素的一端开始，沿着直线过渡到另一端。而径向渐变不同，它是从一个点，全方位向外扩展。 .fade { height: 200px; width: 400px; background-image: radial-gradient(white, blue); } 更多例子: 若想深入研究一下，可看 Using CSS gradients: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Images/Using_CSS_gradients ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:11:1","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 阴影阴影是另一种可以为网页增加立体感的特效。有两个属性可以常见阴影，box-shadow为元素盒子生成阴影，text-shadow为渲染后的文字生成阴影。 模糊半径用来控制阴影边缘模糊区域的大小（可以简单理解为模糊程度），可以为阴影生成一个更柔和、有点透明的边缘。扩展半径用来控制阴影的大小，设置为正值可以使阴影全方位变大，设置负值则会变小。 使用渐变和阴影形成立体感新建一个网页和样式表，添加如下内容: \u003cbutton class=\"butotn\"\u003eSign up now\u003c/button\u003e .button { padding: 1em; border: 0; font-size: 0.8rem; color: white; border-radius: 0.5em; background-image: linear-gradient(to bottom, #57b, #148); box-shadow: 0.1em 0.1em 0.5em #124; } .button:active { box-shadow: inset 0 0 0.5em #124, inset 0 0.5em 1em rgba(0, 0, 0, 0.4); } 上面的样式增加了一个inset关键字，这样可以让阴影出现在元素边框的内部，而非之前的外部。同时定义了不止一个阴影，用逗号分隔。通过这种方式可以添加多个阴影。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:11:2","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 混合模式多数情况下，不论是使用真正的图片还是渐变，元素一般只用一张背景图片。但某些情况下可能会想要用两张或者更多的背景图片，CSS 支持这么做。 background-image属性可以接受任意数量的值，相互之间用逗号分开。 .blend { background-image: url(./bear.jpg), linear-gradient(to bottom, #57b, #148); } 使用多个背景图片时，排在前面的图片会渲染到排序靠后图片的上面。在此例中，bear.jpg 会遮盖在线性渐变之上，渐变就会不可见。若我们使用两张背景图片，那么一般是希望第二章图片可以透视显示。这时就可以用混合模式（Blend Mode）。 示例: \u003cdiv class=\"blend\"\u003e\u003c/div\u003e .blend { min-height: 80vh; background-image: url(./bear.jpg), url(./bear.jpg); background-size: cover; background-repeat: no-repeat; background-position: -30vw, 30vw; background-blend-mode: multiply; /* 应用混合模式 */ } 大部分背景相关的属性可以接受多个值，以逗号分隔。background-position就使用了两个值，第一个值用到第一张背景图片上，第二个值用到第二章背景图片上。 background-size和background-repeat属性也可以接受多个值，若只设置一个值，就会应用到所有背景图片上。 background-size属性接受两个关键字值，分别是cover和contain。使用cover值可以调整背景图片的大小，让其填满整个元素，这样会导致图片的边缘被裁剪掉一部分；使用contain值可以保证整个背景图片可见，这可能导致元素的一些地方不会被背景图片覆盖。该属性也可以接受长度值，用来明确设置背景图片的宽度和高度。 修改混合模式的其他值可以看到不同效果，例如: 使用某种颜色或者渐变为图片着色 为图片添加某种纹理效果，比如划痕或者老胶片放映时的颗粒感等 缓和、加深或减小图片的对比度，使图片上的文字更具可读性 在图片上覆盖一条文字横幅，但让图片完整显示 为图片着色通过使用混合模式，我们可以将一张全彩的图片着色成单一色相的图片。 .blend { min-height: 80vh; background-image: url(\"./bear.jpg\"); background-color: #148; background-size: cover; background-repeat: no-repeat; background-position: center; background-blend-mode: luminosity; /* 使用明度混合模式 */ } background-blend-mode不仅会合并多个背景图片，还会合并background-color。明度混合模式将前景层（大熊图片）的明度，与背景层（蓝色背景色图层）的色相饱和度混合。 即最终使用背景色图层的颜色，但明暗程度来自大熊图片。 混合模式的类型如下图所示: 为图片添加纹理纹理图片以重复平铺的方式覆盖在大熊图片上方。 .blend { min-height: 80vh; background-image: url(\"./scratches.png\"), url(\"./bear.jpg\"); background-size: 200px, cover; background-repeat: repeat, no-repeat; background-position: center, center; background-blend-mode: soft-light; /* 使用柔光混合模式 */ } 使用融合混合模式background-blend-mode属性可以实现多张图片的混合，但只能局限于元素的背景颜色或者背景图片使用。还有一个属性mix-blend-mode，可以融合多个元素。不仅可以混合图片，还可以把元素的文本和边框与容器的背景图片混合在一起。 .blend { background-image: url(\"./bear.jpg\"); background-size: cover; background-position: center; padding: 5em 0 10em; } .blend \u003e h1 { margin: 0; font-family: Arial, Helvetica, sans-serif; font-size: 6rem; text-align: center; mix-blend-mode: hard-light; background-color: #c33; color: #808080; border: 0.1em solid #ccc; border-width: 0.1em 0; } ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:11:3","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 对比、颜色和间距","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:12:0","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 对比最重要对比是设计中的一种手段，通过突出某物来达到吸引注意力的目的。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:12:1","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 排版随着 Web 字体的兴起，使用@font-face规则，告诉浏览器去哪里找到并下载自定义字体，供页面使用。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:13:0","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 过渡Web 是个生动的媒介，可以做如元素淡出、菜单滑入、颜色从一种变成另一种，实现这些效果最简单的方式是过渡（Transitions）。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:14:0","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 从这边到那边过渡是通过一系列transition-*属性来实现的。如果某个元素设置了过渡，那么当它的属性值发生变化时，并不是直接变成新值，而是使用过渡效果。 先看一个示例，最开始是个蓝绿色方角按钮，鼠标悬停时，过渡成一个红色圆角按钮: \u003cbutton\u003eHover over me\u003c/button\u003e button { background-color: hsl(180, 50%, 20%); border: 0; color: white; font-size: 1rem; padding: 0.3em 1em; transition-property: all; transition-duration: 0.5s; } button:hover { background-color: hsl(0, 50%, 50%); border-radius: 1em; } transition-property属性可以指定哪些属性使用过渡。关键字all表示所有的属性变化都使用过渡。transition-duration属性代表过渡到最终值之前需要多长时间，本例是 0.5 秒。 也可以使用简写属性transition，该简写属性接受四个参数值，分别代表四个过渡属性transition-property、transition-duration、transition-timing-function和transition-delay。 第一个值设置了哪些属性需要过渡，初始值是关键字 all，表示所有属性都生效。如果只有某个属性需要过渡，在这里指定属性即可。例如: transition-property: color将只应用在元素的颜色上，其他属性会立刻发生变化。也可以设置多个值，比如: transition-property: color, font-size。 第二个值是持续时间，用秒或者毫秒表示。 第三个值是定时函数，用来控制属性的中间值如何计算，实际上控制的是过渡过程中变化率如何加速或者减速。定时函数可以是一个关键字值，比如linear或者ease-in，也可以是自定义函数。 最后一个值是延迟时间，允许开发者在属性值改变之后过渡生效之前设置一个等待周期。 如果需要为两个不同的属性分别设置不同的过渡，可以添加多个过渡规则，以逗号分隔: transition: border-radius 0.3s linear, background-color 0.6s ease; 等价于以下代码: transition-property: border-radius, background-color; transition-duration: 0.3s, 0.6s; transition-timing-function: linear, ease; ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:14:1","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 定时函数定时函数用来说明如何移动。是以恒定的速度移动？还是开始慢，后面快？ 我们可以用 linear、ease-in 和 ease-out 等关键字来描述移动过程。 linear 过渡，值以固定的速度改变；ease-in 过渡，变化速度开始时慢，然后一直加速，直到过渡完成；ease-out 是减速，开始时快速变化，结束时比较慢。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:14:2","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 变换","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:15:0","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 旋转、平移、缩放和倾斜基本的变换规则如下: transform: rotate(90deg); 这条规则应用到元素上后，会让元素向右（顺时针）旋转 90 度。变换函数rotate()用来指定元素如何变换。其他变换函数如下: 旋转（Rotate）: 元素围绕一个轴心转动一定角度 平移（Translate）: 元素上下左右各个方向移动 缩放（Scale）: 缩小或放大元素 倾斜（Skew）: 使元素变形，顶边滑向一个方向，底边滑向相反的方向 每种变换都使用相应的函数作为transform属性的值。使用变换的时候元素可能会被移动到页面上的新位置，但它不会脱离文档流。其初始位置不会被其他元素占用。 变换不能作用在 span 或 a 这样的行内元素上。若确实需要，要么改变元素的 display 属性，替换掉inline（比如inline-block），要么把元素改为弹性子元素或网格项目。 更改变换基点变换是围绕基点（Point of origin）发生的。基点是旋转的轴心，也是缩放或倾斜开始的地方。这意味着元素的基点是固定在某个位置上，元素的剩余部分围绕基点变换（translate 是个例外，因为平移过程中元素整体移动）。 默认情况下，基点就是元素的中心，可以通过transform-origin属性改变基点位置。 例如: transform-origin: right center; transform-origin: 100% 50%; 以上两句等价。 使用多重变换可以对transform属性指定多个值，用空格隔开。变换的每个值从右向左按顺序执行，例如: transform: rotate(15deg) translate(15px, 0)，元素会先向右平移 15px，然后顺时针旋转 15 度。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:15:1","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 在运动中变换变换本身不具备太多实用性。当和动作结合起来使用的时候，变换就会有用多了。 SVG——可缩放矢量图形（Scalable Vector Graphics）的简称。这是一种基于 XML 的图片格式，使用向量定义图片。由于图片是使用数学计算来定义的，所以可以放大或缩小到任意尺寸。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:15:2","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 动画关键帧（keyframe）是指动画过程中某个特定时刻。我们定义一些关键帧，浏览器负责填充或者插入这些关键帧之间的帧图像。 从原理上看，过渡和关键帧动画类似: 我们定义第一帧（起始点）和最后一帧（结束点），浏览器计算所有中间值，使得元素可以在这些值之间平滑变换。但使用关键帧动画，我们就不在局限于两个点，而是想加多少就加多少。浏览器负责填充一个个点与点之间的值，直到最后一个关键帧，最终生成一系列无缝衔接的过渡。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:16:0","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 关键帧CSS 中的动画包括两部分: 用来定义动画的@keyframes规则和为元素添加动画的animation属性。 先创建一个简单的动画来熟悉以下语法: @keyframes over-and-back { 0% { background-color: hsl(0, 50%, 50%); transform: translate(0); } 50% { transform: translate(50px); } 100% { background-color: hsl(270, 50%, 50%); transform: translate(0); } } .box { width: 100px; height: 100px; background-color: green; animation: over-and-back 1.5s linear 3; } \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003e动画\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"./style.css\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"box\"\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:16:1","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 选择器","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:17:0","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 基础选择器 tagname——标签选择器。该选择器匹配目标元素的标签名。其优先级是0,0,1。例如: p、h1、strong。 .class——类选择器。该选择器匹配 class 属性中有指定类名的元素。其优先级是0,1,0。例如: .media、.nav-menu。 #id——ID 选择器。该选择器匹配拥有指定 ID 属性的元素。其优先级是1,0,0。例如: #sidebar。 *——通用选择器。该选择器匹配所有元素。其优先级是0,0,0。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:17:1","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 组合器组合器将多个基础选择器连接起来组成一个复杂选择器。 后代组合器（空格）——匹配的目标元素的其他元素的后代。例如: .nav-menu li。 子组合器（\u003e）——匹配的目标元素紧跟在其他元素后面。例如: .parent \u003e .child。 相邻兄弟组合器（+）——匹配的目标元素紧跟在其他元素后面。例如: p + h1。 通用兄弟组合器（~）——匹配所有跟随在指定元素之后的兄弟元素。 多个基础选择器可以连起来（不使用空格或者其他组合器）组成一个复合选择器（例如: h1.page-header）。复合选择器选中的元素将匹配其全部基础选择器。例如，.dropdown.is-active能选中\u003cdiv class=\"dropdown is-active\"\u003e...\u003c/div\u003e，当无法选中\u003cdiv class=\"dropdown\"\u003e\u003c/div\u003e。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:17:2","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 伪类选择器伪类选择器用于选中某个特定状态的元素。这种状态可能是由于用户交互，也可能是由于元素相对于其父级或兄弟元素的位置。其优先级等于一个类选择器(0, 1, 0)。 :first-child——匹配的元素是其父元素的第一个子元素。 :last-child——匹配的元素是其父元素的最后一个子元素。 :only-child——匹配的元素是其父元素的唯一一个子元素（无兄弟元素）。 CSS Pseudo-classes: https://www.w3schools.com/css/css_pseudo_classes.asp ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:17:3","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 伪元素选择器伪元素匹配在文档中没有直接对应 HTML 元素的特定部分。伪元素选择器可能只匹配元素的一部分，甚至向 HTML 标记中未定义的地方插入内容。 此类选择器以双冒号开头，大多数浏览器也支持单冒号的语法以便向后兼容。伪元素选择器的优先级与元素选择器(0, 0, 1)相等。 ::before——创建一个伪元素，使其成为匹配元素的第一个子元素。该元素默认是行内元素，可用于插入文字、图片或其他形状。必须指定 content 属性才能让元素出现。例如: .menu::before。 ::after——创建一个伪元素，使其成为匹配元素的最后一个子元素。元素默认是行内元素，可用于插入文字、图片或其他形状。必须指定 content 属性才能让元素出现。例如: .menu::after。 ::first-letter——用于指定匹配元素的第一个文本字符的样式。例如: h2::first-letter。 ::first-line——用于指定匹配元素的第一行文本的样式。 ::selection——用于指定用户使用鼠标高亮选择的任意文本的样式。通常用于改变选中文本的background-color。只有少数属性可以用，包括color、background-color、cursor、text-decoration。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:17:4","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 属性选择器属性选择器用于根据 HTML 属性匹配元素。其优先级与一个类选择器(0,1,0)相等。 [attr]——匹配的元素拥有指定属性 attr，无论属性值是什么，例如: input[disabled]。 [attr=\"value\"]——匹配的元素拥有指定属性 attr，且属性值等于指定的字符串值，例如: input[type=\"radio\"]。 [attr^=\"value\"]——“开头”属性选择器。该选择器匹配的元素拥有指定属性 attr，且属性值的开头是指定的字符串值，例如: a[href^=\"https\"]。 [attr$=\"value\"]——“结尾”属性选择器。该选择器匹配的元素拥有指定属性 attr，且属性值的结尾是指定的字符串值，例如: a[href$=\".pdf\"]。 [attr*=\"value\"]——“包含”属性选择器。该选择器匹配的元素拥有指定属性 attr，且属性值包含指定的字符串值，例如: [class*=\"sprite-\"]。 [attr~=\"value\"]——“空格分隔的列表”属性选择器。该选择器匹配的元素拥有指定属性 attr，且属性值是一个空格分隔的值列表，列表中的某个值等于指定字符串值，例如: a[rel=\"author\"]。 [attr|=\"value\"]——匹配的元素拥有指定属性 attr，且属性值要么等于指定的字符串值，要么以该字符串开头且紧跟着一个连字符。例如: [lang|=\"es\"]。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:17:5","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 预处理器预处理器的原理是把我们写的源文件转译成输出文件，即常规 CSS 样式表。对浏览器而言，最终输出的是常规 CSS，所以预处理器不会向语言添加任何新特性。但对于开发者来说，预处理器提供了许多便利。 比较流行的预处理器有 Sass 和 Less。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:18:0","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" Sass 搭建环境使用npm init -y初始化一个新的 npm 项目。 使用npm install --save-dev node-sass安装node-sass包。 Sass 支持两种语法: Sass 和 SCSS。它们的语言特性一样，但 Sass 语法去掉了所有的大括号和分号，严格使用缩进来表示代码结构。SCSS 语法使用大括号和分号，因此看起来更像 CSS。 在项目目录下新建 sass 和 build 子目录，我们把源文件放在 sass 目录，生成的 CSS 文件将在 build 目录中。 在package.json中添加一条命令: \"scripts\": { \"sass\": \"node-sass sass/index.scss build/styles.css\" }, 之后运行npm run sass，可以看到在 build 目录中生成了 styles.css 文件。 理解 Sass 的核心特性 变量在 Sass 中可以使用变量，在index.scss中添加如下代码: // 定义变量 $brand-blue: #0086b3; a:link { // 使用变量 color: $brand-blue; } body { font-family: Arial, Helvetica, sans-serif; color: black; } .page-heading { font-size: 1.6rem; // 使用变量 color: $brand-blue; } 运行npm run sass命令，输出文件build/styles.css内容如下: a:link { color: #0086b3; } body { font-family: Arial, Helvetica, sans-serif; color: black; } .page-heading { font-size: 1.6rem; color: #0086b3; } 变量已经被替换为了十六进制颜色值，浏览器可以直接加载。 行内计算Sass 支持使用+、-、*、/和%（模运算）进行行内计算，如此一来，我们就可以从一个初始值获得多个值。 $padding-left: 3em; .note-author { padding-left: $padding-left; font-weight: bold; } .note-body { padding-left: $padding-left * 2; } 使用npm run sass编译后生成如下结果: .note-author { padding-left: 3em; font-weight: bold; } .note-body { padding-left: 6em; } .note-body中的padding-left属性成功计算得到。 嵌套选择器Sass 允许在代码块内嵌套选择器，可以使用嵌套把有关联的代码分到一组: .site-nav { display: flex; \u003e li { margin-top: 0; // \u0026符号表示将插入外层选择器的位置 \u0026.is-active { display: block; } } } 编译如下: .site-nav { display: flex; } .site-nav \u003e li { margin-top: 0; } .site-nav \u003e li.is-active { display: block; } 默认情况下，外层的.site-nav选择器会自动添加到编译代码的每个选择器前面，拼接的位置会插入一个空格。使用\u0026符号代表外层选择器要插入的位置。 也可以在声明块内嵌套媒体查询用以避免重复书写相同选择器: html { font-size: 1rem; @media (min-width: 45em) { font-size: 1.25rem; } } 编译结果如下: html { font-size: 1rem; } @media (min-width: 45em) { html { font-size: 1.25rem; } } 这样一来，若修改选择器就不必再去媒体查询中修改对应的选择器。 局部文件(@import)局部文件允许我们将样式分割成多个独立的文件，Sass 将会把这些文件拼接在一起生成一个文件。 新建sass/button.scss文件，添加如下内容: .button { padding: 1em 1.25em; background-color: #265559; color: #333; } 在sass/index.scss文件中引入: @import \"button\"; html { font-family: Arial, Helvetica, sans-serif; } 编译结果如下: .button { padding: 1em 1.25em; background-color: #265559; color: #333; } html { font-family: Arial, Helvetica, sans-serif; } 局部文件会被编译，然后插入到@import规则指定的地方。 混入混入（mixin）是一小段 CSS 代码块，可以在样式表任意地方复用。如果有一段特定的字体样式在多个地方需要使用，使用混入就比较合适。 混入用@mixin规则来定义，用@include规则来调用。 清除浮动: @mixin clearfix { \u0026::before { display: table; content: \" \"; } \u0026::after { clear: both; } } .media { @include clearfix; background-color: #eee; } 预处理器会提取 mixin 中的代码，替换到@include规则所在位置。 .media { background-color: #eee; } .media::before { display: table; content: \" \"; } .media::after { clear: both; } 需要注意的是，最终编译生成的代码中没有了 clearfix。混入的内容只会添加到样式表中用到了它的地方。 我们还可以定义带参数的混入: @mixin alert-variant($color, $bg-color) { padding: 0.3em 0.5em; border: 1px solid $color; color: $color; background-color: $bg-color; } .alert-info { @include alert-variant(blue, lightblue); } .alert-danger { @include alert-variant(red, pink); } 每次调用混入，都可以传递不同的值。这些值指定为对应的两个变量，最终输出的 CSS 如下: .alert-info { padding: 0.3em 0.5em; border: 1px solid blue; color: blue; background-color: lightblue; } .alert-danger { padding: 0.3em 0.5em; border: 1px solid red; color: red; background-color: pink; } 扩展Sass 还支持@extend规则。和 mixin 类似，但编译方式有所不同。对于扩展，Sass 不会多次复制相同的声明，而是把选择器组合在一起，这样它们就会包含同样的规则。 .message { padding: 0.3em 0.5em; border-radius: 0.5em; } .message-info { @extend .message; color: blue; background-color: lightblue; } .message-danger { @extend .message; color: red; background-color: pink; } .message包含的规则被扩展到另外两个规则集中。 .message, .message-info, .message-danger { padding: 0.3em 0.5em; border-radius: 0.5em; } .message-info { color: blue; background-color: lightblue; } .message-danger { color: red; background-color: pink; } 使用mixin还是extend，需要具体情况具体分析。通常情况下，可能更倾向用mixin，只有需要减少 HTML 中填写的类名数量时才考虑使用@extend。 颜色处理Sass 还有一个特性就是颜色处理函数，如果需要两个同类的颜色（比如，同一种颜色的深浅版本），可以用如下代码来生成: $green: #63a53c; // 加深10% $green-dark: darken($green, 10%); $green-light: lighten($green, 10%); // 调整透明度 $green-transparent: rgba($green, 0.5); 通过这些函数，可以实现修改一个变量，同时修改相关联的其他颜色值。这样就","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:18:1","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" PostCSSPostCSS 是另一种类型的预处理器。它编译源文件并输出一个处理过的 CSS 文件，这和 Sass 或者 Less 一样，但 PostCSS 是依靠插件工作的。若没有安装插件，输出文件就是没有任何变化的源文件副本。 搭建环境使用npm init -y初始化一个新的 npm 项目。 使用npm install --save-dev gulp安装gulp包。 AutoprefixerPostCSS 中最重要的插件可能就是 Autoprefixer，这个插件可以将相关的所有浏览器前缀都添加到 CSS 中。 为了使用Autoprefixer，我们使用命令npm install --save-dev gulp-atuoprefixer进行安装。 之后在项目根目录创建一个名为gulpfile.js的文件，添加如下内容: const gulp = require(\"gulp\"); const autoprefixer = require(\"gulp-autoprefixer\"); gulp.task(\"prefix\", () =\u003e { gulp .src(\"./css/*.css\") .pipe( autoprefixer({ cascade: false, }) ) .pipe(gulp.dest(\"./dist\")); }); 新建css目录，在其中的index.css文件中添加如下内容: .fullscreen a { display: flex; } 在package.json文件中加入以下内容: \"scripts\": { \"gulp\": \"gulp prefix\" }, \"browserslist\": [ \"last 99 versions\" ], 打开命令行执行npm run gulp。可以看到生成了一个新目录dist，其中有一个名为index.css的文件，内容如下: .fullscreen a { display: -webkit-box; display: -webkit-flex; display: -moz-box; display: -ms-flexbox; display: flex; } cssnextcssnext 是另一款非常流行的 PostCSS 插件。这款插件模拟那些还没有受所有浏览器支持的最新 CSS 语法。 cssnanocssnano 是基于 PostCSS 的压缩工具。可以从代码中剥离无关的空格，使代码体积尽可能变小，但同时依然保持相同的语法含义。 PreCSSPreCSS 是一款 PostCSS 插件包，提供了类似于 Sass 的特性，其中包含了$变量、行内计算、循环和混入等。 更多 PostCSS 插件，请看PostCSS Plugins。 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:18:2","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 项目 纸上得来终觉浅，绝知此事要躬行。 要想完全掌握书上的内容还得不断练习回顾，以下为练习项目。 Parallax scroll animation: https://codepen.io/isladjan/pen/abdyPBw Voyage Slider | GSAP: https://codepen.io/dev_loop/pen/MWKbJmO App Menu With Lock Screen: https://codepen.io/Hyperplexed/details/vYpXNJd Old Film Effect - Pure CSS Animation: https://codepen.io/josetxu/pen/yLjwOwQ How I recreated a Polaroid camera with CSS gradients only ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:19:0","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":" 参考《深入解析 CSS》 ","date":"2024-02-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:20:0","tags":["CSS","Web"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["JavaScript"],"content":"Axios是一个基于 Promise 的 HTTP 客户端，我们可以在浏览器和 Node.js 中使用它。Axios 使向 REST 端点发送异步 HTTP 请求和执行 CRUD 操作变得更加容易。它可以在纯 JavaScript 中使用，也可以在 Vue 或者 React 之类的库中使用。 先看一个在浏览器中使用 Axios 的例子，我们发送一个请求到https://api.github.com/users/USERNAME，以获取到用户的一些信息。 新建一个名为 1.html 的文件，代码如下： \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e\u003c/head\u003e \u003ctitle\u003eAxios\u003c/title\u003e \u003cbody\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"main.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e main.js 代码如下： axios.get(\"https://api.github.com/users/andyfree96\").then(response =\u003e { console.log(response.data); }).catch(error =\u003e { console.log(\"ERROR!\"); }); 启动服务器， 如果您没有安装http-server的话，请自行安装一下。 打开浏览器，就可以看到： 成功获取到用户信息。 之后的教程将在 Node.js 中使用 Axios，而不是在浏览器。 ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:0:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":" 安装 Axios本文使用的 Node.js 版本是： 初始化一个 Node.js 应用， npm init -y 在命令行中输入npm i axios安装即可。 ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:1:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":" Axios 的响应对象当我们发送一个请求给服务器后，它会返回一个响应。Axios 的响应对象包含如下内容： data - 服务器返回的响应主体数据 status - 服务器返回的响应状态码 statusText - 返回的状态信息 headers - 返回的头部信息 config - 请求的配置信息 request - 请求对象 ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:2:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":" Axios 的 GET 请求我们以回调函数或者 async/await 的方式发送 Get 请求。 回调函数： const axios = require(\"axios\"); axios.get(\"https://api.github.com/users/andyfree96\").then((response) =\u003e { console.log(response.status); console.log(response.statusText); console.log(response.data); }); 结果如下： async/await： const axios = require(\"axios\"); async function makeGetRequest() { let response = await axios.get(\"https://httpbin.org/get\"); let data = response.data; console.log(data); console.log(response.request._header); } makeGetRequest(); 结果如下： ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:3:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":" Axios 的 HEAD 请求HEAD 请求是一个没有消息体的 GET 请求。 const axios = require(\"axios\"); async function makeHeadRequest() { let response = await axios.head(\"http://www.baidu.com\"); console.log(`status: ${response.status}`); console.log(`server : ${response.headers.server}`); console.log(response.headers); } makeHeadRequest(); Axios 有两个基本的 API： axios(config) axios(url, config) const axios = require(\"axios\"); async function makeRequest() { const config = { method: \"get\", }; const url = \"http://httpbin.org/get\"; let response = await axios(url, config); console.log(response.data); } makeRequest(); ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:4:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":" Axios 自定义头部 const axios = require(\"axios\"); async function makeRequest() { const config = { method: \"get\", url: \"http://www.baidu.com\", headers: { \"User-Agent\": \"5.js\" }, }; let response = await axios(config); console.log(response.request._header); } makeRequest(); 这里我们自定义了一个请求头部： const config = { method: \"get\", url: \"http://www.baidu.com\", headers: { \"User-Agent\": \"5.js\" }, }; ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:5:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":" Axios 的 POST 请求 const axios = require(\"axios\"); async function makePostRequest() { let response = await axios.post(\"https://httpbin.org/post\"); console.log(response.data); } makePostRequest(); ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:6:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":" 下载图片 const axios = require(\"axios\"); const fs = require(\"fs\"); async function getImage(url) { const config = { responseType: \"stream\", }; let response = await axios.get(url, config); response.data.pipe(fs.createWriteStream(\"./image.png\")); } getImage( \"https://himg.bdimg.com/sys/portraitn/item/856f6c656f73636f74743936f939\" ); 我们在 config 对象中指明返回类型。 ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:7:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":" 多个请求我们可以用 Axios 一次性创建多个请求。 const axios = require(\"axios\"); async function makeRequests() { let [response1, response2] = await Promise.all([ axios.get(\"https://api.github.com/users/andyfree96\"), axios.get(\"https://api.github.com/users/google\"), ]); console.log(response1.data.created_at); console.log(response2.data.created_at); } makeRequests(); ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:8:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":" JSON ServerJSON Server 是一个很棒的工具，可以让我们轻松地伪造 REST API。 我们先安装json-server: npm i -g json-server 创建一个名为 employees.json 的文件，添加如下内容： { \"employees\": [ { \"id\": 1, \"first_name\": \"Sebastian\", \"last_name\": \"Eschweiler\", \"email\": \"sebastian@codingthesmartway.com\" }, { \"id\": 2, \"first_name\": \"Steve\", \"last_name\": \"Palmer\", \"email\": \"steve@codingthesmartway.com\" }, { \"id\": 3, \"first_name\": \"Ann\", \"last_name\": \"Smith\", \"email\": \"ann@codingthesmartway.com\" } ] } 关于 JSON Server 创建 REST API 可以看下文。 Create A REST API With JSON Server: https://medium.com/codingthesmartway-com-blog/create-a-rest-api-with-json-server-36da8680136d 接下来我们可以启动 JSON Server， json-server --watch employees.json 访问http://localhost:3000/employees可以看到： 接下来我们可以使用 Axios 添加员工， const axios = require(\"axios\"); async function makePostRequest() { const params = { id: 4, first_name: \"Andy\", last_name: \"Scott\", email: \"andyfree96@126.com\", }; let response = await axios.post(\"http://localhost:3000/employees/\", params); console.log(response.data); } makePostRequest(); 获取员工, const axios = require(\"axios\"); async function makeRequest() { let response = await axios.get(\"http://localhost:3000/employees\"); console.log(response.data); } makeRequest(); 删除员工, const axios = require(\"axios\"); async function makeDeleteRequest() { let response = axios.delete(\"http://localhost:3000/employees/4/\"); console.log(response.data); } makeDeleteRequest(); ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:9:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":" 参考Axios tutorial: http://zetcode.com/javascript/axios/ ","date":"2024-02-24","objectID":"/axios%E6%95%99%E7%A8%8B/:10:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"}]