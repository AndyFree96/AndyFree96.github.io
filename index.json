[{"categories":["源码剖析"],"content":" 纸上得来终觉浅，绝知此事要躬行。——陆游《冬夜读书示子聿》 csv2是一个轻量级 C++ 库，用于将 CSV 文件解析为 C++ 中的 STL 容器。该库的主要功能是高效地处理 CSV 数据，简化了处理 CSV 文件的代码编写过程。以下是它的主要特性： 简单易用：通过使用 STL 容器（如 std::vector 和 std::tuple），使得开发者能够轻松将 CSV 文件的内容转换为标准 C++ 数据结构。 依赖少：该库只有 C++17 标准库的依赖，因此不需要额外的第三方库。 高效解析：该库采用高效的解析机制，支持处理大型 CSV 文件。 轻量级：代码库很小，适用于嵌入式或对依赖库要求较高的项目。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:0:0","tags":["CSV","C++","源码剖析"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r准备项目源代码地址为p-ranav/csv2 v1.0。 阅读工具为 CLion。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:1:0","tags":["CSV","C++","源码剖析"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r剖析整个项目包含 4 个文件，分别是: reader.hpp、mio.hpp、writer.hpp和parameters.hpp。 .c vs .cc vs. .cpp vs .hpp vs .h vs .cxx: 由于历史渊源，造成头文件和源代码文件有些不同的命名方式，但本质而言没有什么区别。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:2:0","tags":["CSV","C++","源码剖析"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\rreader.hppreader.hpp 文件中主要定义了一个名为Reader的类。数据部分主要有: 紧接着定义了两个方法: mmap和parse，分别从文件和字符串内容解析内容。 从文件中解析内容: #include \"csv2/reader.hpp\" #include \u003cstring\u003e using namespace std; int main(){ csv2::Reader\u003ccsv2::delimiter\u003c','\u003e, csv2::quote_character\u003c'\"'\u003e, csv2::first_row_is_header\u003ctrue\u003e, csv2::trim_policy::trim_whitespace\u003e csv; std::string content = \"Name, Age\\nPeter, 12\\nLucy, 78\"; if(csv.parse(content)){ const auto header = csv.header(); for (const auto row: csv) { for (const auto cell: row) { // Do something with cell value std::string value; cell.read_value(value); cout \u003c\u003c value \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; } } } 从字符串中解析内容: #include \"csv2/reader.hpp\" #include \u003cstring\u003e using namespace std; int main(){ csv2::Reader\u003ccsv2::delimiter\u003c','\u003e, csv2::quote_character\u003c'\"'\u003e, csv2::first_row_is_header\u003ctrue\u003e, csv2::trim_policy::trim_whitespace\u003e csv; if(csv.mmap(\"demo.csv\")){ const auto header = csv.header(); for (const auto row: csv) { for (const auto cell: row) { // Do something with cell value std::string value; cell.read_value(value); cout \u003c\u003c value \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; } } } parse方法中使用了知识点 10。 reader.hpp 中还定义了Cell、Row、RowIterator等类。 为了方便在之后的类中使用 RowIterator、Row 和 CellIterator，文件中加了 forward-declaration，如上图所示。 CellCell 类的数据部分定义如下: 其中的buffer_指向 memory-mapped buffer，可参考知识点 4，我们可以简单的将其理解为指向数据内容的一个指针。 主要包括两个方法: read_raw_value和read_value，两个方法稍有区别，前者处理无转义字符，后者处理有转义字符。 RowRow 类的数据部分定义如下: 和 Cell 类的定义大同小异。Row 类中还定义了另一个类 CellIterator: class CellIterator { friend class Row; const char *buffer_; size_t buffer_size_; size_t start_; size_t current_; size_t end_; public: CellIterator(const char *buffer, size_t buffer_size, size_t start, size_t end) : buffer_(buffer), buffer_size_(buffer_size), start_(start), current_(start_), end_(end) { } CellIterator \u0026operator++() { current_ += 1; return *this; } Cell operator*() { bool escaped{false}; class Cell cell; cell.buffer_ = buffer_; cell.start_ = current_; cell.end_ = end_; size_t last_quote_location = 0; bool quote_opened = false; for (auto i = current_; i \u003c end_; i++) { current_ = i; if (buffer_[i] == delimiter::value \u0026\u0026 !quote_opened) { // actual delimiter // end of cell cell.end_ = current_; cell.escaped_ = escaped; return cell; } else { if (buffer_[i] == quote_character::value) { if (!quote_opened) { // first quote for this cell quote_opened = true; last_quote_location = i; } else { escaped = (last_quote_location == i - 1); last_quote_location += (i - last_quote_location) * size_t(!escaped); quote_opened = escaped || (buffer_[i + 1] != delimiter::value); } } } } cell.end_ = current_ + 1; return cell; } bool operator!=(const CellIterator \u0026rhs) { return current_ != rhs.current_; } }; CellIterator 中定义了自增操作符、取值操作符和不等操作符。Iterator 必须实现这三个操作符: #include \u003ciostream\u003e using namespace std; // forward-declaration to allow use in Iter class IntVector; class Iter { public: Iter (const IntVector* p_vec, int pos) : _pos( pos ) , _p_vec( p_vec ) { } // these three methods form the basis of an iterator for use with // a range-based for loop bool operator!= (const Iter\u0026 other) const { return _pos != other._pos; } // this method must be defined after the definition of IntVector // since it needs to use it int operator* () const; const Iter\u0026 operator++ () { ++_pos; // although not strictly necessary for a range-based for loop // following the normal convention of returning a value from // operator++ is a good idea. return *this; } private: int _pos; const IntVector *_p_vec; }; class IntVector { public: IntVector () { } int get (int col) const { return _data[ col ]; } Iter begin () const { return Iter( this, 0 ); } Iter end () const { return Iter( this, 100 ); } void set (int index, int val) { _data[ index ] = val; } private: int _data[ 100 ]; }; int Iter::operator* () const { return _p_vec-\u003eget( _pos ); } // sample usage of the range-based for loop on IntVector int main() { IntVector v; for ( int i = 0; i \u003c 100; i++ ) { v.set( i , i ); } for ( int i : v ) { cout \u003c\u003c i \u003c\u003c endl; } } C++ 11 range-based for loops: https://www.cprogramming.com/","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:2:1","tags":["CSV","C++","源码剖析"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\rmio.hppmio.hpp 相比与其他三个文件的代码多了不少，也复杂了许多。文件一开始定义了template \u003caccess_mode AccessMode, typename ByteT\u003e struct basic_mmap结构体，然后围绕这个结构体声明了一系列操作符: 其定义在行号 1058 处: 之后定义了 5 个工厂方法，方便构建mmap、mmap_source以及mmap_sink对象: 然后在 587 处开始定义了字符串相关的工具函数: 在 684 处开始定义了与 Windows 平台相关的open_file_helper函数。 然后定义了template \u003ctypename String\u003e file_handle_type open_file，inline size_t query_file_size和inline mmap_context memory_map函数，以及struct mmap_context结构体。之后，实现了许多在template \u003caccess_mode AccessMode, typename ByteT\u003e struct basic_mmap声明的方法。 最后定义了template \u003caccess_mode AccessMode, typename ByteT\u003e class basic_shared_mmap类。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:2:2","tags":["CSV","C++","源码剖析"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\rwriter.hppwriter.hpp 中包含将数据导出的功能。主要定义了两个方法:write_row和write_rows，代表写入一行和写入多行。 例如，将数据写入到文件中: #include \u003ccsv2/reader.hpp\u003e #include \u003ccsv2/parameters.hpp\u003e #include \u003ccsv2/mio.hpp\u003e #include \u003ccsv2/writer.hpp\u003e #include \u003ciostream\u003e #include \u003costream\u003e #include \u003cvector\u003e #include \u003cstring\u003e using namespace csv2; using namespace std; int main() { std::ofstream out(\"info.csv\"); csv2::Writer\u003ccsv2::delimiter\u003c','\u003e, std::ofstream\u003e writer(out); std::vector\u003cstd::string\u003e header = { \"Name\", \"Age\" }; std::vector\u003cstd::vector\u003cstd::string\u003e\u003e content{ {\"Andy\", \"19\"}, {\"Peter\", \"21\"}, {\"Lucas\", \"20\"} }; writer.write_row(header); writer.write_rows(content); } ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:2:3","tags":["CSV","C++","源码剖析"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\rparameters.hpp首先，为了组织代码引入了trim_policy命名空间。 包含了no_trimming、trim_characters两个结构体，以及using trim_whitespace = trim_characters\u003c' ', '\\t'\u003e;一句，于是给空白符' '和'\\t'新的使用方式——trim_whitespace。需要注意的是，该标识符在trim_policy命名空间中。 此外，还包含delimiter、quote_character以及first_row_is_header三个结构体，和之前不同的是它们在csv2命令空间中。 整个文件的结构体里面的方法或数据都是static的，表示我们可以用delimiter\u003c':'\u003e::value的方式直接获取里面的数据，而不用实例化（实例化从逻辑上好像也有一些问题，同样是用:作为分隔符却实例化了两个不同的对象，有点奇怪）。 关于可变参数模板可看知识点 5。 pair 的使用: https://cplusplus.com/reference/utility/pair/pair/ ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:2:4","tags":["CSV","C++","源码剖析"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r知识点","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:0","tags":["CSV","C++","源码剖析"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r1. CMake 项目添加第三方库在 CMakeLists.txt 中添加如下语句: 即可将三方库的头文件包含进来。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:1","tags":["CSV","C++","源码剖析"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r2. Static Const 使用mio.hpp 中有如下一段代码: /** * Determines the operating system's page allocation granularity. * * On the first call to this function, it invokes the operating system specific syscall * to determine the page size, caches the value, and returns it. Any subsequent call to * this function serves the cached value, so no further syscalls are made. */ inline size_t page_size() { static const size_t page_size = [] { #ifdef _WIN32 SYSTEM_INFO SystemInfo; GetSystemInfo(\u0026SystemInfo); return SystemInfo.dwAllocationGranularity; #else return sysconf(_SC_PAGE_SIZE); #endif }(); return page_size; } page_size()内部的匿名函数只会运行一次，得益于static const声明，这样可以避免重复调用sysconf()函数（如注释所述）。 https://www.tutorialspoint.com/static-const-vs-hashdefine-vs-enum ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:2","tags":["CSV","C++","源码剖析"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r3. static_assertmio.hpp 中有static_assert的写法。 static_assert declaration: https://en.cppreference.com/w/cpp/language/static_assert Understanding static_assert in C++ 11: https://www.geeksforgeeks.org/understanding-static_assert-c-11/ ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:3","tags":["CSV","C++","源码剖析"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r4. mmapmio.hpp 中的memory_map函数使用了mmap。 Use the mmap Function to Write to the Memory in C Shared Memory: https://kuafu1994.github.io/MoreOnMemory/sharedMemory.html mapread.c 和 mapwrite.c: https://gist.github.com/marcetcheverry/991042 Memory Mapped I/O: https://www.cs.uleth.ca/~holzmann/C/system/mmap.html 存储映射 I/O存储映射 I/O（Memory-Mapped I/O）能将一个磁盘文件映射到存储空间的一个缓冲区上，当从缓冲区中取数据时，就相当于读文件中的相应字节。与此类似，将数据存入缓冲区时，相应字节就自动写入文件。如此一来，就可以在不调用 read 和 write 的情况下执行 I/O。——《UNIX 环境高级编程》14.8 节 探索内存原理的内存映射文件: https://zhuanlan.zhihu.com/p/429987335 File Mapping in C++ Applications: https://www.geeksforgeeks.org/file-mapping-in-cpp-applications/ File Mapping: https://learn.microsoft.com/en-us/windows/win32/memory/file-mapping Mapping files into virtual memory in C on windows: https://stackoverflow.com/questions/68368291/mapping-files-into-virtual-memory-in-c-on-windows 示例代码: #include \u003ccstdio\u003e #include \u003cwindows.h\u003e #include \u003ciostream\u003e using namespace std; int main(int argc, char* argv[]) { const TCHAR* lpFileName = TEXT(\"hello.txt\"); HANDLE hFile; HANDLE hMap; LPVOID lpBasePtr; LARGE_INTEGER liFileSize; hFile = CreateFile(lpFileName, GENERIC_READ, // dwDesiredAccess 0, // dwShareMode NULL, // lpSecurityAttributes OPEN_EXISTING, // dwCreationDisposition FILE_ATTRIBUTE_NORMAL, // dwFlagsAndAttributes 0); // hTemplateFile if (hFile == INVALID_HANDLE_VALUE) { fprintf(stderr, \"CreateFile failed with error %d\\n\", GetLastError()); return 1; } if (!GetFileSizeEx(hFile, \u0026liFileSize)) { fprintf(stderr, \"GetFileSize failed with error %d\\n\", GetLastError()); CloseHandle(hFile); return 1; } if (liFileSize.QuadPart == 0) { fprintf(stderr, \"File is empty\\n\"); CloseHandle(hFile); return 1; } hMap = CreateFileMapping( hFile, NULL, // Mapping attributes PAGE_READONLY, // Protection flags 0, // MaximumSizeHigh 0, // MaximumSizeLow NULL); // Name if (hMap == 0) { fprintf(stderr, \"CreateFileMapping failed with error %d\\n\", GetLastError()); CloseHandle(hFile); return 1; } lpBasePtr = MapViewOfFile( hMap, FILE_MAP_READ, // dwDesiredAccess 0, // dwFileOffsetHigh 0, // dwFileOffsetLow 0); // dwNumberOfBytesToMap if (lpBasePtr == NULL) { fprintf(stderr, \"MapViewOfFile failed with error %d\\n\", GetLastError()); CloseHandle(hMap); CloseHandle(hFile); return 1; } // Display file content as ASCII charaters char* ptr = (char*)lpBasePtr; LONGLONG i = liFileSize.QuadPart; while (i-- \u003e 0) { fputc(*ptr++, stdout); } UnmapViewOfFile(lpBasePtr); CloseHandle(hMap); CloseHandle(hFile); printf(\"\\nDone\\n\"); } ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:4","tags":["CSV","C++","源码剖析"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r5. 可变参数模板在 parameters.hpp 中使用了可变参数模板（Variadic Template Function）。 C++11 – Variadic Template Function | Tutorial \u0026 Examples template\u003ctypename T\u003e void logging(T t){ cout \u003c\u003c t; cout \u003c\u003c \"\\nLast Call\\n\"; } template\u003ctypename T, typename ... Args\u003e void logging(T first, Args... args){ cout \u003c\u003c first \u003c\u003c \", \"; logging(args...); } ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:5","tags":["CSV","C++","源码剖析"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r6. #pragma onceWhat does #pragma once mean in C? 截至到 2023 年为止，主流的编译器都支持#pragma once。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:6","tags":["CSV","C++","源码剖析"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r7. __has_include()根据Source file inclusion的描述，__has_include()可以用来检测某个头文件是否存在，但此时并没有将其引入。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:7","tags":["CSV","C++","源码剖析"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r8. defined(identifier)reader.hpp 中有#if defined(identifier)一句。 #if, #elif, #else, and #endif directives ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:8","tags":["CSV","C++","源码剖析"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r9. 模板默认参数reader.hpp 有默认模板参数的写法: 在 C++ 17 之前，如果不用任何模板参数且正常使用 Reader 类的话，需要使用如下语法: Reader\u003c\u003e reader; 将 CMakeLists.txt 中的 C++版本由 14 set(CMAKE_CXX_STANDARD 14) 改为 17 set(CMAKE_CXX_STANDARD 17) 即可用如下轻便的语法使用 Reader。 Reader reader; ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:9","tags":["CSV","C++","源码剖析"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r10. std::forwardhttps://cplusplus.com/reference/utility/forward/ 通过使用std::forward函数可以根据实参调用不同的函数，如下面例子所示: #include \u003cutility\u003e // std::forward #include \u003ciostream\u003e // std::cout // function with lvalue and rvalue reference overloads: void overloaded (const int\u0026 x) {std::cout \u003c\u003c \"[lvalue]\";} void overloaded (int\u0026\u0026 x) {std::cout \u003c\u003c \"[rvalue]\";} // function template taking rvalue reference to deduced type: template \u003cclass T\u003e void fn (T\u0026\u0026 x) { overloaded (x); // always an lvalue overloaded (std::forward\u003cT\u003e(x)); // rvalue if argument is rvalue } int main () { int a; std::cout \u003c\u003c \"calling fn with lvalue: \"; fn (a); std::cout \u003c\u003c '\\n'; std::cout \u003c\u003c \"calling fn with rvalue: \"; fn (0); std::cout \u003c\u003c '\\n'; return 0; } ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:10","tags":["CSV","C++","源码剖析"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r11. std::stringhttps://cplusplus.com/reference/string/string/ string::erase 可用于清除指定位置的字符。 string::reserve 可用于指定 string 存储空间的大小。 string::push_back 可将字符存入 string 中。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:3:11","tags":["CSV","C++","源码剖析"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":["源码剖析"],"content":"\r最后项目中涉及到的存储映射 I/O ，若要想彻底弄清楚机制，可能需要补充一些操作系统方面的知识。 ","date":"2024-10-07","objectID":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/:4:0","tags":["CSV","C++","源码剖析"],"title":"csv2源码剖析","uri":"/csv2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"},{"categories":null,"content":"\r项目json-tutorial: 从零开始的 JSON 库教程 http-parser: http request/response parser for c mongoose: Embedded Web Server xgboost: Scalable, Portable and Distributed Gradient Boosting (GBDT, GBRT or GBM) Library, for Python, R, Java, Scala, C++ and more. Runs on single machine, Hadoop, Spark, Dask, Flink and DataFlow darknet: Convolutional Neural Networks ","date":"2024-02-26","objectID":"/resource/:1:0","tags":null,"title":"资源","uri":"/resource/"},{"categories":null,"content":"\r2024Stanford CS107 Programming Paradigms 编程范式 清华大学 操作系统 清华大学 经济学原理 耶鲁大学 聆听音乐 Machine Learning 2022 Spring Deep Learning for Human Language Processing 2020 Spring 6.824 Schedule: Spring 2022 ","date":"2024-02-25","objectID":"/opencourse/:1:0","tags":null,"title":"公开课","uri":"/opencourse/"},{"categories":null,"content":"\r2024","date":"2024-02-25","objectID":"/book/:1:0","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r计算机JavaScript 高级程序设计 第 4 版 Unix\u0026Linux 大学教程 学习 JavaScript 数据结构与算法 第 3 版 Hands-on Machine Learning with Scikit-Learn, Keras \u0026 TensorFlow 2nd Edition 编写可读代码的艺术 ","date":"2024-02-25","objectID":"/book/:1:1","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r文学红楼梦 金瓶梅 ","date":"2024-02-25","objectID":"/book/:1:2","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r传记王安石传 毛泽东传 ","date":"2024-02-25","objectID":"/book/:1:3","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r经济经济学原理 ","date":"2024-02-25","objectID":"/book/:1:4","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r饮食一日一果 ","date":"2024-02-25","objectID":"/book/:1:5","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r写作文心 ","date":"2024-02-25","objectID":"/book/:1:6","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r哲学哲学家们都干了些什么 苏菲的世界 理想国 ","date":"2024-02-25","objectID":"/book/:1:7","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r政治政治学通识 ","date":"2024-02-25","objectID":"/book/:1:8","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r电影认识电影 ","date":"2024-02-25","objectID":"/book/:1:9","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r历史明朝那些事儿 万历十五年 ","date":"2024-02-25","objectID":"/book/:1:10","tags":null,"title":"书单","uri":"/book/"},{"categories":null,"content":"\r2024 # 标题 年份 论文 代码 状态 1 You Only Look Once: Unified, Real-Time Object Detection 2015 Link Link ❎ 2 YOLOv4: Optimal Speed and Accuracy of Object Detection 2020 Link Link ❎ 3 A Neural Algorithm of Artistic Style 2015 Link Link ❎ ","date":"2024-02-25","objectID":"/paper/:1:0","tags":null,"title":"论文","uri":"/paper/"},{"categories":null,"content":"\r简介一个热爱学习的东尼君 ","date":"2024-02-25","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":["计算机网络"],"content":" 2024/1/17 更新: 增加进程间通信 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:0:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r理解网络编程和套接字","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r理解网络编程和套接字网络编程中接受连接请求的套接字创建过程如下: 调用socket函数创建套接字 调用bind函数分配 IP 地址和端口号 调用listen函数转为可接收请求和状态 调用accpet函数受理连接请求 客户端程序只有“调用 socket 函数创建套接字”和“调用 connect 函数向服务器发送连接请求”两个步骤。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:1","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r基于 Linux 的文件操作对 Linux 而言，socket 操作与文件操作没有区别，socket 被认为是文件的一种，因此在网络数据传输过程中自然可以使用文件 I/O 的相关函数。Windows 和 Linux 不同，区分二者。 文件描述符只不过是为了方便称呼操作系统创建的文件或套接字而赋予的数而已。文件描述符有时也称为句柄，但“句柄”主要是 Windows 中的术语。 在项目中，为了给基本数据类型赋予别名，一般会添加大量的typedef声明。为了与程序员定义的新数据类型加以区分，操作系统定义的数据类型会添加后缀_t，例如size_t、ssize_t等。 文件描述符从 3 开始由小到大顺序编号，因为 0、1、2 分配给标准 I/O 的描述符。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:2","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r基于 Windows 平台的实现Windows 套接字（简称 Winsock）大部分是参考 BSD 系列的 UNIX 套接字设计的。 为了在 Windows 基础上开发网络程序，需要做如下准备。 导入头文件winsock2.h 链接ws2_32.lib库 Winsock 编程时必须首先调用WSAStartup函数，设置程序中用到的 Winsock 版本，并初始化相应版本的库。 注销该库使用如下函数: ##include \u003ciostream\u003e ##include \u003cWinSock2.h\u003e int main() { WSADATA wsaData; if (WSAStartup(MAKEWORD(2, 2), \u0026wsaData) != 0) { std::cout \u003c\u003c \"WSAStartup ERROR!\" \u003c\u003c std::endl; } WSACleanup(); return 0; } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:3","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r套接字类型与协议设置协议是计算机对话使用的通信规则。 ##include \u003csys/socket.h\u003e int socket(int domain, int type, int protocol); // 成功返回文件描述符，失败时返回-1 domain套接字使用的协议族信息 type套接字数据传输类型信息 protocol计算机间通信中使用的协议信息 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r协议族套接字通信中的协议有一些分类，通过socket函数的第一个参数传递套接字中使用的协议分类信息。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:1","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r套接字类型套接字类型指的是套接字的数据传输方式，通过socket函数的第二个参数传递，只有这样才能决定创建的套接字的数据传输方式。为什么通过第一个参数传递了协议族信息，还要决定数据传输方式？这是因为决定了协议族并不能同时决定数据传输方式，换而言之，socket函数第一个参数PF_INET协议族中也存在多种数据传输方式。 面向连接的套接字（SOCK_STREAM）可靠的、按序传递的、基于字节的面向连接的数据传输方式的套接字。（传送带传输，收和发套接字都有缓存，多次write可能只需要一次read，即二者的次数可以不等，传输的数据不存在数据边界） 面向消息的套接字（SOCK_DGRAM）不可靠的、不按序传递的、以数据的高速传递为目的的套接字（摩托车传输，发一次得收一次，传输的数据存在数据边界）。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:2","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r协议的最终选择socket函数的前两个参数传递了协议族的信息和套接字数据传输方式，这些信息还不足以决定采用的协议吗？为什么还需要传递第 3 个参数？ 前两个参数即可创建所需套接字。所以大部分情况下可以向第三个参数传递 0，除非遇到以下情况: 同一个协议族中存在多个传输方式相同的协议 数据传输方式相同，但协议不同。此时需要通过第三个参数具体指定协议信息。 比如，创建“IPv4 协议族面向连接的套接字”。 参数PF_INET指 IPv4 网络协议族，SOCK_STREAM是面向连接的数据传输。满足这两个条的协议只有IPPROTO_TCP，这种套接字称为 TCP 套接字。 int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); 再比如，创建“IPv4 协议族面向消息的套接字”。 满足上述条件的协议只有IPPROTO_UDP，这种套接字称为 UDP 套接字。 int udp_socket = socket(PF_INET, SOCKET_STREAM, IPPROTO_UDP); ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:3","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r地址族与数据序列","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r分配给套接字的 IP 地址和端口号IP 是 Internet Protocol（网络协议）的简写，是为收发网络数据而分配给计算机的值。端口号并非赋予计算机的值，而是为区分程序中创建的套接字而分配给套接字的序号。 网络地址（Internet Address）为让计算机连接到网络并收发数据，需向其分配 IP 地址。IP 地址分为两类。 IPv4（Internet Protocol version 4） 4 字节地址族 IPv6（Internet Protocol version 6） 16 字节地址族 网络地址（网络 ID）是为区分网络而设置的一部分 IP 地址。传输数据时，并非一开始就浏览所有 4 字节 IP 地址，进而找到目标主机；而是仅浏览 4 字节 IP 地址的网络地址，向把数据传到网络。网络（构成网络的路由器（Router）或交换机（Switch））接到数据后，浏览传输数据的主机地址（主机 ID）并将数据传给目标计算机。 构建网络需要一种物理设备完成外网与本网主机之间的数据交换，这种设备便是路由器或交换机。它们也是一种计算机，只不过为了特殊目的而设计运行的，因而有了别名。我们可在自己的计算机中安装适当的软件，也可以将其作为交换机。交换机的功能比路由器简单一些，实际差别不大。 网络地址分类与主机地址边界只需通过 IP 地址的第一个字节即可判断网络地址占用的字节数: 用于区分套接字的端口号计算机中一般配有 NIC（Network Interface Card，网络接口卡）数据传输设备。通过 NIC 向计算机内部传输数据时会用到 IP。操作系统负责把传递到内部的数据适当分配给套接字，这时就要利用端口号。也就是说，通过 NIC 收到的数据内有端口号，操作系统参考此端口号把数据传输给相应端口的套接字。 端口号是在同意操作系统内为区分不同套接字而设置的，因此无法将一个端口号分配给不同套接字。端口号由 16 位构成，可分配的端口号范围是 0~65535。但 0~1023 是知名端口号（Wll-known PORT），一般分配给特定应用程序。TCP 套接字和 UDP 套接字不会公用端口号，所以允许重复。 数据传输目标地址同时包含 IP 地址和端口号，只有这样，数据才会被传输到最终的目的应用程序（应用程序套接字）。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:1","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r地址信息的表示\r表示 IPv4 地址的结构体 struct sockaddr_in { sa_family_t sin_family; // 地址族(Address Family) uint16_t sin_port; // 16位TCP/UDP端口号 struct in_addr sin_addr; // 32位IP地址 char sin_zero[8]; // 不使用 } in_addr定义如下: struct in_addr { In_addr_t s_addr; // 32位IPv4地址 }; 结构体sockaddr_in的成员分析","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:2","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r网络字节序与地址转换\r字节序（Order）与网络字节序CPU 向内存保存数据的方式有两种: 大端序（Big Endian）: 高位字节放到低位地址 小端序（Little Endian）: 高位字节放到高位地址 主流的 Intel 系列 CPU 以小端序方式保存数据。 在通过网络传输数据时约定统一的方式，称为网络字节序（Network Byte Order），非常简单——统一为大端序。即，先把数据数组转化为大端序格式再进行网络传输。 字节序转换（Endian Conversions） 除了向sockaddr_in结构体变量填充数据外，其他情况无需考虑字节序问题。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:3","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r网络地址的初始化与分配\r将字符串信息转换为网络字节序的整数型使用inet_addr函数可以将字符串形式的 IP 地址转换为 32 为整型数据。 ##include\u003carpa/inet.h\u003e in_addr_t inet_addr(const char* string); // 成功返回32位大端序整型值，失败时返回INADDR_NONE。 char* inet_ntoa(struct in_addr adr); // 成功返回转换的字符串地址值，失败时返回-1 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:4","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r基于 TCP 的服务器端/客户端(1)","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r实现基于 TCP 的服务器端/客户端\rTCP 服务器端的默认函数调用顺序 进入等待连接请求状态我们已调用bind函数给套接字分配了地址，接下来就要通过listen函数进入等待连接请求状态。只有调用了listen函数，客户端才能进入可发出连接请求的状态。这时客户端才能调用connect函数（若提前调用将发生错误）。 ##include \u003csys/socket.h\u003e int listen(int sock, int backlog); // 成功返回0，失败返回-1 // sock 希望进入等待连接状态的套接字文件描述符，传递的描述符套接字参数成为服务器端套接字（监听套接字） // backlog 连接请求等待队列的长度，若为5，则队列长度为5，表示最多使5个连接请求进入队列 受理客户端连接请求服务器端套接字是做门卫的。如果与客户端的数据交换使用门卫，那谁来守门呢？因此需要另外一个套接字，但没必要亲自创建。accpet函数将自动创建套接字，并连接到发起请求的客户端。 ##include \u003csys/socket.h\u003e int accpet(int sock, struct sockaddr* addr, socklen_t* addrlen); // 成功时返回创建的套接字文件描述符，失败返回-1 // sock 服务器套接字的文件描述符 // addr 保存发起连接请求的客户端地址信息的变量地址值，调用函数后向传递来的地址变量参数填充客户端地址信息 // addrlen 第二个参数addr结构体的长度，但是存有长度的变量地址。函数调用完成后，该变量即被填入客户端地址长度 TCP 客户端的默认函数调用顺序 服务器调用listen函数后创建连接请求等待队列，之后客户端即可请求连接。通过如下函数即可发起请求连接: ##include \u003csys/socket.h\u003e int connect(int sock, struct sockaddr* servaddr, socklen_t addrlen); // 成功时返回0，失败时返回-1 // sock 客户端套接字文件描述符 // servaddr 保存目标服务器端地址信息的变量地址值 // addrlen 以字节为单位传递已传递给第二个结构体参数servaddr的地址变量长度 客户端调用connect函数后，发生以下情况之一才会返回（完成函数调用）。 服务器端接收连接请求 发生断网等异常情况而中断连接请求 接收连接并不意味着服务器端调用accpet函数，其实是服务器端把连接请求信息记录到等待队列。因此connect函数返回后并不立即进行数据交换。 客户端套接字何时、何地、如何分配地址呢？调用connect函数时。操作系统，准确地说是在内核中。IP 用主机的 IP，端口随机。客户端的 IP 地址和端口在调用connect函数时自动分配，无需调用bind函数进行分配。 基于 TCP 和服务器端/客户端函数调用关系 服务器端创建套接字后连续调用bind和listen函数进入等待状态，客户端通过调用connect函数发起连接请求。客户端只能等到服务器端调用listen函数后才能调connect函数。客户端调用connect函数前，服务器端有可能率先调用accpet函数。此时服务器端在调用accpet函数时进入阻塞状态，直到客户端调用connect函数为止。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:1","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r实现迭代服务器端/客户端\r实现迭代服务器端插入循环语句反复调用accept函数。 从上图可看出，调用accept函数后紧接着调用 I/O 相关的read和write函数，之后调用close函数。这并非针对服务器端套接字，而是针对accept函数调用时创建的套接字。 调用close函数就意味着结束了针对某一客户端的服务。此时如果还想服务于其他客户端，就要重新调用accpet函数。同一时刻只能服务于一个客户端，学完进程和线程后，就可以编写同时服务多个客户端的服务器了。 迭代回声服务器/客户端 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:2","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r基于 Windows 的实现\r基于 Windows 的回声服务器端 ##include \u003ciostream\u003e ##include \u003ccstdlib\u003e ##include \u003ccstring\u003e ##include \u003cwinsock2.h\u003e ##include \u003ccstdio\u003e ##define BUF_SIZE 1024 void ErrorHandling(const char* message); int main(int argc, char* argv[]) { WSADATA wsaData; SOCKET hServerSocket, hClientSocket; char message[BUF_SIZE]; int strlen, i; int clientAddrSize; SOCKADDR_IN serverAddr, clientAddr; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } if (WSAStartup(MAKEWORD(2, 2), \u0026wsaData) != 0) ErrorHandling(\"WSAStartup() error!\"); hServerSocket = socket(PF_INET, SOCK_STREAM, 0); if (hServerSocket == INVALID_SOCKET) ErrorHandling(\"socket() error!\"); memset(\u0026serverAddr, 0, sizeof(serverAddr)); serverAddr.sin_family = AF_INET; serverAddr.sin_addr.s_addr = htonl(INADDR_ANY); serverAddr.sin_port = htons(atoi(argv[1])); if (bind(hServerSocket, (sockaddr*)\u0026serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) { ErrorHandling(\"bind() error!\"); } if (listen(hServerSocket, 5) == SOCKET_ERROR) { ErrorHandling(\"listen() error!\"); } clientAddrSize = sizeof(clientAddr); for (i = 0; i \u003c 5; i++) { hClientSocket = accept(hServerSocket, (sockaddr*)\u0026clientAddr, \u0026clientAddrSize); if (hClientSocket == -1) ErrorHandling(\"accept() error!\"); else std::cout \u003c\u003c \"Connected client \" \u003c\u003c i + 1 \u003c\u003c \"\\n\"; while ((strlen = recv(hClientSocket, message, BUF_SIZE, 0)) != 0) { send(hClientSocket, message, strlen, 0); } closesocket(hClientSocket); } closesocket(hServerSocket); WSACleanup(); return 0; } void ErrorHandling(const char* message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } 基于 Windows 的回声客户端 ##include \u003ciostream\u003e ##include \u003ccstdlib\u003e ##include \u003ccstring\u003e ##include \u003cwinSock2.h\u003e ##include \u003ccstdio\u003e ##pragma warning(disable:4996) ##define BUF_SIZE 1024 void ErrorHandling(const char* message); int main(int argc, char* argv[]) { WSADATA wsaData; SOCKET hSocket; char message[BUF_SIZE]; int strLen; SOCKADDR_IN serverAddr; if (argc != 3) { printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e\\n\", argv[0]); exit(1); } if (WSAStartup(MAKEWORD(2, 2), \u0026wsaData) != 0) ErrorHandling(\"WSAStartup() error!\"); hSocket = socket(PF_INET, SOCK_STREAM, 0); if (hSocket == INVALID_SOCKET) ErrorHandling(\"socket() error\"); memset(\u0026serverAddr, 0, sizeof(serverAddr)); serverAddr.sin_family = AF_INET; serverAddr.sin_addr.s_addr = inet_addr(argv[1]); serverAddr.sin_port = htons(atoi(argv[2])); if (connect(hSocket, (sockaddr*)\u0026serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) { ErrorHandling(\"connect() error!\"); } while (1) { fputs(\"Input message (Q to quit): \", stdout); fgets(message, BUF_SIZE, stdin); if (!strcmp(message, \"q\\n\") || !strcmp(message, \"Q\\n\")) break; send(hSocket, message, strlen(message), 0); strLen = recv(hSocket, message, BUF_SIZE - 1, 0); message[strLen] = 0; printf(\"Message from server : %s\", message); } closesocket(hSocket); WSACleanup(); return 0; } void ErrorHandling(const char* message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:3","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r基于 TCP 的服务器端/客户端(2)","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r回声客户端的完美实现 ##include \u003cstdio.h\u003e ##include \u003cstdlib.h\u003e ##include \u003cstring.h\u003e ##include \u003cunistd.h\u003e ##include \u003carpa/inet.h\u003e ##include \u003csys/socket.h\u003e ##define BUF_SIZE 1024 void error_handling(char *message); int main(int argc, char *argv[]) { int sock; char message[BUF_SIZE]; int str_len, recv_len, recv_cnt; struct sockaddr_in serv_addr; if (argc != 3) { printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e \\n\", argv[0]); exit(1); } sock = socket(PF_INET, SOCK_STREAM, 0); if (sock == -1) { error_handling(\"socket() error\"); } memset(\u0026serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = inet_addr(argv[1]); serv_addr.sin_port = htons(atoi(argv[2])); if (connect(sock, (struct sockaddr *)\u0026serv_addr, sizeof(serv_addr)) == -1) { error_handling(\"connect() error\"); } else { puts(\"connected....\"); } while (1) { fputs(\"Input message (Q to quit): \", stdout); fgets(message, BUF_SIZE, stdin); if (!strcmp(message, \"q\\n\") || !strcmp(message, \"Q\\n\")) { break; } str_len = write(sock, message, strlen(message)); recv_len = 0; while (recv_len \u003c str_len) { recv_cnt = read(sock, \u0026message[recv_len], BUF_SIZE - 1); if (recv_cnt == -1) { error_handling(\"read() error\"); } recv_len += recv_cnt; } message[recv_len] = 0; printf(\"Message from server : %s\", message); } close(sock); return 0; } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:1","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\rTCP 原理\rTCP 套接字中的 I/O 缓冲TCP 套接字的数据收发无边界。服务器端即使调用 1 次write函数传输 40 字节的数据，客户端也有可能通过 4 次read函数调用每次读取 10 字节。write函数调用后并非立即传输数据，read函数调用后也并非马上接收数据。write函数调用瞬间，数据将移至输出缓冲；read函数调用瞬间，从输入缓冲读取数据。 如上图所示，调用write函数时，数据将移到输出缓冲，在适当的时候（不管是分别传送还是一次性传送）传向对方的输入缓冲。这时对方将调用read函数从输入缓冲读取数据。这些 I/O 缓冲特性可整理如下。 I/O 缓冲在每个 TCP 套接字中单独存在 I/O 缓冲在创建套接字时自动生成 即使关闭套接字也会继续传递输出缓冲中遗留的数据 关闭套接字将丢失输入缓冲中的数据 不会发生超过输入缓冲大小的数据传输，因为 TCP 会控制数据流。TCP 中有滑动窗口（Sliding Window）协议。数据收发也是如此，TCP 不会因为缓冲溢出而丢失数据。 TCP 内部工作原理 1：与对方套接字的连接TCP 套接字从创建到消失分为以下 3 步。 与对方套接字建立连接 与对方套接字进行数据交换 断开与对方套接字的连接 连接过程中实际交换的信息格式如下: 该过程又称 Tree-way handhshaking（三次握手）。 TCP 内部工作原理 2：与对方主机的数据交换 ACK 号 -\u003e SEQ 号 + 传递字节数 + 1 TCP 内部工作原理 3：断开与套接字的连接 数据包内的 FIN 表示断开连接。即双方各发送 1 次 FIN 消息后断开连接。该过程经历了 4 个阶段，因此又称四次握手（Four-way handshaking）。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:2","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r基于 Windows 实现服务器端op_server.c ##include \u003ccstdio\u003e ##include \u003ccstdlib\u003e ##include \u003ciostream\u003e ##include \u003cWinSock2.h\u003e ##include \u003ccstring\u003e ##define BUF_SIZE 1024 ##define OPZS 4 void ErrorHandling(const char* message); int calculate(int opnum, int opnds[], char op); int main(int argc, char* argv[]) { WSADATA wsData; SOCKET serverSocket, clientSocket; SOCKADDR_IN serverAddr, clientAddr; char opinfo[BUF_SIZE]; int clientAddrSize, i; int result, opndCount; int recvCount, recvLen; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } if (WSAStartup(MAKEWORD(2, 2), \u0026wsData) != 0) ErrorHandling(\"WSAStartup() error!\"); serverSocket = socket(PF_INET, SOCK_STREAM, 0); if (serverSocket == INVALID_SOCKET) ErrorHandling(\"socket() error!\"); memset(\u0026serverAddr, 0, sizeof(serverAddr)); serverAddr.sin_family = PF_INET; serverAddr.sin_port = htons(atoi(argv[1])); serverAddr.sin_addr.s_addr = htonl(INADDR_ANY); if (bind(serverSocket, (SOCKADDR*)\u0026serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) ErrorHandling(\"bind() error!\"); if (listen(serverSocket, 5) == SOCKET_ERROR) ErrorHandling(\"listen() error!\"); clientAddrSize = sizeof(clientAddr); for (i = 0; i \u003c 5; i++) { opndCount = 0; clientSocket = accept(serverSocket, (SOCKADDR*)\u0026clientAddr, \u0026clientAddrSize); recv(clientSocket, (char*)\u0026opndCount, 1, 0); recvLen = 0; while ((opndCount * OPZS + 1) \u003e recvLen) { recvCount = recv(clientSocket, opinfo, BUF_SIZE - 1, 0); recvLen += recvCount; } result = calculate(opndCount, (int*)opinfo, opinfo[recvLen - 1]); send(clientSocket, (char*)\u0026result, sizeof(result), 0); closesocket(clientSocket); } closesocket(serverSocket); WSACleanup(); return 0; } void ErrorHandling(const char* message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } int calculate(int opnum, int opnds[], char op) { int result = opnds[0], i; switch (op) { case '+': for (i = 1; i \u003c opnum; i++) result += opnds[i]; break; case '-': for (i = 1; i \u003c opnum; i++) result -= opnds[i]; break; case '*': for (i = 1; i \u003c opnum; i++) result *= opnds[i]; break; } return result; } 客户端op_client.c ##include \u003ciostream\u003e ##include \u003cWinSock2.h\u003e ##include \u003ccstdlib\u003e ##include \u003ccstdio\u003e ##pragma warning(disable:4996) ##define BUF_SIZE 1024 ##define RLT_SIZE 4 ##define OPSZ 4 void ErrorHandling(const char* message); int main(int argc, char* argv[]) { WSADATA wsData; SOCKET hSocket; char opmsg[BUF_SIZE]; int result, opndCount, i; SOCKADDR_IN serverAddr; if (argc != 3) { printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e\\n\", argv[0]); exit(1); } if (WSAStartup(MAKEWORD(2, 2), \u0026wsData) != 0) { ErrorHandling(\"WSAStartup() error!\"); } hSocket = socket(PF_INET, SOCK_STREAM, 0); if (hSocket == INVALID_SOCKET) ErrorHandling(\"socket() error!\"); memset(\u0026serverAddr, 0, sizeof(serverAddr)); serverAddr.sin_addr.s_addr = inet_addr(argv[1]); serverAddr.sin_family = AF_INET; serverAddr.sin_port = htons(atoi(argv[2])); if (connect(hSocket, (SOCKADDR*)\u0026serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) ErrorHandling(\"socket() error!\"); else puts(\"Connected ......\"); fputs(\"Operand count : \", stdout); scanf(\"%d\", \u0026opndCount); opmsg[0] = (char)opndCount; for (i = 0; i \u003c opndCount; i++) { printf(\"Operand %d : \", i + 1); scanf(\"%d\", (int*)\u0026opmsg[i * OPSZ + 1]); } fgetc(stdin); fputs(\"Operator : \", stdout); scanf(\"%c\", \u0026opmsg[opndCount * OPSZ + 1]); send(hSocket, opmsg, opndCount * OPSZ + 2, 0); recv(hSocket, (char*)\u0026result, RLT_SIZE, 0); printf(\"Operation result : %d \\n\", result); closesocket(hSocket); WSACleanup(); return 0; } void ErrorHandling(const char* message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:3","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r推荐File Transfer using TCP Socket in C: https://idiotdeveloper.com/file-transfer-using-tcp-socket-in-c/ ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:4","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r基于 UDP 的服务器端/客户端","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:6:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r理解 UDP\rUDP 内部工作原理 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:6:1","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r实现基于 UDP 的服务器端/客户端\rUDP 中的服务器端和客户端没有连接UDP 服务器端和客户端不像 TCP 那样在连接状态下交换数据，因此与 TCP 不同，无需经过连接过程。即，不必调用 TCP 连接过程中调用的listen函数和accept函数。UDP 中只有创建套接字的过程和数据交换过程。 UDP 服务器端和客户端均只需 1 个套接字TCP 中，套接字之间应该是一对一的关系。若要向 10 个客户端提供服务，则除了守门的服务器套接字外，还需要 10 个服务器端套接字。但在 UDP 中，不管是服务器端还是客户端都只需要 1 个套接字。 只需 1 个 UDP 套接字就可以向任意主机传输数据（类似收发信件的邮筒）。只需 1 个 UDP 套接字就能和多台主机通信。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:6:2","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r基于 Windows 实现 ##include \u003cwinsock2.h\u003e int sendto(SOCKET s, const char* buf, int len, int flags, const struct sockaddr* to, int tolen); // 成功返回传输的字节数，失败返回SOCKET_ERROR int recvfrom(SOCKET s, char* buf, int len, int flag, struct sockaddr* from, int* fromlen); // 成功返回接收的字节数，失败返回SOCKET_ERROR ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:6:3","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r优雅地断开套接字连接","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:7:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r基于 TCP 的半关闭\r套接字和流（Stream）两台主机通过套接字建立连接后进入可交换数据的状态，又称“流形成的状态”。也就是把建立套接字后可交换数据的状态看作一种流。此处的流可以比作水流。水朝着一个方向流动，同样，在套接字的流中，数据也只能向一个方向流动。为了进行双向通信，就需要如下图所示的 2 个流。 一旦两台主机建立了套接字连接，每个主机机会拥有单独的输入流和输出流。其中一个主机的输入流与一台主机的输出流相连，而输出流则与另一主机的输入流相连。优雅地断开连接方式指的是只断开其中一个流，而非同时断开两个流。Linux 的close和 Windows 的closesocket函数将同时断开这两个流，因此不够优雅。 针对优雅断开的shutdown函数shutdown函数可以用来关闭其中 1 个流。 ##include \u003csys/socket.h\u003e int shutdown(int sock, int howto); // 成功返回0，失败返回-1 调用上述函数时，第二个参数决定断开连接的方式，其可能值如下: SHUT_RD: 断开输入流 SHUT_WR: 断开输出流 SHUT_RDWR: 同时断开 I/O 流 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:7:1","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r基于 Windows 的实现Windows 平台调用的shutdown函数传递的参数略有不同。 ##include \u003cwinsock2.h\u003e int shutdown(SOCKET sock, int howto); // 成功返回0，失败返回SOCKET_ERROR // sock 要断开的套接字句柄 // howto 断开方式的信息 调用上述函数时，第二个参数的可能值如下: SD_RECEIVE: 断开输入流 SD_SEND: 断开输出流 SD_BOTH: 同时断开 I/O 流 服务器端file_server_win.cpp: ##include \u003cWinSock2.h\u003e ##include \u003ccstdio\u003e ##include \u003ccstdlib\u003e ##pragma warning(disable:4996) ##define BUF_SIZE 30 void ErrorHandling(const char* message); int main(int argc, char* argv[]) { WSADATA wsaData; SOCKET serverSocket, clientSocket; FILE* fp; char buf[BUF_SIZE]; int readCount; SOCKADDR_IN serverAddr, clientAddr; int clientAddrSize; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } if (WSAStartup(MAKEWORD(2, 2), \u0026wsaData) != 0) ErrorHandling(\"WSAStartup() error!\"); fp = fopen(\"file_server_win.cpp\", \"rb\"); serverSocket = socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serverAddr, 0, sizeof(serverAddr)); serverAddr.sin_family = AF_INET; serverAddr.sin_addr.s_addr = htonl(INADDR_ANY); serverAddr.sin_port = htons(atoi(argv[1])); bind(serverSocket, (SOCKADDR*)\u0026serverAddr, sizeof(serverAddr)); listen(serverSocket, 5); clientAddrSize = sizeof(clientAddr); clientSocket = accept(serverSocket, (SOCKADDR*)\u0026clientAddr, \u0026clientAddrSize); while (true) { readCount = fread((void*)buf, 1, BUF_SIZE, fp); if (readCount \u003c BUF_SIZE) { send(clientSocket, (char*)\u0026buf, readCount, 0); break; } send(clientSocket, (char*)\u0026buf, BUF_SIZE, 0); } shutdown(clientSocket, SD_SEND); recv(clientSocket, (char*)buf, BUF_SIZE, 0); printf(\"Message from client : %s \\n\", buf); fclose(fp); closesocket(clientSocket); closesocket(serverSocket); WSACleanup(); return 0; } void ErrorHandling(const char* message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } 客户端file_client_win.cpp: ##include \u003ciostream\u003e ##include \u003cWinSock2.h\u003e ##include \u003ccstdlib\u003e ##include \u003ccstdio\u003e ##pragma warning(disable:4996) ##define BUF_SIZE 30 void ErrorHandling(const char* message); int main(int argc, char* argv[]) { WSADATA wsData; SOCKET hSocket; char buf[BUF_SIZE]; int readCount; SOCKADDR_IN serverAddr; FILE* fp; if (argc != 3) { printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e\\n\", argv[0]); exit(1); } if (WSAStartup(MAKEWORD(2, 2), \u0026wsData) != 0) { ErrorHandling(\"WSAStartup() error!\"); } fp = fopen(\"receive.dat\", \"wb\"); hSocket = socket(PF_INET, SOCK_STREAM, 0); if (hSocket == INVALID_SOCKET) ErrorHandling(\"socket() error!\"); memset(\u0026serverAddr, 0, sizeof(serverAddr)); serverAddr.sin_addr.s_addr = inet_addr(argv[1]); serverAddr.sin_family = AF_INET; serverAddr.sin_port = htons(atoi(argv[2])); if (connect(hSocket, (SOCKADDR*)\u0026serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) ErrorHandling(\"socket() error!\"); else puts(\"Connected ......\"); while ((readCount = recv(hSocket, buf, BUF_SIZE, 0)) != 0) { fwrite((void*)buf, 1, readCount, fp); } puts(\"Received file data\"); send(hSocket, \"Thank you\", 10, 0); fclose(fp); closesocket(hSocket); WSACleanup(); return 0; } void ErrorHandling(const char* message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:7:2","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r域名及网络地址","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:8:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r套接字的多种可选项","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:9:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r多进程服务器端","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r进程概念及应用\r并发服务器的的实现方法 多进程服务器: 通过创建多个进程提供服务 多路复用服务器: 通过绑定并统一管理 I/O 对象提供服务 多线程服务器: 通过生成与客户端等量的线程提供服务 第一种方法: 多进程服务器。不适合在 Windows 平台下（Windows 不支持），因此将重点放在 Linux 平台。 理解进程（Process）定义如下: 占用内存空间的正在运行的程序 进程 ID无论进程是如何创建的，所有进程都会从操作系统分配到 ID。此 ID 称为进程 ID，其值为大于 2 的整数。1 要分配给操作系统启动后（用于协助操作系统）首个进程，因此用户进程无法得到 ID 值 1。 通过 ps 命令可以查看当前运行的所有进程。 通过调用 fork 函数创建进程 ##include \u003cunistd.h\u003e pid_t fork(void); // 成功返回进程ID，失败返回-1 fork函数将创建调用的进程副本。即并非根据完全不同的程序创建进程，而是复制正在运行的、调用fork函数的进程。两个进程都将执行fork函数调用后的语句（准确说是在fork函数返回后）。但因为通过同一个进程、复制相同的内存空间，之后的程序流要根据fork函数的返回值加以区分。fork函数的特点如下: 父进程: fork函数返回子进程 ID 子进程: fork函数返回 0 这里的父进程（Parent Process）指的是原进程，即调用fork函数的主体，而子进程（Child Process）是通过父进程调用fork函数复制出的进程。 从上图可以看到，父进程调用fork函数的同时复制出子进程，并分别得到fork函数的返回值。在父进程和子进程中gval和lval互不影响。因此fork函数调用后分成了完全不同的进程，只是二者共享同一代码而已。 ##include \u003cstdio.h\u003e ##include \u003cunistd.h\u003e int gval = 10; int main(int argc, char* argv[]){ pid_t pid; int lval = 20; gval++, lval+=5; pid = fork(); if (pid == 0) gval += 2, lval += 2; else gval -= 2, lval -= 2; if (pid == 0) printf(\"Child Proc : [%d, %d] \\n\", gval, lval); else printf(\"Parent Proc : [%d, %d] \\n\", gval, lval); return 0; } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:1","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r进程和僵尸进程进程销毁和进程创建同等重要。如果未认真进程销毁，它们将变成僵尸进程。 僵尸（Zombie）进程进程完成工作后（执行完main函数中的程序后）应被销毁，但有时这些进程将变成僵尸进程，占用系统中的重要资源。这种状态下的进程称作“僵尸进程”，也是给系统带来负担的原因之一。 产生僵尸进程的原因调用fork函数产生子进程的终止方式: 传递参数并调用exit函数 main函数中执行return语句并返回值 向exit函数传递的参数值和main函数的return语句返回的值都会传递给操作系统。而操作系统不会销毁子进程，直到把这些值传递给产生该子进程的父进程。处在这种状态下的进程就是僵尸进，将子进程变成僵尸进程的正是操作系统。那么如何销毁僵尸进程呢？向父进程传递exit函数的参数值或return的返回值即可。如何向父进程传递这些值呢？操作系统不会主动传递给父进程，只有父进程主动发起请求（函数调用）时，操作系统才会传递该值。换言之，如果父进程未主动要求获得子进程的结束状态值，操作系统将一直保存，并让子进程长时间处于僵尸进程状态。 ##include \u003cstdio.h\u003e ##include \u003cunistd.h\u003e int main(int argc, char* argv[]){ pid_t pid = fork(); if (pid == 0) puts(\"Child Process\"); else { printf(\"Child Process ID : %d \\n\", pid); sleep(30); // Sleep 30 sec } if (pid == 0) puts(\"End Child Process\"); else puts(\"End Parent Process\"); return 0; } 销毁僵尸进程 1：利用 wait 函数为了销毁子进程，父进程应主动请求获取子进程的返回值。发起请求的方法有两种，其中之一就是调用如下函数。 ##include \u003csys/wait.h\u003e pid_t wait(int* statloc); // 成功返回终止的子进程ID，失败返回-1 调用此函数时如果已有子进程终止，那么子进程终止时传递的返回值（exit函数的参数值、main函数的return返回值）将保存到该函数的参数所指内存空间。但函数参数指向的单元中还包含其他信息，因此需要通过下列宏进行分离。 WIFEXITED子进程正常终止时返回真（True） WEXITSTATUS返回子进程的返回值 向wait函数传递变量status的地址时，调用wait函数后应编写如下代码: if (WIFEXITED(status)) // 是正常终止吗？ { puts(\"Normal termination!\"); printf(\"Child pass num: %d\", WEXITSTATUS(status)); // 返回值是多少？ } 根据上述内容编写示例，此示例不会再让子进程变成僵尸进程。 ##include \u003cstdio.h\u003e ##include \u003cstdlib.h\u003e ##include \u003cunistd.h\u003e ##include \u003csys/wait.h\u003e int main(int argc, char* argv[]){ int status; pid_t pid = fork(); if (pid == 0) { return 3; } else { printf(\"Child PID %d \\n\", pid); pid = fork(); if (pid == 0) { exit(7); } else { printf(\"Child PID %d \\n\", pid); wait(\u0026status); if (WIFEXITED(status)){ printf(\"Child send one : %d\\n\", WEXITSTATUS(status)); } wait(\u0026status); if (WIFEXITED(status)){ printf(\"Child send two : %d\\n\", WEXITSTATUS(status)); } sleep(30); } } return 0; } 调用wait函数时，如果没有已终止的子进程，那么程序将阻塞（Blocking）直到有子进程终止，因此需谨慎调用该函数。 销毁僵尸进程 2：使用 waitpid 函数wait函数会引起程序阻塞，可以考虑调用waitpid函数。这是防止僵尸进程的第二种方法，也是防止阻塞的方法。 ##include \u003csys/wait.h\u003e pid_t waitpid(pid_t pid, int* statloc, int options); // 成功返回终止的子进程ID（或0），失败返回-1 // pid 等待终止的目标子进程ID，若传递-1，则与wait函数相同，可以等待任意子进程终止 // statloc 与wait函数的statloc参数具有相同含义 // options 传递头文件sys/wait.h中声明的常量WNOHANG，即使没有终止的子进程也不会进入阻塞状态，而是返回0并退出函数 示例如下: ##include \u003cstdio.h\u003e ##include \u003cstdlib.h\u003e ##include \u003cunistd.h\u003e ##include \u003csys/wait.h\u003e int main(int argc, char *argv[]) { int status; pid_t pid = fork(); if (pid == 0) { sleep(15); return 24; } else { while (!waitpid(-1, \u0026status, WNOHANG)) { sleep(3); puts(\"Sleep 3sec.\"); } if (WIFEXITED(status)) { printf(\"Child send %d \\n\", WEXITSTATUS(status)); } } return 0; } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:2","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r信号处理我们已经直到子进程的创建及销毁方法，但还有一个问题没解决。 子进程究竟何时终止？调用waitpid函数后要无休止地等待吗？ 父进程往往与子进程一样繁忙，因此不能只调用waitpid函数以等待子进程终止。 向操作系统求助子进程终止的识别主体是操作系统。如果操作系统能把子进程终止的消息告诉正忙于工作的父进程，将有助于构建高效的程序。 此时父进程暂时放下工作，处理子进程终止相关事宜。为了实现该想法，引入信号处理（Signal Handling）机制。此处的“信号”是在特定时间发生时由操作系统向进程发送的消息。为了响应该消息，执行与消息相关的自定义操作的过程“处理”或“信号处理”。 信号与 signal 函数信号注册函数，请求操作系统当子进程结束时调用某函数。 ##include \u003csignal\u003e void (*signal(int signo, void(*func)(int)))(int) 上述函数的返回值类型为函数指针。第一个参数为特殊情况信息，第二个参数为特殊情况下将要调用的函数的地址值（指针）。发生第一个参数代表的情况时，调用第二个参数所指的函数。可以在signal函数中注册的部分特殊情况和对应常数如下: SIGALRM: 已到通过调用alarm函数注册的时间 SIGNIT: 输入CTRL + C SIGCHLD: 子进程终止 比如，编写调用signal函数完成“子进程终止则调用 myChild 函数”的请求，语句如下: signal(SIGCHILD, myChild); 以上就是信号注册过程。注册好信号后，发生注册信号时（注册的情况发生时），操作系统将调用该信号对应的函数。 先介绍alarm函数。 ##include \u003cunistd.h\u003e unsigned int alarm(unsigned int seconds); // 返回0或者以秒为单位的距SIGALRM信号发生所剩时间 如果调用该函数的同时向它传递一个正整型函数，相应时间后（以秒为单位）将产生 SIGALRM 信息。若向该函数传递 0，则之前对 SIGALRM 信号预约将取消。如果通过该函数预约信号后为指定该信号对应的处理函数，则（通过调用signal函数）终止进程，不做任何处理。 示例如下: ##include \u003csignal.h\u003e ##include \u003cunistd.h\u003e ##include \u003cstdio.h\u003e void timeout(int sig) { if (sig == SIGALRM) puts(\"Time out!\"); alarm(2); } void keycontrol(int sig) { if (sig == SIGINT) puts(\"CTRL + C pressed\"); } int main(int argc, char *argv[]) { int i; signal(SIGALRM, timeout); signal(SIGINT, keycontrol); alarm(2); for (i = 0; i \u003c 3; i++) { puts(\"wait...\"); sleep(100); } return 0; } 发生信号时将唤醒由于调用sleep函数而进入阻塞状态的进程。调用函数的主体是操作系统，但进程处于睡眠状态无法调用函数。因此，产生信号时，为了调用信号处理器 ，将唤醒由于调用sleep函数而进入阻塞状态的进程。而且，进程一旦被唤醒，就不会再进入睡眠状态。即使还未到sleep函数中规定的时间也如此。所以上述示例运行不到 10 秒就会结束，连续输入CTRL + C可能 1 秒都不到。 利用 sigaction 函数进行信号处理sigaction函数类似于signal函数，且完全可以代替它，也更稳定。稳定的原因是signal函数在 UNIX 系列的不同操作系统中可能存在区别，但sigaction函数完全相同。 ##include \u003csignal.h\u003e int sigaction(int signo, const struct sigaction* act, struct sigaction* oldact); // 成功时返回0，失败时返回-1 // signo 与signal函数相同，传递信号信息 // act 对于与第一个参数的信号处理函数（信号处理器）信息 // oldact 通过参数获取之前注册的信号处理函数指针，若不需要则传递0 声明并初始化sigaction结构体变量以调用上述函数，该结构体定义如下: 结构体的sa_handler成员保存信号处理函数的指针值（地址值）。 示例如下: ##include \u003csignal.h\u003e ##include \u003cstdio.h\u003e ##include \u003cunistd.h\u003e void timeout(int sig) { if (sig == SIGALRM) { puts(\"Time out!\"); } alarm(2); } int main(int argc, char *argv[]) { int i; struct sigaction act; act.sa_handler = timeout; sigemptyset(\u0026act.sa_mask); act.sa_flags = 0; sigaction(SIGALRM, \u0026act, 0); alarm(2); for (i = 0; i \u003c 3; i++) { puts(\"wait...\"); sleep(100); } return 0; } 利用信号处理技术消灭僵尸进程进程终止时将产生SIGCHLD信号。 ##include \u003cstdio.h\u003e ##include \u003cstdlib.h\u003e ##include \u003cunistd.h\u003e ##include \u003csignal.h\u003e ##include \u003csys/wait.h\u003e void read_childproc(int sig) { int status; pid_t pid = waitpid(-1, \u0026status, WNOHANG); if (WIFEXITED(status)) { printf(\"Removed proc id : %d\\n\", pid); printf(\"Child send : %d \\n\", WEXITSTATUS(status)); } } int main(int argc, char *argv[]) { pid_t pid; struct sigaction act; act.sa_handler = read_childproc; sigemptyset(\u0026act.sa_mask); act.sa_flags = 0; sigaction(SIGCHLD, \u0026act, 0); pid = fork(); if (pid == 0) // 子进程执行区域 { puts(\"Hi! I am child process\"); sleep(10); return 12; } else // 父进程执行区域 { printf(\"Child proc is : %d\\n\", pid); pid = fork(); if (pid == 0) // 另一子进程执行区域 { puts(\"Hi! I am child process\"); sleep(10); exit(24); } else { int i; printf(\"Child proc is : %d\\n\", pid); for (i = 0; i \u003c 5; i++) { puts(\"wait...\"); sleep(5); } } } return 0; } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:3","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r基于多任务的并发服务器\r基于进程的并发服务器模型此前的回声服务器端每次都只能向一个客户端提供服务。因此，我们可以扩展回声服务器端，使其可以同时向国歌客户端提供服务，实现模型如下。 每当有客户端请求服务（连接请求）时，回声服务器都创建子进程以提供服务。请求服务的客户端若有 5 个，则将创建 5 个子进程提供服务。过程如下: 第一阶段：回声服务器端（父进程）通过调用accept函数受理连接请求 第二阶段：此时获取的套接字文件描述符创建并传递给子进程 第三阶段：子进程利用传递来的文件描述符提供服务 子进程会复制父进程拥有的所有资源，实际上根本不哦那个另外传递文件描述符的过程。 实现并发服务器 // echo_mpserv.c ##include \u003cstdio.h\u003e ##include \u003cstdlib.h\u003e ##include \u003cstring.h\u003e ##include \u003cunistd.h\u003e ##include \u003csignal.h\u003e ##include \u003csys/wait.h\u003e ##include \u003carpa/inet.h\u003e ##include \u003csys/socket.h\u003e ##define BUF_SIZE 30 void error_handling(char *message); void read_childproc(int sig); int main(int argc, char *argv[]) { int serv_sock, clnt_sock; struct sockaddr_in serv_adr, clnt_adr; pid_t pid; struct sigaction act; socklen_t adr_sz; int str_len, state; char buf[BUF_SIZE]; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } act.sa_handler = read_childproc; sigemptyset(\u0026act.sa_mask); act.sa_flags = 0; state = sigaction(SIGCHLD, \u0026act, 0); serv_sock = socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family = AF_INET; serv_adr.sin_addr.s_addr = htonl(INADDR_ANY); serv_adr.sin_port = htons(atoi(argv[1])); if (bind(serv_sock, (struct sockaddr *)\u0026serv_adr, sizeof(serv_adr)) == -1) { error_handling(\"bind() error\"); } if (listen(serv_sock, 5) == -1) { error_handling(\"listen() error\"); } while (1) { adr_sz = sizeof(clnt_adr); clnt_sock = accept(serv_sock, (struct sockaddr *)\u0026clnt_adr, \u0026adr_sz); if (clnt_sock == -1) { continue; } else { puts(\"new client connected...\"); } pid = fork(); if (pid == -1) { close(clnt_sock); continue; } if (pid == 0) // 子进程运行区域 { close(serv_sock); while ((str_len = read(clnt_sock, buf, BUF_SIZE)) != 0) { write(clnt_sock, buf, str_len); } close(clnt_sock); puts(\"client disconnected...\"); return 0; } else { close(clnt_sock); } } close(serv_sock); return 0; } void read_childproc(int sig) { pid_t pid; int status; pid = waitpid(-1, \u0026status, WNOHANG); printf(\"removed proc id %d \\n\", pid); } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } 启动服务器后，可以发现服务器可以向多个客户端提供服务。 通过 fork 函数复制文件描述符echo_mpserv.c中父进程将 2 个套接字（一个服务器端套接字，一个是与客户端连接的套接字）文件描述符复制给子进程。 只复制文件描述符吗？是否也复制了套接字？ 调用fork函数时复制父进程的所有资源，但套接字并非进程所有——严格意义上说，套接字属于操作系统——只是进程拥有代表相应套接字的文件描述符。 调用fork函数后，2 个文件描述符指向同一套接字。 1 个套接字中存在 2 个文件描述符时，只有 2 个文件描述符都终止（销毁）后，才能销毁套接字。如果维持上图中的连接状态，即使子进程销毁了与客户端连接的套接字文件描述符，也无法完全销毁套接字（服务器端套接字同样如此）。因此，调用fork函数后，要将无关的套接字文件描述符关掉，如下图所示。 为了将文件描述符整理成上图形式，echo_mpserv.c调用了close函数。 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:4","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r分割 TCP 的 I/O 程序\r分割 I/O 程序的优点已经实现的回声客户端的数据回声方式如下： 向服务器端传输数据，并等待服务器端回复。无条件等待，直到接受完服务器端的回声数据后，才能传输下一批数据。 传输数据后需等待服务器端返回的数据，因为程序代码中重复调用了read和write函数。这么写的原因是，程序在 1 个进程中运行。现在可创建多个进程，因此可以分割数据收发过程。分割模型如下: 如此实现的一个重要原因是程序实现更简单。父进程中只需编写接收数据的代码，子进程中只需编写发送数据的代码，所以会简化。 另一个好处是可以提高频繁交换数据的性能。 分割 I/O 后的客户端发送数据时不必考虑接收数据的情况，因此可以连续发送数据，由此提高同一时间内传输的数据量。这种差异在网络较慢时尤为明显。 回声客户端的 I/O 程序分割 // echo_mpclient.c ##include \u003cstdio.h\u003e ##include \u003cstdlib.h\u003e ##include \u003cstring.h\u003e ##include \u003cunistd.h\u003e ##include \u003carpa/inet.h\u003e ##include \u003csys/socket.h\u003e ##define BUF_SIZE 30 void error_handling(char *message); void read_routine(int sock, char *buf); void write_routine(int sock, char *buf); int main(int argc, char *argv[]) { int sock; char buf[BUF_SIZE]; pid_t pid; struct sockaddr_in serv_addr; if (argc != 3) { printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e \\n\", argv[0]); exit(1); } sock = socket(PF_INET, SOCK_STREAM, 0); if (sock == -1) { error_handling(\"socket() error\"); } memset(\u0026serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = inet_addr(argv[1]); serv_addr.sin_port = htons(atoi(argv[2])); if (connect(sock, (struct sockaddr *)\u0026serv_addr, sizeof(serv_addr)) == -1) { error_handling(\"connect() error\"); } else { puts(\"connected....\"); } pid = fork(); if (pid == 0) { write_routine(sock, buf); } else { read_routine(sock, buf); } close(sock); return 0; } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } void read_routine(int sock, char *buf) { while (1) { int str_len = read(sock, buf, BUF_SIZE); if (str_len == 0) { return; } buf[str_len] = 0; printf(\"Message from server : %s\", buf); } } void write_routine(int sock, char *buf) { while (1) { fgets(buf, BUF_SIZE, stdin); if (!strcmp(buf, \"q\\n\") || !strcmp(buf, \"Q\\n\")) { shutdown(sock, SHUT_WR); return; } write(sock, buf, strlen(buf)); } } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:5","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r进程间通信","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:11:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r进程间通信的基本概念进程间通信（Inter Process Communication）意味着两个不同进程间可以交换数据，为了完成这一点，操作系统中应提供两个进程可以同时访问的内存空间。 对进程通信的基本理解只要有两个进程可以同时访问的内存空间，就可以通过此空间交换数据。但进程具有完全独立的内存结构。连通过fork函数创建的子进程也不会与父进程共享内存空间。因此，进程间通信只能通过其他特殊方法完成。 通过管道实现进程间通信 为了完成进程间通信，需要创建管道。管道并非属于进程的资源，而是和套接字一样，属于操作系统（也就不是fork函数的复制对象）。所以，两个进程通过操作系统提供的内存空间进行通信。创建管道的函数如下: ##include \u003cunistd.h\u003e int pipe(int filedes[2]); // 成功返回0，失败返回-1 // filedes[0] 通过管道接收数据时使用的文件描述符，即管道出口 // filedes[1] 通过管道传输数据时使用的文件描述符，即管道入口 以长度为 2 的 int 数组地址值作为参数调用上述函数时，数组中存有两个文件描述符，它们将被用作管道的出口和入口。父进程调用该函数时将创建管道，同时获取对应于出入口的文件描述符，此时父进程可以读写同一管道。由于父进程的目的是与子进程进行数据交换，因此需要将入口或出口中的 1 个文件描述符传递给子进程。 // pipe1.c ##include \u003cstdio.h\u003e ##include \u003cunistd.h\u003e ##define BUF_SIZE 30 int main(int argc, char *argv[]) { int fds[2]; char str[] = \"Who are you?\"; char buf[BUF_SIZE]; pid_t pid; pipe(fds); pid = fork(); if (pid == 0) { write(fds[1], str, sizeof(str)); } else { read(fds[0], buf, BUF_SIZE); puts(buf); } return 0; } 上例中的通信方法如下。父子进程都可以访问管道 I/O 路径，但子进程仅用输入路径，父进程仅用输出路径。 通过管道进程进程间双向通信创建 2 个进程通过 1 个管道进程双向数据交换，通信方式如下: // pipe2.c ##include \u003cstdio.h\u003e ##include \u003cunistd.h\u003e ##define BUF_SIZE 30 int main(int argc, char *argv[]) { int fds[2]; char str1[] = \"Who are you?\"; char str2[] = \"Thank you for your message\"; char buf[BUF_SIZE]; pid_t pid; pipe(fds); pid = fork(); if (pid == 0) { write(fds[1], str1, sizeof(str1)); sleep(2); read(fds[0], buf, BUF_SIZE); printf(\"Child proc output : %s\\n\", buf); } else { read(fds[0], buf, BUF_SIZE); printf(\"Parent proc output : %s\\n\", buf); write(fds[1], str2, sizeof(str2)); sleep(3); } return 0; } 运行结果: 向管道传递数据时，先读的进程会把数据取走。简而言之，数据进入管道后称为无主数据。通过read函数先读取数据的进程将得到数据，即使是该进程将数据传到了管道。 只用 1 个管道进行双向通信并非易事。为了实现这点，程序需要预测并控制运行流程，这在每种系统中都不同，可以视为不可能完成的任务。我们可以通过创建 2 个管道进行双向通信。各自负责不同的数据流动即可。 ##include \u003cstdio.h\u003e ##include \u003cunistd.h\u003e ##define BUF_SIZE 30 int main(int argc, char *argv[]) { int fds1[2], fds2[2]; char str1[] = \"Who are you?\"; char str2[] = \"Thank you for your message\"; char buf[BUF_SIZE]; pid_t pid; pipe(fds1); pipe(fds2); pid = fork(); if (pid == 0) { write(fds1[1], str1, sizeof(str1)); read(fds2[0], buf, BUF_SIZE); printf(\"Child proc output : %s\\n\", buf); } else { read(fds1[0], buf, BUF_SIZE); printf(\"Parent proc output : %s\\n\", buf); write(fds2[1], str2, sizeof(str2)); sleep(3); } return 0; } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:11:1","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r运用进程间通信\r保存消息的回声服务器端扩展echo_mpserv.c，将回声客户端传输得的字符串按序保存到文件中。 我们可以将该任务委托给另外的进程。换言之，另行创建进程，从向客户端提供服务的进程读取字符串信息。当然，该过程中需要创建用于接收数据的管道。 // echo_storeserv.c ##include \u003cstdio.h\u003e ##include \u003cstdlib.h\u003e ##include \u003cstring.h\u003e ##include \u003cunistd.h\u003e ##include \u003csignal.h\u003e ##include \u003csys/wait.h\u003e ##include \u003carpa/inet.h\u003e ##include \u003csys/socket.h\u003e ##define BUF_SIZE 30 void error_handling(char *message); void read_childproc(int sig); int main(int argc, char *argv[]) { int serv_sock, clnt_sock; struct sockaddr_in serv_adr, clnt_adr; int fds[2]; pid_t pid; struct sigaction act; socklen_t adr_sz; int str_len, state; char buf[BUF_SIZE]; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } act.sa_handler = read_childproc; sigemptyset(\u0026act.sa_mask); act.sa_flags = 0; state = sigaction(SIGCHLD, \u0026act, 0); serv_sock = socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family = AF_INET; serv_adr.sin_addr.s_addr = htonl(INADDR_ANY); serv_adr.sin_port = htons(atoi(argv[1])); if (bind(serv_sock, (struct sockaddr *)\u0026serv_adr, sizeof(serv_adr)) == -1) { error_handling(\"bind() error\"); } if (listen(serv_sock, 5) == -1) { error_handling(\"listen() error\"); } pipe(fds); pid = fork(); if (pid == 0) { FILE *fp = fopen(\"echomsg.txt\", \"wt\"); char msgbuf[BUF_SIZE]; int i, len; for (i = 0; i \u003c 10; i++) { len = read(fds[0], msgbuf, BUF_SIZE); fwrite((void *)msgbuf, 1, len, fp); } fclose(fp); return 0; } while (1) { adr_sz = sizeof(clnt_adr); clnt_sock = accept(serv_sock, (struct sockaddr *)\u0026clnt_adr, \u0026adr_sz); if (clnt_sock == -1) { continue; } else { puts(\"new client connected...\"); } pid = fork(); if (pid == -1) { close(clnt_sock); continue; } if (pid == 0) // 子进程运行区域 { close(serv_sock); while ((str_len = read(clnt_sock, buf, BUF_SIZE)) != 0) { write(clnt_sock, buf, str_len); write(fds[1], buf, str_len); } close(clnt_sock); puts(\"client disconnected...\"); return 0; } else { close(clnt_sock); } } close(serv_sock); return 0; } void read_childproc(int sig) { pid_t pid; int status; pid = waitpid(-1, \u0026status, WNOHANG); printf(\"removed proc id %d \\n\", pid); } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:11:2","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\rI/O 复用","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:12:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r多种 I/O 函数","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:13:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r多播与广播","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:14:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r套接字和标准 I/O","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:15:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r关于 I/O 流分离的其他内容","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:16:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r由于 select 和 epoll","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:17:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r多线程服务器端的实现","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:18:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\rWindows 平台下的线程的使用","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:19:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\rWindows 中的线程同步","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:20:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r异步通知的 I/O 模型","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:21:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r重叠 I/O 模型","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:22:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r制作 HTTP 服务器端","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:23:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r进阶内容","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:24:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r推荐Windows Sockets 2: https://learn.microsoft.com/en-us/windows/win32/api/_winsock/ 《计算机网络 自顶向下》 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:25:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["计算机网络"],"content":"\r参考《TCP/IP 网络编程》 ","date":"2024-02-25","objectID":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:26:0","tags":["网络编程","读书笔记"],"title":"TCP/IP网络编程","uri":"/tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["CSS"],"content":"\r2023/11/23 更新: 增加 4 个练习项目——Parallax scroll animation、Voyage Slider、App Menu With Lock Screen 和 Old Film Effect 2023/12/13 更新: 增加练习项目——Polaroid Camera ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:0:0","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r准备随书代码: https://github.com/CSSInDepth/css-in-depth Node.js: https://nodejs.org/en/ Visual Studio Code: https://code.visualstudio.com/ Git: https://git-scm.com/ ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:1:0","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r层叠、优先级和继承","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:2:0","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r层叠当声明冲突时，层叠会依据三种条件解决冲突。 样式表的来源: 样式是从哪里来的，包括你的样式和浏览器默认样式。 选择器优先级: 哪些选择器比另一些选择器更重要。 源码顺序: 样式在样式表里的声明顺序。 选择器和声明块一起构成了规则集（ruleset）。一个规则集也简称一个规则。 @规则（at-rules）是指用@符号开头的语法，比如@import规则或者@media查询。 样式表的来源自己的样式表属于作者样式表，除此之外还有用户代理样式表，即浏览器默认样式。用户代理样式表优先级低，自己的样式会覆盖它们。 标记了!important的声明会被当作更高优先级的来源，因此总体的优先级按照由高到低排列如下所示: 作者的!important 作者 用户代理 理解优先级如果无法用来源解决冲突声明，浏览器会尝试检查它们的优先级。 浏览器将优先级分为两部分: HTML 的行内样式和选择器样式。 优先级的规则如下： 如果选择器的 ID 数量更多，则它会胜出。 如果 ID 数量一致，那么拥有更多类的选择器胜出。 如果以上两次比较都一致，那么拥有最多标签名的选择器胜出。 伪类选择器（如:hover）和属性选择器（如[type=\"input\"]）与一个类选择器的优先级相同。通用选择器（*）和组合器（\u003e、+、~）对优先级没有影响。 我们可以用优先级标记来比较不同选择器的优先级: 通常最好让优先级尽可能低，这样当需要覆盖一些样式时，才能有选择空间。 源码顺序如果两个声明的来源和优先级相同，其中一个声明在样式表中出现比较晚，或者位于页面较晚引入的样式表中，则该声明胜出。 两条经验法则 在选择器中不要使用 ID。就算只用一个 ID，也会大幅度提升优先级。但需要覆盖整个选择器时，通常找不到另一个有意义的 ID，于是就会复制原来的选择器，然后加上另一个类，以区别想要覆盖的选择器。 不要使用!important。它比 ID 更难覆盖，一旦用了它，想要覆盖原先的声明，就需要加上一个!important，而且依然要处理优先级的问题。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:2:1","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r继承只有特定的属性能被继承，通常是我们希望被继承的那些。它们主要是跟文本相关的属性: color font font-family font-size font-weight font-variant font-style line-height letter-spacing text-align text-indent text-transform white-space word-spacing 列表属性也可以被继承: list-style list-style-type list-style-position list-style-image 活用开发者工具了解具体情况: ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:2:2","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r特殊值有两个特殊值可以赋给任意属性，用户控制层叠: inherit和initial。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:2:3","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r简写属性https://developer.mozilla.org/zh-CN/docs/Web/CSS/Shorthand_properties ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:2:4","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r相对单位相对单位会根据外部因素发生变化。例如，2em的具体值会更具它作用到的元素（有时甚至是根据属性）而变化。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:0","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r相对单位的好处响应式: 能够根据浏览器窗口的大小有不同的“响应”。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:1","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\rem 和 rem在 CSS 中，1em等于当前元素的字号，其准确值取决于作用的元素。 浏览器会根据相对单位的值计算出绝对值，称作计算值（computed value）。 使用 em 定义字号如果声明font-size: 1.2em，这个font-size是根据继承的字号来计算的。 body { font-size: 16px; } .slogan { font-size: 1.2em; /* 19.2px */ padding: 1.2em; /* 23.04px */ } 字体缩小问题 body { font-size: 16px; } ul { font-size: .8em; } 会导致嵌套的列表字体越来越小。纠正方法如下: ul { font-size: .8em; } ul ul { font-size: 1em; } 使用 rem 设置字号根节点有一个伪类选择器（:root），可以用来选中它自己。这等价于类型选择器html，但html的优先级相当于一个类名，而不是标签。 rem是 root em 的缩写。rem 不是相当于当前元素，而是相对于根元素的单位。 :root { font-size: 1em; /* 使用浏览器的默认字号(16px) */ } ul { font-size: .8rem; /* 12.8px */ } 提示: 拿不准的时候，用 rem 设置字号，用 px 设置边框，用 em 设置其他大部分属性。 通过这种策略，可以轻松构建响应式面板: .panel { padding: 1em; border-radius: 0.5em; border: 1px solid #999; } .panel \u003e h2 { margin-top: 0; font-size: 0.8rem; font-weight: bold; text-transform: uppercase; } 使用媒体查询改变根元素的字号。这样就可以基于不同用户的屏幕尺寸，渲染出不同大小的面板。 :root { font-size: 0.75em; } @media (min-width: 800px) { /* 宽度800px以上 */ :root { font-size: 0.875em; } } @media (min-width: 1200px) { /* 宽度1200px以上 */ :root { font-size: 1em; } } 充分体现了使用em的优势。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:2","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r视口的相对单位视口: 浏览器窗口中网页可见部分的边框区域。不包括浏览器的地址栏、工具栏、状态栏。 vh: 视口高度的 1/100 vw: 视口宽度的 1/100 vmin: 视口宽、高中较小一方的 1/100 vmax: 视口宽、高中较大一方的 1/100 使用 vw 定义字号给一个元素加上font-size: 2vw在一个 1200px 的显示器上计算值为 24px。在一个 768px 宽的平板上，计算值约为 15px。这样做的好处在于元素能够在这两种大小之间平滑地过渡， 这意味着不会在某个断点突然开始改变。当视口大小改变时，元素会逐渐过渡。 使用 calc()定义字号calc()函数内可以对两个及其以上的值进行基本运算。支持的运算包括加减乘除。 :root { font-size: calc(0.5em + 1vw); } https://gist.github.com/basham/2175a16ab7c60ce8e001 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:3","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r自定义属性(即 CSS 变量)定义一个自定义属性: :root { --main-font: Helvetica, Arial, sans-serif; } p { font-family: var(--main-font); } 变量名用两个连字符用来和 CSS 属性区分。 变量必须在一个声明块内声明。这里用了:root选择器，所以可以在整个网页使用。 var()函数接受第二个参数，它指定了备用值。如果第一个参数指定的变量未定义，那么就会使用第二个值。 若 var()函数算出来的是一个非法值，对应的属性就会设置为其初始值。 动态改变自定义属性自定义属性的声明能够层叠和继承：可以再多个选择器中定义相同的变量，这个变量在网页的不同地方有不同的值。 如下所示: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003e导航\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"style.css\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003cheader class=\"page-header\"\u003e \u003ch1 class=\"title\" id=\"page-title\"\u003eWombat Coffe Roasters\u003c/h1\u003e \u003cnav\u003e \u003cul class=\"nav\" class=\"main-nav\"\u003e \u003cli\u003e\u003ca href=\"/\"\u003eHome\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/coffees\"\u003eCoffes\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/brewers\"\u003eBrewers\u003c/a\u003e\u003c/li\u003e \u003cli\u003e \u003ca href=\"/specials\" class=\"featured\"\u003eSpecials\u003c/a\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/nav\u003e \u003c/header\u003e \u003cmain\u003e \u003cdiv class=\"panel\"\u003e\u003c/div\u003e \u003cdiv class=\"panel dark\"\u003e\u003c/div\u003e \u003c/main\u003e \u003c/body\u003e \u003c/html\u003e :root { font-size: calc(0.5em + 0.5vw); --bg-color: #368; } h1 { font-family: sans-serif; } ##page-title { font-family: sans-serif; } .title { font-family: monospace; } .panel { width: 5em; height: 5em; background-color: var(--bg-color); margin: 1em; } .dark { --bg-color: #000; } 使用 JavaScript 改变自定义属性 const rootElement = document.documentElement; const styles = getComputedStyle(rootElement); const bgColor = styles.getPropertyValue(\"--bg-color\"); console.log(String(bgColor).trim()); rootElement.style.setProperty(\"--bg-color\", \"red\"); ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:4","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r盒模型\r调整盒模型在 CSS 中可以使用box-sizing属性调整盒模型的行为。其默认值为content-box，任何指定的宽或高都只会设置内容盒子的大小。将其值设为border-box后，height和width属性会设置内容、内边距以及边框的大小总和。 全局设置 border-box通用选择器*可以选中页面上所有元素，并用两个选择器选中网页的所有伪元素。 *, ::before, ::after { box-sizing: border-box; } 如果用了第三方组件，使用上述方式可能会破坏其中一些组件的布局。我们可以利用继承改一下修改盒模型的方式。 :root { box-sizing: border-box; } *, ::before, ::after { box-sizing: inherit; } ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:5","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r元素高度的问题通常最好避免给元素指定明确的高度。普通文档流是为限定的宽度和无限的高度设计的。内容会填满视口的高度，然后在必要的时候折行。因此，容器的高度由内容天然地决定，而不是容器自己决定。 普通文档流——指的是网页元素的默认布局行为。行内元素跟随文字的方向从左到右排列，当到达容器边缘时会换行。块级元素会占据完整的一行，前后都有换行。 控制溢出行为当明确设置一个元素的高度时，内容可能会溢出。当内容在限定区域放不下渲染到父元素外面时，就会发生这种现象。 用 overflow 属性可以控制溢出内容的行为，该属性支持以下 4 个值。 visible（默认值）——所有内容可见，即使溢出容器边缘。 hidden——溢出容器内边距边缘的内容被裁剪，无法看见。 scroll——容器出现滚动条。 auto——只有内容溢出时容器才会出现滚动条。 百分比高度的备选方案用百分比指定高度存在问题。百分比参考的事元素容器块的大小，但是容器的高度通常是由子元素的高度决定的。这样会造成死循环，浏览器处理不了，因此它会忽略这个声明。想要让百分比高度生效，必须给父元素明确定义一个高度。 CSS 表格布局 给容器设置display: table，给每一列设置display: table-cell。这里没有table-row元素，因为 CSS 表格不像 HTML 表格那样必须有行元素。 不像block的元素，默认情况下，显示为table的元素宽度不会扩展到 100%，因此需要明确指定宽度。但外边距不会作用于table-cell元素。 可以用表格元素border-spacing属性来定义单元格的间距。该属性接受两个长度值: 水平间距和垂直间距。可以给容器加上border-spacing: 1.5em 0，但这会产生一个副作用: 这个值也会作用于表格的外边缘。如此一来就无法和头部左右对齐。 我们可以使用负外边距解决这个问题，但这需要给整个表格包裹一层新的容器。代码如下: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003e盒模型\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"style.css\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003cheader\u003e \u003ch1\u003eFranklin Running Club\u003c/h1\u003e \u003c/header\u003e \u003cdiv class=\"wrapper\"\u003e \u003cdiv class=\"container\"\u003e \u003cmain class=\"main\"\u003e \u003cp\u003e The Franklin Running Club meets at 6:00pm every Thursday at the town square. Runs are three to five miles, at your own pace. \u003c/p\u003e \u003c/main\u003e \u003caside class=\"sidebar\"\u003e \u003cdiv class=\"widget\"\u003e\u003c/div\u003e \u003cdiv class=\"widget\"\u003e\u003c/div\u003e \u003c/aside\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 样式设置如下: :root { box-sizing: border-box; } *, ::before, ::after { box-sizing: inherit; } .wrapper { margin-left: -1.5em; margin-right: -1.5em; } .container { display: table; border-spacing: 1.5em 0; width: 100%; } body { background-color: #eee; font-family: Helvetica, Arial, sans-serif; } header { color: #fff; background-color: #0072b0; border-radius: 0.5em; } main { display: block; } .main { display: table-cell; width: 70%; background-color: #fff; border-radius: 0.5em; } .sidebar { display: table-cell; margin-left: 1.5em; width: calc(30% - 1.5em); padding: 1.5em; background-color: #fff; border-radius: 0.5em; } Flexbox 还可以用 Flexbox 实现两列等高布局。Flexbox 不需要一个额外的 div 包裹元素，它默认会产生等高的元素，也不需要使用负外边距。 :root { box-sizing: border-box; } *, ::before, ::after { box-sizing: inherit; } .container { display: flex; } body { background-color: #eee; font-family: Helvetica, Arial, sans-serif; } header { color: #fff; background-color: #0072b0; border-radius: 0.5em; } main { display: block; } .main { width: 70%; background-color: #fff; border-radius: 0.5em; } .sidebar { width: 30%; padding: 1.5em; margin-left: 1.5em; background-color: #fff; border-radius: 0.5em; } 弹性容器（Flex Container）子元素默认等高。 使用 min-height 和 max-height可以用这两个属性指定最小或最大值，而不是明确定义高度，这样元素就可以再这些界限内自动决定高度。 可以用min-height指定一个最小高度，而不指定它的明确高度。这意味着元素至少等于指定的高度，如果内容太多，浏览器就会允许元素自己扩展高度，以免内容溢出。 max-height允许元素自然地增加到一个特定界限。如果到达这个界限，元素就不再增高，内容会溢出。 还有类似属性min-width和max-width。 垂直居中给块级元素设置vertical-align: middle后，通常不能垂直居中，因为浏览器会忽略这个声明。 vertical-align声明只会影响行内元素或table-cell元素。 垂直居中指南 http://howtocenterincss.com/ ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:6","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r负外边距https://www.educba.com/negative-margin-css/ ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:7","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r外边距折叠在没有其他 CSS 的影响下，所以相邻的顶部和底部外边距都会折叠。 只有上下外边距会产生折叠，左右外边距不会折叠。 如下方法可以防止外边距折叠： ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:8","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r容器内的元素间距猫头鹰选择器 body * + * { margin-top: 1.5em; } ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:3:9","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r理解浮动","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:4:0","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r浮动的设计初衷浮动能将一个元素（通常是一张图片）拉到容器的一侧，这样文档流就能包围它。 浮动元素会被移除正常文档流，并被拉到容器边缘。文档流会重新排列，但是它会包围浮动元素此刻所占据的空间。 如果让多个元素向同侧浮动，它们就会挨着排列。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:4:1","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r容器折叠和清楚浮动\r理解容器折叠 \u003c!doctype html\u003e \u003chead\u003e \u003cstyle\u003e :root { box-sizing: border-box; } *, ::before, ::after { box-sizing: inherit; } body { background-color: #eee; font-family: Helvetica, Arial, sans-serif; } body * + * { margin-top: 1.5em; } header { padding: 1em 1.5em; color: #fff; background-color: #0072b0; border-radius: .5em; margin-bottom: 1.5em; } .main { padding: 0 1.5em; background-color: #fff; border-radius: .5em; } .container { max-width: 1080px; margin: 0 auto; } .media { float: left; width: 50%; padding: 1.5em; background-color: #eee; border-radius: 0.5em; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"container\"\u003e \u003cheader\u003e \u003ch1\u003eFranklin Running Club\u003c/h1\u003e \u003c/header\u003e \u003cmain class=\"main clearfix\"\u003e \u003ch2\u003eRunning tips\u003c/h2\u003e \u003cdiv\u003e \u003cdiv class=\"media\"\u003e \u003cimg class=\"media-image\" src=\"runner.png\"\u003e \u003cdiv class=\"media-body\"\u003e \u003ch4\u003eStrength\u003c/h4\u003e \u003cp\u003e Strength training is an important part of injury prevention. Focus on your core\u0026mdash; especially your abs and glutes. \u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"media\"\u003e \u003cimg class=\"media-image\" src=\"shoes.png\"\u003e \u003cdiv class=\"media-body\"\u003e \u003ch4\u003eCadence\u003c/h4\u003e \u003cp\u003e Check your stride turnover. The most efficient runners take about 180 steps per minute. \u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"media\"\u003e \u003cimg class=\"media-image\" src=\"shoes.png\"\u003e \u003cdiv class=\"media-body\"\u003e \u003ch4\u003eChange it up\u003c/h4\u003e \u003cp\u003e Don't run the same every time you hit the road. Vary your pace, and vary the distance of your runs. \u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"media\"\u003e \u003cimg class=\"media-image\" src=\"runner.png\"\u003e \u003cdiv class=\"media-body\"\u003e \u003ch4\u003eFocus on form\u003c/h4\u003e \u003cp\u003e Run tall but relaxed. Your feet should hit the ground beneath your hips, not out in front of you. \u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/main\u003e \u003c/div\u003e \u003c/body\u003e 效果如下： 容器白色的背景没有延伸到媒体盒子后面。这是因为浮动元素不同于普通文档流的元素，它们的高度不会加到父元素上。 一个解决的办法是使用和浮动配套的clear属性。将一个元素放在主容器末尾，并对其使用clear，这会让容器扩展到浮动元素下面。 \u003cmain class=\"main\"\u003e ... \u003cdiv style=\"clear: both;\"\u003e\u003c/div\u003e \u003c/main\u003e 因为空div本身没有浮动，所以容器就会扩展，直到包含它。 理解清除浮动 伪元素——特殊的选择器，可以选中文档的特定部分。伪元素以双冒号开头，大部分浏览器为了向后兼容也支持单冒号形式。 .clearfix::after { display: block; content: \" \"; clear: both; } 要给包含浮动的元素清除浮动。 https://learningnow.com.tw/css-float/ ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:4:2","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\rFlexbox","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:5:0","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\rFlexbox 的原则给元素添加display: flex，该元素就变成了一个弹性容器（Flex Container），它的直接子元素就变成了弹性子元素（Flex Item）。弹性子元素默认是在同一行按照从左到右的顺序并排排列。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:5:1","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r弹性子元素的大小flex属性控制弹性子元素在主轴方向上的大小（宽度）。 .column-main { flex: 2; } .column-sidebar { flex: 1; } flex属性是三个不同大小属性的简写：flex-grow、flex-shrink和flex-basis。 flex: 2等价于flex: 2 1 0%，也可以分别声明: .column-main { flex-grow: 2; flex-shrink: 1; flex-basis: 0%; } 使用flex-basis属性flex-basis定义了元素大小的基准值，即一个初始的主尺寸。flex-basis属性可以设置为任意的 width 值，包括 px、em、百分比。它的初始值是auto，此时浏览器会检查元素是否设置了width属性值。如果有，则使用width的值作为flex-basis的值；如果没有，则用元素内容自身的大小。使用flex-basis的值不是 auto，width 属性会被忽略。 使用flex-grow属性每个弹性子元素的flex-basis值计算出来后，它们（加上子元素之间的外边距）加起来会占据一定的宽度。加起来的宽度不一定正好填满弹性容器的宽度，多出来的留白会按照 flex-grow 的值分配每个弹性子元素。 flex-grow 的值为非负数。若一个弹性子元素的值 flex-grow 值为 0，那么它的宽度不会超过 flex-basis 的值；如果某个弹性子元素的 flex-grow 非 0，那么这些元素会增长到所有的剩余空间被分配完。 使用flex-shrink属性计算出弹性子元素的初始主尺寸后，它们的累加值可能会超出弹性容器的可用宽度。如果不用flex-shrink，就会导致溢出。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:5:2","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r弹性方向 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:5:3","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r对齐、间距等细节通常情况下，创建一个弹性盒子方法如下: 选择一个容器及其子元素，给容器设置display: flex 如有必要，给容器设置flex-direction 给弹性子元素设置外边距和/或 flex 值，用来控制它们的大小 理解弹性容器的属性弹性容器的属性: 弹性子元素的属性: ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:5:4","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r网格布局","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:6:0","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r网页布局开启新纪元和 Flexbox 类似，设置为display: grid的元素成为一个网格容器。它的子元素变成网格元素。 .grid { display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr; grid-gap: 0.5em; } .grid \u003e * { background-color: darkgray; color: white; padding: 2em; border-radius: 0.5em; } grid-template-columns和grid-template-rows定义了网格每列每行的大小。使用了一个新单位fr，代表每一列（或每一行）的分数单位（fraction unit）。 这个单位和 Flexbox 中flex-grow因子的表现一样。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:6:1","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r网络剖析 repeat()函数，在声明多个网格轨道时提供了简写方式。grid-template-rows: repeat(4, auto);定义了四个水平网格轨道。轨道大小设置为auto，轨道会根据自身内容扩展。 用repeat()符号还可以定义不同的重复模式，比如repeat(3, 2fr, 1fr)会重复三遍这个模式，从而定义 6 个网格轨道。 可以给网格线或网格区域命名。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:6:2","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r显式和隐式网格使用grid-template-*属性定义网格轨道时，创建的是显式网格。 可以给网格容器设置grid-auto-columns和grid-auto-rows为隐式网格轨道指定一个大小。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:6:3","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r对齐 CSS Grid 网格布局教程: https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html 最强大的 CSS 布局 —— Grid 布局: https://juejin.cn/post/6854573220306255880 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:6:4","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r定位和层叠上下文position属性可以用来构建下拉菜单、模态框以及现代 Web 应用程序的一些基本效果。 position属性的初始值是static。如果把它改成其他值，就说元素被定位了。若元素使用了静态定位，那么就说它未被定位。 定位将元素彻底从文档流中移走，允许将元素放在屏幕的任意位置。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:7:0","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r固定定位给一个元素设置position: fixed就能将元素放在视口的任意位置。这需要搭配四种属性一起使用：top、right、bottom和left。 这些属性的值决定了固定定位的元素与浏览器视口边缘的距离。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:7:1","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r绝对定位绝对定位不是相对视口，而是相对最近的祖先定位元素。 如果祖先元素都没有定位，那么绝对定位的元素会基于初始包含块来定位。初始包含块和视口一样大，固定在网页的顶部。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:7:2","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r相对定位相对定位会让元素从原来的位置移走。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:7:3","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r层叠上下文和z-index拥有较高z-index的元素出现在拥有较低z-index的元素前面。拥有负数z=index的元素出现在静态元素后面。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:7:4","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r响应式设计响应式设计的三大原则: 移动优先。在实现桌面布局之前先构建移动版的布局。 @media 规则。使用该样式规则，可以为不同大小的视口定制样式。通常叫作媒体查询，写的样式只有在特定条件下才会生效。 流式布局。这种方式允许容器根据视口宽度缩放尺寸。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:8:0","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r移动优先构建桌面版之前要先构建移动端布局。 移动端布局一般是很朴素的设计。主要关注的是内容，在大屏上，可以把页面的大块区域拿来做头部、主图和菜单。在移动设备上，用户通常有更明确的目标。 做响应式设计时，要确保 HTML 包含各种屏幕尺寸所需的全部内容。可以对每个屏幕尺寸应用不同的 CSS，但必须共享同一份 HTML。 断点（breakpoint）：一个特殊的临界值。屏幕尺寸到达这个值时，网页的样式会发生改变，以便给当前屏幕尺寸提供最佳的布局。 视口meta标签。该 HTML 标签告知移动设备，已特意将网页适配了小屏设备。如果不加该标签，移动浏览器会假定网页不是响应式的，并且会尝试模拟桌面浏览器，那之前的移动端设计就白做了。 为了避免这种情况，我们将meta标签包含进去。 \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /\u003e \u003ctitle\u003eWombat Coffee Roasters\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"./style.css\" /\u003e \u003c/head\u003e meta标签的content属性里包含两个选项。首先，它告诉浏览器当解析 CSS 时将设备宽度作为假定宽度，而不是一个全屏的桌面浏览器宽度。其次，当页面加载时，它使用initial-scale将缩放比设置为 100%。 现代浏览器的开发者工具提供了模拟移动浏览器的功能。 Using the viewport meta tag to control layout on mobile browsers: https://udn.realityripple.com/docs/Mozilla/Mobile/Viewport_meta_tag ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:8:1","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r媒体查询媒体查询允许某些样式只在页面满足特定条件时才生效。这样就可以根据屏幕大小定制样式。可以针对小屏设备定义一套样式，针对中等屏幕设备定义另一套样式，针对大屏幕设备再定义一套样式，这样就可以让页面的内容拥有多种布局。 媒体查询使用@media规则选择满足条件的设备。一条简单的媒体查询如下所示: @media (min-width: 560px) { .title \u003e h1 { font-size: 2.25rem; } } 在最外层的大括号内可以定义任意的样式规则。@media规则会对条件进行见检查，只有满足所有的条件时，才会让这些样式应用到页面上。上例中浏览器会检查min-width: 560px。只有当设备的视口宽度大于等于 560px 时，才会给标题设置2.25rem的字号，否则将会被忽略。 在媒体查询里更适合用 em，如: .title \u003e h1 { color: #333; text-transform: uppercase; font-size: 1.5rem; margin: 0.2em 0; } @media (min-width: 35em) { .title \u003e h1 { font-size: 2.25rem; } } 媒体查询的类型可以进一步将两个条件用and关键字联合起来组成一个媒体查询，如下所示: @media (min-width: 20em) and (max-width: 35em) {...} 这种联合媒体查询只在设备同时满足两个条件时生效。若设备只需满足多个条件之一，可以用逗号分隔: @media (max-width: 20em), (min-width: 35em) {...} 还有一些别的媒体特征，参考: https://developer.mozilla.org/en-US/docs/Web/CSS/@media 给网页添加断点在任何媒体查询之前，最先写的是移动端样式，然后设置越来越大的断点。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:8:2","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r流式布局流式布局（Fluid Layout），有时被称作液体布局（Liquid Layout），指的是使用的容器随视口宽度而变化。它和固定布局相反，固定布局的列都是用 px 或 em 单位定义。固定容器（例如，设定了width: 800px的元素）在小屏上会超出视口范围，导致需要水平滚动条，而流式容器会自动缩小以适应视口。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:8:3","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r响应式图片创建不同分辨率的图片副本，利用媒体查询发送合适的图片。或者使用srcset提供对应的图片。 The anatomy of responsive images: https://jakearchibald.com/2015/anatomy-of-responsive-images/ ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:8:4","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r推荐RWD 是什么？: https://welly.tw/serp-rank-optimization/what-is-rwd-and-how-to-use The Beginner’s Guide to Responsive Web Design: https://kinsta.com/blog/responsive-web-design/ ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:8:5","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r模块化 CSS","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:9:0","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r基础样式: 打好基础每个样式表的开头都要写一些给整个页面使用的通用规则。这些规则通常被称为基础样式，其他样式是构建在这些基础样式之上的。 :root { box-sizing: border-box; } *, *::before, *::after { box-sizing: inherit; } body { font-family: Helvetica, Arial, sans-serif; } normalize.css库，可以协助消除不同客户端浏览器上的不一致。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:9:1","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r模式库","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:10:0","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r背景、阴影和混合模式","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:11:0","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r渐变background属性还有很多功能等着我们去探索，实际上，它是以下八个属性的简写。 background-image: 指定一个文件或生成的颜色渐变作为背景图片 background-position: 设置背景图片的初始位置 background-size: 指定元素内背景图片的渲染尺寸 background-repeat: 决定在需要填充整个元素时，是否平铺图片 background-origin: 决定背景相对于元素的边框盒、内边距框盒（初始值）或内容盒子来定位 background-clip: 指定背景是否应该填充边框盒（初始值）、内边距框盒或内容盒子 background-attachment: 指定背景图片是随着元素上下滚动（初始值），还是固定在视口区域。使用fixed值会对页面性能产生负面影响 background-color: 指定纯色背景，渲染到背景图片下方 使用简写属性background可以设置指定的值，同时把其他属性重置为初始值。因此，在需要用到多个属性时，可以考虑用单独的值。 background-image可以接受一个图片 URL 路径，例如background-image: url(coffee-beans.jpg)。也可以接受一个渐变函数，例如一个从白色过渡到蓝色的渐变。 线性渐变 .fade { height: 200px; width: 400px; background-image: linear-gradient(to right, white, blue); } linear-gradient函数使用三个参数来定义行为: 角度、起始颜色和终止颜色。上例的角度是to right（也可以是to left、to top、to bottom，或者是to bottom right），意思是渐变从元素的左侧开始平滑过渡到右侧。也可以使用其他的颜色表示方法，比如#0000ff、rgb(0,0,255)或者transparent关键字。 可以用确切的单位（比如度）更精确地控制角度。值0deg代表垂直向上，更大的值会颜色顺时针变化，90deg代表向右渐变。 度是最常用的单位，还有一些其他单位可用来表示角度: rad: 弧度，完整的圆是 2Π turn: 代表环绕圆周的圈数 gad: 百分度，一个完整的圆是 400 百分度 可以定义包含多个颜色的渐变，其中每个颜色可以称为颜色节点（Color Stop）。下面例子包含三个颜色节点的渐变: .fade { height: 200px; width: 400px; background-image: linear-gradient(90deg, red, white, blue); } 一个渐变可以接受任意数量的颜色节点，节点之间用逗号分隔。渐变会自动均匀地平铺这些颜色节点。本例中，最左侧（0%）从红色开始，过渡到中间（50%）的白色，到最右侧的蓝色（100%）。我们也可以在渐变函数中为每个颜色节点明确指定位置。 .fade { height: 200px; width: 400px; background-image: linear-gradient(90deg, red 0%, white 50%, blue 100%); } 使用repeating-linear-gradient()可以实现重复渐变，对于重复渐变最好使用特定的长度而不是百分比，因为设置的值决定了要重复图片大小。 条纹进度条示例: .fade { height: 1em; width: 400px; background-image: repeating-linear-gradient( -45deg, #57b, #57b 10px, #148 10px, #148 20px ); border-radius: 0.3em; } 更多例子，请看 Stripes in CSS: https://css-tricks.com/stripes-css/ 径向渐变线性渐变是从元素的一端开始，沿着直线过渡到另一端。而径向渐变不同，它是从一个点，全方位向外扩展。 .fade { height: 200px; width: 400px; background-image: radial-gradient(white, blue); } 更多例子: 若想深入研究一下，可看 Using CSS gradients: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Images/Using_CSS_gradients ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:11:1","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r阴影阴影是另一种可以为网页增加立体感的特效。有两个属性可以常见阴影，box-shadow为元素盒子生成阴影，text-shadow为渲染后的文字生成阴影。 模糊半径用来控制阴影边缘模糊区域的大小（可以简单理解为模糊程度），可以为阴影生成一个更柔和、有点透明的边缘。扩展半径用来控制阴影的大小，设置为正值可以使阴影全方位变大，设置负值则会变小。 使用渐变和阴影形成立体感新建一个网页和样式表，添加如下内容: \u003cbutton class=\"butotn\"\u003eSign up now\u003c/button\u003e .button { padding: 1em; border: 0; font-size: 0.8rem; color: white; border-radius: 0.5em; background-image: linear-gradient(to bottom, #57b, #148); box-shadow: 0.1em 0.1em 0.5em #124; } .button:active { box-shadow: inset 0 0 0.5em #124, inset 0 0.5em 1em rgba(0, 0, 0, 0.4); } 上面的样式增加了一个inset关键字，这样可以让阴影出现在元素边框的内部，而非之前的外部。同时定义了不止一个阴影，用逗号分隔。通过这种方式可以添加多个阴影。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:11:2","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r混合模式多数情况下，不论是使用真正的图片还是渐变，元素一般只用一张背景图片。但某些情况下可能会想要用两张或者更多的背景图片，CSS 支持这么做。 background-image属性可以接受任意数量的值，相互之间用逗号分开。 .blend { background-image: url(./bear.jpg), linear-gradient(to bottom, #57b, #148); } 使用多个背景图片时，排在前面的图片会渲染到排序靠后图片的上面。在此例中，bear.jpg 会遮盖在线性渐变之上，渐变就会不可见。若我们使用两张背景图片，那么一般是希望第二章图片可以透视显示。这时就可以用混合模式（Blend Mode）。 示例: \u003cdiv class=\"blend\"\u003e\u003c/div\u003e .blend { min-height: 80vh; background-image: url(./bear.jpg), url(./bear.jpg); background-size: cover; background-repeat: no-repeat; background-position: -30vw, 30vw; background-blend-mode: multiply; /* 应用混合模式 */ } 大部分背景相关的属性可以接受多个值，以逗号分隔。background-position就使用了两个值，第一个值用到第一张背景图片上，第二个值用到第二章背景图片上。 background-size和background-repeat属性也可以接受多个值，若只设置一个值，就会应用到所有背景图片上。 background-size属性接受两个关键字值，分别是cover和contain。使用cover值可以调整背景图片的大小，让其填满整个元素，这样会导致图片的边缘被裁剪掉一部分；使用contain值可以保证整个背景图片可见，这可能导致元素的一些地方不会被背景图片覆盖。该属性也可以接受长度值，用来明确设置背景图片的宽度和高度。 修改混合模式的其他值可以看到不同效果，例如: 使用某种颜色或者渐变为图片着色 为图片添加某种纹理效果，比如划痕或者老胶片放映时的颗粒感等 缓和、加深或减小图片的对比度，使图片上的文字更具可读性 在图片上覆盖一条文字横幅，但让图片完整显示 为图片着色通过使用混合模式，我们可以将一张全彩的图片着色成单一色相的图片。 .blend { min-height: 80vh; background-image: url(\"./bear.jpg\"); background-color: #148; background-size: cover; background-repeat: no-repeat; background-position: center; background-blend-mode: luminosity; /* 使用明度混合模式 */ } background-blend-mode不仅会合并多个背景图片，还会合并background-color。明度混合模式将前景层（大熊图片）的明度，与背景层（蓝色背景色图层）的色相饱和度混合。 即最终使用背景色图层的颜色，但明暗程度来自大熊图片。 混合模式的类型如下图所示: 为图片添加纹理纹理图片以重复平铺的方式覆盖在大熊图片上方。 .blend { min-height: 80vh; background-image: url(\"./scratches.png\"), url(\"./bear.jpg\"); background-size: 200px, cover; background-repeat: repeat, no-repeat; background-position: center, center; background-blend-mode: soft-light; /* 使用柔光混合模式 */ } 使用融合混合模式background-blend-mode属性可以实现多张图片的混合，但只能局限于元素的背景颜色或者背景图片使用。还有一个属性mix-blend-mode，可以融合多个元素。不仅可以混合图片，还可以把元素的文本和边框与容器的背景图片混合在一起。 .blend { background-image: url(\"./bear.jpg\"); background-size: cover; background-position: center; padding: 5em 0 10em; } .blend \u003e h1 { margin: 0; font-family: Arial, Helvetica, sans-serif; font-size: 6rem; text-align: center; mix-blend-mode: hard-light; background-color: #c33; color: #808080; border: 0.1em solid #ccc; border-width: 0.1em 0; } ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:11:3","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r对比、颜色和间距","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:12:0","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r对比最重要对比是设计中的一种手段，通过突出某物来达到吸引注意力的目的。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:12:1","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r排版随着 Web 字体的兴起，使用@font-face规则，告诉浏览器去哪里找到并下载自定义字体，供页面使用。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:13:0","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r过渡Web 是个生动的媒介，可以做如元素淡出、菜单滑入、颜色从一种变成另一种，实现这些效果最简单的方式是过渡（Transitions）。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:14:0","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r从这边到那边过渡是通过一系列transition-*属性来实现的。如果某个元素设置了过渡，那么当它的属性值发生变化时，并不是直接变成新值，而是使用过渡效果。 先看一个示例，最开始是个蓝绿色方角按钮，鼠标悬停时，过渡成一个红色圆角按钮: \u003cbutton\u003eHover over me\u003c/button\u003e button { background-color: hsl(180, 50%, 20%); border: 0; color: white; font-size: 1rem; padding: 0.3em 1em; transition-property: all; transition-duration: 0.5s; } button:hover { background-color: hsl(0, 50%, 50%); border-radius: 1em; } transition-property属性可以指定哪些属性使用过渡。关键字all表示所有的属性变化都使用过渡。transition-duration属性代表过渡到最终值之前需要多长时间，本例是 0.5 秒。 也可以使用简写属性transition，该简写属性接受四个参数值，分别代表四个过渡属性transition-property、transition-duration、transition-timing-function和transition-delay。 第一个值设置了哪些属性需要过渡，初始值是关键字 all，表示所有属性都生效。如果只有某个属性需要过渡，在这里指定属性即可。例如: transition-property: color将只应用在元素的颜色上，其他属性会立刻发生变化。也可以设置多个值，比如: transition-property: color, font-size。 第二个值是持续时间，用秒或者毫秒表示。 第三个值是定时函数，用来控制属性的中间值如何计算，实际上控制的是过渡过程中变化率如何加速或者减速。定时函数可以是一个关键字值，比如linear或者ease-in，也可以是自定义函数。 最后一个值是延迟时间，允许开发者在属性值改变之后过渡生效之前设置一个等待周期。 如果需要为两个不同的属性分别设置不同的过渡，可以添加多个过渡规则，以逗号分隔: transition: border-radius 0.3s linear, background-color 0.6s ease; 等价于以下代码: transition-property: border-radius, background-color; transition-duration: 0.3s, 0.6s; transition-timing-function: linear, ease; ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:14:1","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r定时函数定时函数用来说明如何移动。是以恒定的速度移动？还是开始慢，后面快？ 我们可以用 linear、ease-in 和 ease-out 等关键字来描述移动过程。 linear 过渡，值以固定的速度改变；ease-in 过渡，变化速度开始时慢，然后一直加速，直到过渡完成；ease-out 是减速，开始时快速变化，结束时比较慢。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:14:2","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r变换","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:15:0","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r旋转、平移、缩放和倾斜基本的变换规则如下: transform: rotate(90deg); 这条规则应用到元素上后，会让元素向右（顺时针）旋转 90 度。变换函数rotate()用来指定元素如何变换。其他变换函数如下: 旋转（Rotate）: 元素围绕一个轴心转动一定角度 平移（Translate）: 元素上下左右各个方向移动 缩放（Scale）: 缩小或放大元素 倾斜（Skew）: 使元素变形，顶边滑向一个方向，底边滑向相反的方向 每种变换都使用相应的函数作为transform属性的值。使用变换的时候元素可能会被移动到页面上的新位置，但它不会脱离文档流。其初始位置不会被其他元素占用。 变换不能作用在 span 或 a 这样的行内元素上。若确实需要，要么改变元素的 display 属性，替换掉inline（比如inline-block），要么把元素改为弹性子元素或网格项目。 更改变换基点变换是围绕基点（Point of origin）发生的。基点是旋转的轴心，也是缩放或倾斜开始的地方。这意味着元素的基点是固定在某个位置上，元素的剩余部分围绕基点变换（translate 是个例外，因为平移过程中元素整体移动）。 默认情况下，基点就是元素的中心，可以通过transform-origin属性改变基点位置。 例如: transform-origin: right center; transform-origin: 100% 50%; 以上两句等价。 使用多重变换可以对transform属性指定多个值，用空格隔开。变换的每个值从右向左按顺序执行，例如: transform: rotate(15deg) translate(15px, 0)，元素会先向右平移 15px，然后顺时针旋转 15 度。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:15:1","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r在运动中变换变换本身不具备太多实用性。当和动作结合起来使用的时候，变换就会有用多了。 SVG——可缩放矢量图形（Scalable Vector Graphics）的简称。这是一种基于 XML 的图片格式，使用向量定义图片。由于图片是使用数学计算来定义的，所以可以放大或缩小到任意尺寸。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:15:2","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r动画关键帧（keyframe）是指动画过程中某个特定时刻。我们定义一些关键帧，浏览器负责填充或者插入这些关键帧之间的帧图像。 从原理上看，过渡和关键帧动画类似: 我们定义第一帧（起始点）和最后一帧（结束点），浏览器计算所有中间值，使得元素可以在这些值之间平滑变换。但使用关键帧动画，我们就不在局限于两个点，而是想加多少就加多少。浏览器负责填充一个个点与点之间的值，直到最后一个关键帧，最终生成一系列无缝衔接的过渡。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:16:0","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r关键帧CSS 中的动画包括两部分: 用来定义动画的@keyframes规则和为元素添加动画的animation属性。 先创建一个简单的动画来熟悉以下语法: @keyframes over-and-back { 0% { background-color: hsl(0, 50%, 50%); transform: translate(0); } 50% { transform: translate(50px); } 100% { background-color: hsl(270, 50%, 50%); transform: translate(0); } } .box { width: 100px; height: 100px; background-color: green; animation: over-and-back 1.5s linear 3; } \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003e动画\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"./style.css\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"box\"\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:16:1","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r选择器","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:17:0","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r基础选择器 tagname——标签选择器。该选择器匹配目标元素的标签名。其优先级是0,0,1。例如: p、h1、strong。 .class——类选择器。该选择器匹配 class 属性中有指定类名的元素。其优先级是0,1,0。例如: .media、.nav-menu。 #id——ID 选择器。该选择器匹配拥有指定 ID 属性的元素。其优先级是1,0,0。例如: #sidebar。 *——通用选择器。该选择器匹配所有元素。其优先级是0,0,0。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:17:1","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r组合器组合器将多个基础选择器连接起来组成一个复杂选择器。 后代组合器（空格）——匹配的目标元素的其他元素的后代。例如: .nav-menu li。 子组合器（\u003e）——匹配的目标元素紧跟在其他元素后面。例如: .parent \u003e .child。 相邻兄弟组合器（+）——匹配的目标元素紧跟在其他元素后面。例如: p + h1。 通用兄弟组合器（~）——匹配所有跟随在指定元素之后的兄弟元素。 多个基础选择器可以连起来（不使用空格或者其他组合器）组成一个复合选择器（例如: h1.page-header）。复合选择器选中的元素将匹配其全部基础选择器。例如，.dropdown.is-active能选中\u003cdiv class=\"dropdown is-active\"\u003e...\u003c/div\u003e，当无法选中\u003cdiv class=\"dropdown\"\u003e\u003c/div\u003e。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:17:2","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r伪类选择器伪类选择器用于选中某个特定状态的元素。这种状态可能是由于用户交互，也可能是由于元素相对于其父级或兄弟元素的位置。其优先级等于一个类选择器(0, 1, 0)。 :first-child——匹配的元素是其父元素的第一个子元素。 :last-child——匹配的元素是其父元素的最后一个子元素。 :only-child——匹配的元素是其父元素的唯一一个子元素（无兄弟元素）。 CSS Pseudo-classes: https://www.w3schools.com/css/css_pseudo_classes.asp ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:17:3","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r伪元素选择器伪元素匹配在文档中没有直接对应 HTML 元素的特定部分。伪元素选择器可能只匹配元素的一部分，甚至向 HTML 标记中未定义的地方插入内容。 此类选择器以双冒号开头，大多数浏览器也支持单冒号的语法以便向后兼容。伪元素选择器的优先级与元素选择器(0, 0, 1)相等。 ::before——创建一个伪元素，使其成为匹配元素的第一个子元素。该元素默认是行内元素，可用于插入文字、图片或其他形状。必须指定 content 属性才能让元素出现。例如: .menu::before。 ::after——创建一个伪元素，使其成为匹配元素的最后一个子元素。元素默认是行内元素，可用于插入文字、图片或其他形状。必须指定 content 属性才能让元素出现。例如: .menu::after。 ::first-letter——用于指定匹配元素的第一个文本字符的样式。例如: h2::first-letter。 ::first-line——用于指定匹配元素的第一行文本的样式。 ::selection——用于指定用户使用鼠标高亮选择的任意文本的样式。通常用于改变选中文本的background-color。只有少数属性可以用，包括color、background-color、cursor、text-decoration。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:17:4","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r属性选择器属性选择器用于根据 HTML 属性匹配元素。其优先级与一个类选择器(0,1,0)相等。 [attr]——匹配的元素拥有指定属性 attr，无论属性值是什么，例如: input[disabled]。 [attr=\"value\"]——匹配的元素拥有指定属性 attr，且属性值等于指定的字符串值，例如: input[type=\"radio\"]。 [attr^=\"value\"]——“开头”属性选择器。该选择器匹配的元素拥有指定属性 attr，且属性值的开头是指定的字符串值，例如: a[href^=\"https\"]。 [attr$=\"value\"]——“结尾”属性选择器。该选择器匹配的元素拥有指定属性 attr，且属性值的结尾是指定的字符串值，例如: a[href$=\".pdf\"]。 [attr*=\"value\"]——“包含”属性选择器。该选择器匹配的元素拥有指定属性 attr，且属性值包含指定的字符串值，例如: [class*=\"sprite-\"]。 [attr~=\"value\"]——“空格分隔的列表”属性选择器。该选择器匹配的元素拥有指定属性 attr，且属性值是一个空格分隔的值列表，列表中的某个值等于指定字符串值，例如: a[rel=\"author\"]。 [attr|=\"value\"]——匹配的元素拥有指定属性 attr，且属性值要么等于指定的字符串值，要么以该字符串开头且紧跟着一个连字符。例如: [lang|=\"es\"]。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:17:5","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r预处理器预处理器的原理是把我们写的源文件转译成输出文件，即常规 CSS 样式表。对浏览器而言，最终输出的是常规 CSS，所以预处理器不会向语言添加任何新特性。但对于开发者来说，预处理器提供了许多便利。 比较流行的预处理器有 Sass 和 Less。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:18:0","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\rSass\r搭建环境使用npm init -y初始化一个新的 npm 项目。 使用npm install --save-dev node-sass安装node-sass包。 Sass 支持两种语法: Sass 和 SCSS。它们的语言特性一样，但 Sass 语法去掉了所有的大括号和分号，严格使用缩进来表示代码结构。SCSS 语法使用大括号和分号，因此看起来更像 CSS。 在项目目录下新建 sass 和 build 子目录，我们把源文件放在 sass 目录，生成的 CSS 文件将在 build 目录中。 在package.json中添加一条命令: \"scripts\": { \"sass\": \"node-sass sass/index.scss build/styles.css\" }, 之后运行npm run sass，可以看到在 build 目录中生成了 styles.css 文件。 理解 Sass 的核心特性\r变量在 Sass 中可以使用变量，在index.scss中添加如下代码: // 定义变量 $brand-blue: #0086b3; a:link { // 使用变量 color: $brand-blue; } body { font-family: Arial, Helvetica, sans-serif; color: black; } .page-heading { font-size: 1.6rem; // 使用变量 color: $brand-blue; } 运行npm run sass命令，输出文件build/styles.css内容如下: a:link { color: #0086b3; } body { font-family: Arial, Helvetica, sans-serif; color: black; } .page-heading { font-size: 1.6rem; color: #0086b3; } 变量已经被替换为了十六进制颜色值，浏览器可以直接加载。 行内计算Sass 支持使用+、-、*、/和%（模运算）进行行内计算，如此一来，我们就可以从一个初始值获得多个值。 $padding-left: 3em; .note-author { padding-left: $padding-left; font-weight: bold; } .note-body { padding-left: $padding-left * 2; } 使用npm run sass编译后生成如下结果: .note-author { padding-left: 3em; font-weight: bold; } .note-body { padding-left: 6em; } .note-body中的padding-left属性成功计算得到。 嵌套选择器Sass 允许在代码块内嵌套选择器，可以使用嵌套把有关联的代码分到一组: .site-nav { display: flex; \u003e li { margin-top: 0; // \u0026符号表示将插入外层选择器的位置 \u0026.is-active { display: block; } } } 编译如下: .site-nav { display: flex; } .site-nav \u003e li { margin-top: 0; } .site-nav \u003e li.is-active { display: block; } 默认情况下，外层的.site-nav选择器会自动添加到编译代码的每个选择器前面，拼接的位置会插入一个空格。使用\u0026符号代表外层选择器要插入的位置。 也可以在声明块内嵌套媒体查询用以避免重复书写相同选择器: html { font-size: 1rem; @media (min-width: 45em) { font-size: 1.25rem; } } 编译结果如下: html { font-size: 1rem; } @media (min-width: 45em) { html { font-size: 1.25rem; } } 这样一来，若修改选择器就不必再去媒体查询中修改对应的选择器。 局部文件(@import)局部文件允许我们将样式分割成多个独立的文件，Sass 将会把这些文件拼接在一起生成一个文件。 新建sass/button.scss文件，添加如下内容: .button { padding: 1em 1.25em; background-color: #265559; color: #333; } 在sass/index.scss文件中引入: @import \"button\"; html { font-family: Arial, Helvetica, sans-serif; } 编译结果如下: .button { padding: 1em 1.25em; background-color: #265559; color: #333; } html { font-family: Arial, Helvetica, sans-serif; } 局部文件会被编译，然后插入到@import规则指定的地方。 混入混入（mixin）是一小段 CSS 代码块，可以在样式表任意地方复用。如果有一段特定的字体样式在多个地方需要使用，使用混入就比较合适。 混入用@mixin规则来定义，用@include规则来调用。 清除浮动: @mixin clearfix { \u0026::before { display: table; content: \" \"; } \u0026::after { clear: both; } } .media { @include clearfix; background-color: #eee; } 预处理器会提取 mixin 中的代码，替换到@include规则所在位置。 .media { background-color: #eee; } .media::before { display: table; content: \" \"; } .media::after { clear: both; } 需要注意的是，最终编译生成的代码中没有了 clearfix。混入的内容只会添加到样式表中用到了它的地方。 我们还可以定义带参数的混入: @mixin alert-variant($color, $bg-color) { padding: 0.3em 0.5em; border: 1px solid $color; color: $color; background-color: $bg-color; } .alert-info { @include alert-variant(blue, lightblue); } .alert-danger { @include alert-variant(red, pink); } 每次调用混入，都可以传递不同的值。这些值指定为对应的两个变量，最终输出的 CSS 如下: .alert-info { padding: 0.3em 0.5em; border: 1px solid blue; color: blue; background-color: lightblue; } .alert-danger { padding: 0.3em 0.5em; border: 1px solid red; color: red; background-color: pink; } 扩展Sass 还支持@extend规则。和 mixin 类似，但编译方式有所不同。对于扩展，Sass 不会多次复制相同的声明，而是把选择器组合在一起，这样它们就会包含同样的规则。 .message { padding: 0.3em 0.5em; border-radius: 0.5em; } .message-info { @extend .message; color: blue; background-color: lightblue; } .message-danger { @extend .message; color: red; background-color: pink; } .message包含的规则被扩展到另外两个规则集中。 .message, .message-info, .message-danger { padding: 0.3em 0.5em; border-radius: 0.5em; } .message-info { color: blue; background-color: lightblue; } .message-danger { color: red; background-color: pink; } 使用mixin还是extend，需要具体情况具体分析。通常情况下，可能更倾向用mixin，只有需要减少 HTML 中填写的类名数量时才考虑使用@extend。 颜色处理Sass 还有一个特性就是颜色处理函数，如果需要两个同类的颜色（比如，同一种颜色的深浅版本），可以用如下代码来生成: $green: #63a53c; // 加深10% $green-dark: darken($green, 10%); $green-light: lighten($green, 10%); // 调整透明度 $green-transparent: rgba($green, 0.5); 通过这些函数，可以实现修改一个变量，同时修改相关联的其他颜色值。这样就","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:18:1","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\rPostCSSPostCSS 是另一种类型的预处理器。它编译源文件并输出一个处理过的 CSS 文件，这和 Sass 或者 Less 一样，但 PostCSS 是依靠插件工作的。若没有安装插件，输出文件就是没有任何变化的源文件副本。 搭建环境使用npm init -y初始化一个新的 npm 项目。 使用npm install --save-dev gulp安装gulp包。 AutoprefixerPostCSS 中最重要的插件可能就是 Autoprefixer，这个插件可以将相关的所有浏览器前缀都添加到 CSS 中。 为了使用Autoprefixer，我们使用命令npm install --save-dev gulp-atuoprefixer进行安装。 之后在项目根目录创建一个名为gulpfile.js的文件，添加如下内容: const gulp = require(\"gulp\"); const autoprefixer = require(\"gulp-autoprefixer\"); gulp.task(\"prefix\", () =\u003e { gulp .src(\"./css/*.css\") .pipe( autoprefixer({ cascade: false, }) ) .pipe(gulp.dest(\"./dist\")); }); 新建css目录，在其中的index.css文件中添加如下内容: .fullscreen a { display: flex; } 在package.json文件中加入以下内容: \"scripts\": { \"gulp\": \"gulp prefix\" }, \"browserslist\": [ \"last 99 versions\" ], 打开命令行执行npm run gulp。可以看到生成了一个新目录dist，其中有一个名为index.css的文件，内容如下: .fullscreen a { display: -webkit-box; display: -webkit-flex; display: -moz-box; display: -ms-flexbox; display: flex; } cssnextcssnext 是另一款非常流行的 PostCSS 插件。这款插件模拟那些还没有受所有浏览器支持的最新 CSS 语法。 cssnanocssnano 是基于 PostCSS 的压缩工具。可以从代码中剥离无关的空格，使代码体积尽可能变小，但同时依然保持相同的语法含义。 PreCSSPreCSS 是一款 PostCSS 插件包，提供了类似于 Sass 的特性，其中包含了$变量、行内计算、循环和混入等。 更多 PostCSS 插件，请看PostCSS Plugins。 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:18:2","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r项目要想完全掌握书上内容还得不断练习回顾，以下为推荐练习项目。 Parallax scroll animation: https://codepen.io/isladjan/pen/abdyPBw Voyage Slider | GSAP: https://codepen.io/dev_loop/pen/MWKbJmO App Menu With Lock Screen: https://codepen.io/Hyperplexed/details/vYpXNJd Old Film Effect - Pure CSS Animation: https://codepen.io/josetxu/pen/yLjwOwQ How I recreated a Polaroid camera with CSS gradients only ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:19:0","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["CSS"],"content":"\r参考《深入解析 CSS》 ","date":"2023-08-25","objectID":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/:20:0","tags":["CSS","Web","读书笔记"],"title":"深入解析CSS","uri":"/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90css/"},{"categories":["JavaScript"],"content":"在用 JavaScript 编程时，我们会经常用到数组对象，本文我们就来盘点一下那些好用的数组方法吧！😁 为了方便演示，我们先创建两个数组： const a = ['JavaScript', 'Php', 'Python', 'Ruby', 'C++', 'Node.js', 'Java', 'C++']; const b = [1, 3, 8, 16, 32, 48, 5]; ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:0:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\revery()首先，我们想知道数组a中的所有元素长度都是大于 4 的吗？对于这个数组的而言，结果是显然的。我们可以用如下的for循环得到问题的答案， let result = true; for (let i = 0; i \u003c a.length; i++\u003e){ if (a[i].length \u003c= 4){ result = false; break } } console.log(result); 结果如下： 但用for循环的方式多少显得有些麻烦，我们可以更加简洁地得到结果，那就是使用every()方法。 a.every(word =\u003e word.length \u003e 4); 通过传入一个箭头函数，就将问题解决啦，而且代码变得简洁清晰多了 😉。 ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:1:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rsome()接下来，我们想知道数组b中是否有大于 10 的元素呢？看起来这问题似乎有点傻，但…… 如果数组b中有 1 万个元素呢？ 我们同样可以使用for循环得到问题的答案： let result = false; for (let i = 0; i \u003c b.length; i++){ if (b[i] \u003e 10){ result = true; break; } } console.log(result); 我们还可以用some()方法， b.some(elem =\u003e elem \u003e 10); 如上所示，我们总是可以通过every()方法检测数组中所有元素都满足某种要求，而通过some()方法检测数组中是否有某个元素满足某种要求。 ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:2:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rfilter()我们已经知道数组a中并不是所有元素的长度都是大于 4 的，那么具体是哪些元素的长度大于 4 呢？有没有什么办法可以把它们都找到呢？ 老规矩，我们依旧可以用for循环。 let words = []; for (let i = 0; i \u003c a.length; i++){ if (a[i].length \u003e 4){ words.push(a[i]); } } console.log(words); 但我们还是推荐更加简短的filter()方法， a.filter(word =\u003e word.length \u003e 4); 结果如下： ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:3:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rmap()接下来，我们来做另外一件事，那就是给数组a中的每个元素后追加一个字符串“ is awesome!”，我们可以怎么做呢？——用map()方法。 a.map(word =\u003e word + \" is awesome!\"); ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:4:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rforEach()如果我们想将数组a中长度大于 4 的元素每每追加一个字符串“ is awesome!”并依次打印输出怎么做？ 首先我们可以用filter()方法进行筛选，然后用map()方法进行追加，最后用forEach()方法进行迭代打印输出。 a.filter(word =\u003e word.length \u003e 4).map(word =\u003e word + \" is awesome!\").forEach(word =\u003e console.log(word)); 现在你可能发现了map()和filter()方法返回一个数组的好处了吧！😋 ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:5:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rreduce()如果想将数组b进行求和运算该怎么做呢？——用reduce()方法。 reduce()方法的原型如下： array.reduce(reducer [, initialValue]) reducer为一个回调函数，以及可选初始化参数initialValue。reduce()方法会在每个数组元素上调用reducer()函数，reducer()函数返回一个累积的值，这个值在下一次调用reducer()函数时作为参数传入。 reducer()函数的原型如下： function reducer(accumulator, currentValue, currentIndex, array){} 回到给数组b进行求和的问题，代码如下： b.reduce((accu, curr) =\u003e accu + curr); ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:6:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rincludes()假如我们想知道数组中是否包含某个元素怎么整？比如，数组a包含Julia吗？ 当然，我们可以用之前学到过的some()方法， a.some(word =\u003e word === 'Julia'); 但还是推荐使用includes()方法： a.includes('Julia'); 无它，简明而已！ ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:7:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rfind()filter()可以帮我们找到数组b中所有大于 8 的元素，但有时候我们要的不是所有，而是第一个。此时我们可以用find()方法。 b.find(elem =\u003e elem \u003e 8); ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:8:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\rfindIndex()如果你对第一个元素（详见find()方法）不感兴趣，而是迫切想知道满足某条件的第一个元素的下标，那么可以用findIndex()方法。 b.findIndex(elem =\u003e elem \u003e 8); ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:9:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\r总结本文介绍了 9 个能让我们代码更加简洁的数组方法，分别是every()，some()，filter()，map()，forEach()，reduce()，includes()，find()和findIndex()，希望能让给你带来一点启发。 ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:10:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\r推荐最后，推荐几个网站！ JavaScript Tutorial: https://www.javascripttutorial.net/ MDN Web Docs: https://developer.mozilla.org/en-US/ 感兴趣的同学可以去瞅瞅 😍。 ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:11:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"\r参考https://www.w3schools.com/jsref/jsref_obj_array.asp ","date":"2023-02-27","objectID":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/:12:0","tags":["Array","JavaScript"],"title":"那些好用的JavaScript数组方法","uri":"/%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"categories":["JavaScript"],"content":"Axios是一个基于 Promise 的 HTTP 客户端，我们可以在浏览器和 Node.js 中使用它。Axios 使向 REST 端点发送异步 HTTP 请求和执行 CRUD 操作变得更加容易。它可以在纯 JavaScript 中使用，也可以在 Vue 或者 React 之类的库中使用。 先看一个在浏览器中使用 Axios 的例子，我们发送一个请求到https://api.github.com/users/USERNAME，以获取到用户的一些信息。 新建一个名为 1.html 的文件，代码如下： \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e\u003c/head\u003e \u003ctitle\u003eAxios\u003c/title\u003e \u003cbody\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"main.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e main.js 代码如下： axios.get(\"https://api.github.com/users/andyfree96\").then(response =\u003e { console.log(response.data); }).catch(error =\u003e { console.log(\"ERROR!\"); }); 启动服务器， 如果您没有安装http-server的话，请自行安装一下。 打开浏览器，就可以看到： 成功获取到用户信息。 之后的教程将在 Node.js 中使用 Axios，而不是在浏览器。 ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:0:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\r安装 Axios本文使用的 Node.js 版本是： 初始化一个 Node.js 应用， npm init -y 在命令行中输入npm i axios安装即可。 ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:1:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\rAxios 的响应对象当我们发送一个请求给服务器后，它会返回一个响应。Axios 的响应对象包含如下内容： data - 服务器返回的响应主体数据 status - 服务器返回的响应状态码 statusText - 返回的状态信息 headers - 返回的头部信息 config - 请求的配置信息 request - 请求对象 ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:2:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\rAxios 的 GET 请求我们以回调函数或者 async/await 的方式发送 Get 请求。 回调函数： const axios = require(\"axios\"); axios.get(\"https://api.github.com/users/andyfree96\").then((response) =\u003e { console.log(response.status); console.log(response.statusText); console.log(response.data); }); 结果如下： async/await： const axios = require(\"axios\"); async function makeGetRequest() { let response = await axios.get(\"https://httpbin.org/get\"); let data = response.data; console.log(data); console.log(response.request._header); } makeGetRequest(); 结果如下： ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:3:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\rAxios 的 HEAD 请求HEAD 请求是一个没有消息体的 GET 请求。 const axios = require(\"axios\"); async function makeHeadRequest() { let response = await axios.head(\"http://www.baidu.com\"); console.log(`status: ${response.status}`); console.log(`server : ${response.headers.server}`); console.log(response.headers); } makeHeadRequest(); Axios 有两个基本的 API： axios(config) axios(url, config) const axios = require(\"axios\"); async function makeRequest() { const config = { method: \"get\", }; const url = \"http://httpbin.org/get\"; let response = await axios(url, config); console.log(response.data); } makeRequest(); ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:4:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\rAxios 自定义头部 const axios = require(\"axios\"); async function makeRequest() { const config = { method: \"get\", url: \"http://www.baidu.com\", headers: { \"User-Agent\": \"5.js\" }, }; let response = await axios(config); console.log(response.request._header); } makeRequest(); 这里我们自定义了一个请求头部： const config = { method: \"get\", url: \"http://www.baidu.com\", headers: { \"User-Agent\": \"5.js\" }, }; ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:5:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\rAxios 的 POST 请求 const axios = require(\"axios\"); async function makePostRequest() { let response = await axios.post(\"https://httpbin.org/post\"); console.log(response.data); } makePostRequest(); ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:6:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\r下载图片 const axios = require(\"axios\"); const fs = require(\"fs\"); async function getImage(url) { const config = { responseType: \"stream\", }; let response = await axios.get(url, config); response.data.pipe(fs.createWriteStream(\"./image.png\")); } getImage( \"https://himg.bdimg.com/sys/portraitn/item/856f6c656f73636f74743936f939\" ); 我们在 config 对象中指明返回类型。 ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:7:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\r多个请求我们可以用 Axios 一次性创建多个请求。 const axios = require(\"axios\"); async function makeRequests() { let [response1, response2] = await Promise.all([ axios.get(\"https://api.github.com/users/andyfree96\"), axios.get(\"https://api.github.com/users/google\"), ]); console.log(response1.data.created_at); console.log(response2.data.created_at); } makeRequests(); ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:8:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\rJSON ServerJSON Server 是一个很棒的工具，可以让我们轻松地伪造 REST API。 我们先安装json-server: npm i -g json-server 创建一个名为 employees.json 的文件，添加如下内容： { \"employees\": [ { \"id\": 1, \"first_name\": \"Sebastian\", \"last_name\": \"Eschweiler\", \"email\": \"sebastian@codingthesmartway.com\" }, { \"id\": 2, \"first_name\": \"Steve\", \"last_name\": \"Palmer\", \"email\": \"steve@codingthesmartway.com\" }, { \"id\": 3, \"first_name\": \"Ann\", \"last_name\": \"Smith\", \"email\": \"ann@codingthesmartway.com\" } ] } 关于 JSON Server 创建 REST API 可以看下文。 Create A REST API With JSON Server: https://medium.com/codingthesmartway-com-blog/create-a-rest-api-with-json-server-36da8680136d 接下来我们可以启动 JSON Server， json-server --watch employees.json 访问http://localhost:3000/employees可以看到： 接下来我们可以使用 Axios 添加员工， const axios = require(\"axios\"); async function makePostRequest() { const params = { id: 4, first_name: \"Andy\", last_name: \"Scott\", email: \"andyfree96@126.com\", }; let response = await axios.post(\"http://localhost:3000/employees/\", params); console.log(response.data); } makePostRequest(); 获取员工, const axios = require(\"axios\"); async function makeRequest() { let response = await axios.get(\"http://localhost:3000/employees\"); console.log(response.data); } makeRequest(); 删除员工, const axios = require(\"axios\"); async function makeDeleteRequest() { let response = axios.delete(\"http://localhost:3000/employees/4/\"); console.log(response.data); } makeDeleteRequest(); ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:9:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["JavaScript"],"content":"\r参考Axios tutorial: http://zetcode.com/javascript/axios/ ","date":"2022-12-24","objectID":"/axios%E6%95%99%E7%A8%8B/:10:0","tags":["JavaScript","Axios"],"title":"Axios教程","uri":"/axios%E6%95%99%E7%A8%8B/"},{"categories":["命令行"],"content":"在现代操作系统中，图形用户界面 (GUI) 让我们与计算机的交互变得直观和简单。然而，对于许多开发者、系统管理员和技术爱好者而言，Linux 命令行仍然是最为强大且不可替代的工具。通过它，我们能够精准地控制系统资源、自动化复杂任务，并快速处理各种系统操作。与 GUI 不同，命令行的操作不依赖于鼠标或其他外部设备，只需键入一行命令，便可在数秒内完成从文件管理到网络配置、从进程控制到系统监控等一系列操作。正因为其高效、灵活和可扩展性，Linux 命令行成为了技术专家首选的工作方式之一。本文，我们将逐步探索 Linux 命令行的基础知识，了解一些常用的命令，以及如何利用这些命令高效管理系统。无论你是新手还是经验丰富的用户，掌握这些命令都会让你在 Linux 世界中如鱼得水。 ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:0:0","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\rcurlcurl是一个用于与远端服务器进行信息交换的命令行工具。通过curl命令，可以十分方便地上传或者下载数据。本文我们将介绍如何在 Ubuntu 18.04.4 LTS 上使用curl命令。 ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:1:0","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r安装在终端中输入： sudo apt update sudo apt install curl 即可安装。 ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:1:1","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r语法curl命令的语法如下： curl [options...] \u003curl\u003e \u003curl\u003e表示 URL 是必须的，而[options...]表示选项可以有多个或者零个。如果不带任何选项，对应 URL 的资源数据会在标准输出设备中输出。例如： curl http://www.baidu.com 如上所示，百度主页的源代码正常在屏幕上打印输出了。 ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:1:2","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r保存输出至文件通常我们需要将请求的数据保存到文件中，此时可以使用-O或者-o选项。 curl -O https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js -O选项会使用远端服务器上的文件名作为保存到本地文本的文本名。如不希望这样的话，可以-o选项自定义本地文件的文件名。 curl -o andy.js https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:1:3","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r下载多个文件有时，我们会需要多个文件，除了不断运行curl -O url1，curl -O url2……命令外，我们也可以使用如下方式： curl -O https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js -O https://cdn.jsdelivr.net/npm/async@3.2.0/dist/async.min.js ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:1:4","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r设置请求 User-Agent 字段HTTP 请求报文中有一个 User-Agent 头部字段，我们可以通过使用-A选项对其进行设置： curl -A \"andyfree\" ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:1:5","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r获取 HTTP 响应头通过-I选项，我们可以获取到 HTTP 响应报文的头部信息。 curl -I https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:1:6","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r使用代理为了能顺利访问到资源，有时我们需要用到代理，使用-x选项即可： curl -x 127.0.0.1:8100 http://httpbin.org/ip ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:1:7","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r恢复下载在下载大文件时，由于持续时间会比较长，网络可能会因为某些原因断开，此时我们可以用-C选项恢复下载而不用从头下载。 curl -C - -O https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/20.10/ubuntu-20.10-desktop-amd64.iso ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:1:8","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r推荐https://curl.se/docs/manual.html ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:1:9","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\rfind","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:2:0","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r语法 find [-H] [-L] [-P] [-Olevel] [-D debugopts] [path...] [expression] ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:2:1","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r列出当前目录使用不带参数和选项的find会列出当前目录下的所有文件及目录： find ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:2:2","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r搜索特定目录通过指定目录可以让find命令特定目录。 find ~/work ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:2:3","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r在指定目录中搜索特定文件有时，我们会想在某个指定目录下搜索特定文件名，例如： sudo find /etc -name \"ssh_config\" ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:2:4","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r模糊搜索如果想搜索系统中所有以.config为文件名结尾的文件的话，我们可以使用*通配符进行模糊搜索。 sudo find / -name \"*.config\" ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:2:5","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r指定搜索深度通过-maxdepth和-mindepth选项可以分别指定搜索时的最大和最小深度。 sudo find / -maxdepth 2 -name \"*.config\" ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:2:6","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r或操作符通过使用或操作符可以组合搜索结果，该操作符如下例中所示，用-o或-or选项表示。 sudo find / -maxdepth 2 -name \"*.config\" -o -name \"ssh\" ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:2:7","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r指定搜索类型通过-type选项，我们可以指定搜索文件类型，例如-type f搜索文件，-type d搜索目录： ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:2:8","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r指定搜索文件大小通过-size选项，我们可以指定搜索文件大小。比如，-size 10k表示搜索大小为10k的文件，-size +10k表示搜索大小超过10k的文件，-size -10k表示搜索大小少于10k的文件。 ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:2:9","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r推荐https://man7.org/linux/man-pages/man1/find.1.html ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:2:10","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r参考https://www.journaldev.com/25686/find-command-in-linux-unix ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:2:11","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\rpsps命令是进程状态（Process Status）的缩写，能显示 Linux 系统当前运行进程的相关信息。 ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:3:0","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r语法ps命令的语法如下： ps [options] ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:3:1","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r当前 shell 运行的进程不带任何选项的ps命令会显示当前 shell 运行的进程： ps PID指的是进程号 TTY指的是用户登录的终端类型 TIME指的是进程运行的时间 CMD指的是启动进程的命令 ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:3:2","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r列出所有进程使用-A或-e选项可以列出所有进程： ps -A ps -e ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:3:3","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r列出与特定用户相关的进程如果想列出与特定用户相关的进程，可以使用-u选项。 ps -u user 例如： ps -u ubuntu ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:3:4","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r显示所选列通过-o选项后指定的参数可以选择想要显示的列。 ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:3:5","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r搜索进程配合grep命令，我们可以十分方便的对进程进行搜索。 ps -ef | grep python ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:3:6","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r推荐https://man7.org/linux/man-pages/man1/ps.1.html ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:3:7","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r参考https://www.journaldev.com/24613/linux-ps-command https://www.geeksforgeeks.org/ps-command-in-linux-with-examples/ ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:3:8","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\rgrepgrep 是Global Regular Expression Print 的缩写，用于在指定文件中搜索字符串，它会打印匹配到的行。 ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:4:0","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r语法使用语法如下： grep [OPTION]... PATTERN [FILE]... PATTERN表示搜索模式。 ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:4:1","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r单个文件搜索 如果我们想在log1文件中搜索andy这个模式，可以使用如下命令： grep andy log1 ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:4:2","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r多个文件搜索若想在多个文件进行模式搜索，可以使用如下命令： grep andy log1 log2 ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:4:3","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r搜索整个目录work目录中只有两个文件，如果有成百上千个文件，显然不能上例一样指明目录下所有的文件名，此时我们可以使用*通配符来搜索整个当前目录： grep andy * ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:4:4","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r按单词搜索以上的例子没有把andy当作整个单词搜索，只要单词中匹配到andy这部分就会被搜索到。若想按单词搜索，使用-w选项即可。 grep -w andy * ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:4:5","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r忽略大小写使用-i选项可以让grep命令忽略大小写对模式进行搜索。 grep -iw andy * ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:4:6","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r反转搜索若想查看没有匹配到的行，我们可以使用-v选项： grep -iwv andy * ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:4:7","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r按行搜索通过-x选项可以让grep按行进行搜索： grep -xi andy * ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:4:8","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r搜索子目录目录中可能包含子目录，若想进一步在子目录进行搜索，可以使用-r选项： grep -rwi andy * ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:4:9","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r统计匹配数通过使用-c选项可以统计每个文件的匹配数。 grep -ci andy * ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:4:10","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r推荐https://man7.org/linux/man-pages/man1/grep.1.html ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:4:11","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r参考How To Use grep Command In Linux/UNIX: https://phoenixnap.com/kb/grep-command-linux-unix-examples ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:4:12","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\runame本节我们将介绍uname命令，该命令非常实用，可以打印输出系统相关信息。 ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:5:0","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r语法 uname [OPTION]... 可选选项如下： -s, (--kernel-name)：打印输出内核名称 -n, (--nodename)：打印输出主机名（在网络中使用），此时输出和hostname命令一样 -r, (--kernel-release)：打印输出内核版本 -v, (--kernel-version)：打印输出内核版本和构建时间 -m, (--machine)：打印输出机器硬件名称 -p, (--processor)：打印输出处理器架构 -i, (--hardware-platform)：打印输出硬件平台 -o, (--operating-system)：打印输出操作系统名称 -a, (--all)：和-snrvmpio打印输出信息一样 uname命令不带任何选项时，打印输出内核名称，和uname -s一样： 为了方便使用，我们可以通常使用-a选项： 其中： Linux为内核名称 andyfree-ubuntu为主机名 4.15.0-88-generic为内核版本 #88-Ubuntu SMP Tue Feb 11 20:11:34 UTC 2020为内核版本和构建时间 三个x86_64分别为硬件名称、处理器架构和硬件平台 GNU/Linux为操作系统名称 ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:5:1","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r更改主机名如上图所示，本文所使用的机器的主机名为andyfree-ubuntu，我们可以使用hostnamectl命令自行更改主机名，例如：将主机名改为lucas： sudo hostnamectl set-hostname lucas ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:5:2","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r参考https://linuxize.com/post/uname-command-in-linux/ ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:5:3","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["命令行"],"content":"\r推荐快乐的 Linux 命令行: https://billie66.github.io/TLCL/ the-art-of-command-line: Master the command line, in one page ","date":"2022-10-07","objectID":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/:6:0","tags":["Linux","命令行"],"title":"快乐的Linux命令行","uri":"/%E5%BF%AB%E4%B9%90%E7%9A%84linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"categories":["网络爬虫"],"content":"BeautifulSoup是啥？它是一个可以从 HTML 或 XML 文件中提取数据的 Python 库。它能通过我们喜欢的转换器实现文档导航，查找和修改。 ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:0:0","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r安装 BeautifulSoup可以通过pip来安装，包的名字的是beautifulsoup4。 pip install -i https://pypi.douban.com/simple beautifulsoup4 ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:1:0","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r安装解析器BeautifulSoup除了支持 Python 标准库中的 HTML 解析器之外，还支持一些第三方的解析器，比如lxml。可以按下列方式来安装 lxml： pip install -i https://pypi.douban.com/simple lxml 另一个可供选择的解析器是纯 Python 实现的html5lib，可以按下列方式来安装 html5lib： pip install -i https://pypi.douban.com/simple html5lib 下表列出了主要的解析器以及它们的优缺点： ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:2:0","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r如何使用将一段文档传入BeautifulSoup的构造方法就能得到一个文档对象，可以传入一段字符串或一个文件句柄。 from bs4 import BeautifulSoup soup = BeautifulSoup(open(\"index.html\")) suop = BeautifulSoup(\"\u003chtml\u003edata\u003c/html\u003e\") 如果手动指定解析器的话，BeautifulSoup会选择指定的解析器来解析文档。 ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:3:0","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r对象的种类BeautifulSoup将复杂的 HTML 文档转换成一个复杂的树形结构，每个节点都是 Python 对象，所有对象可以归纳为 4 中：Tag，NavigableString，BeautifulSoup，Comment。 ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:4:0","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\rTagTag对象与 XML 或 HTML 文档中的 tag 相同： from bs4 import BeautifulSoup soup = BeautifulSoup('\u003cb class=\"boldest\"\u003eExtremely bold\u003c/b\u003e') tag = soup.b type(tag) # \u003cclass 'bs4.element.Tag'\u003e Tag有很多方法和属性，比如遍历文档树和搜索文档树。现在介绍一下 tag 中最重要的属性：name和attributes。 Name每个 tag 都有自己的名字，通过.name来获取： tag.name # 'b' 如果改变 tag 的 name 将会影响所有通过当前BeautifulSoup对象生成的 HTML 文档： tag.name = \"blockquote\" tag # \u003cblockquote class=\"boldest\"\u003eExtremely bold\u003c/blockquote\u003e tag.name = \"ironman\" tag # \u003cironman class=\"boldest\"\u003eExtremely bold\u003c/ironman\u003e Attributes一个 tag 可能有很多个属性。tag \u003cb class=\"boldest\"\u003e有一个名为class的属性，值为boldest。tag 的属性的操作方法与字典相同： tag['class'] # ['boldest'] 也可以直接.取属性，比如：.attrs： tag.attrs # {'class': ['boldest']} tag 的属性可以被添加，删除或修改，和字典一样。 In [13]: tag['class'] Out[13]: ['boldest'] In [14]: tag['class'] = 'verybold' In [15]: tag['id'] = 1 In [16]: tag Out[16]: \u003cironman class=\"verybold\" id=\"1\"\u003eExtremely bold\u003c/ironman\u003e In [17]: del tag['class'] In [18]: del tag['id'] In [19]: tag Out[19]: \u003cironman\u003eExtremely bold\u003c/ironman\u003e In [20]: tag['class'] KeyError In [21]: tag.get('class') 多值属性HTML 定义了一系列可以包含多个值的属性。最常见的多值属性是class（一个 tag 可以有多个 CSS 的class）。在BeautifulSoup中多值属性的返回类型是 list： In [22]: css_soup = BeautifulSoup('\u003cp class=\"body strikeout\"\u003e\u003c/p\u003e') In [23]: css_soup.p['class'] Out[23]: ['body', 'strikeout'] 如果某个属性看起来好像有多个值，但在任何版本的 HTML 定义中都没有被定义为多值属性，那么BeautifulSoup会将这个属性作为字符串返回 In [25]: id_soup = BeautifulSoup('\u003cp id=\"my id\"\u003e\u003c/p\u003e') In [26]: id_soup.p['id'] Out[26]: 'my id' ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:4:1","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\rNavigableString字符串常被包含在 tag 内。BeautifulSoup用NavigableString类来包装 tag 中的字符串： In [27]: tag Out[27]: \u003cironman\u003eExtremely bold\u003c/ironman\u003e In [28]: tag.string Out[28]: 'Extremely bold' In [29]: type(tag.string) Out[29]: bs4.element.NavigableString NavigableString 对象支持遍历文档树和搜索文档树中定义的大部分属性, 并非全部。 ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:4:2","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\rBeautifulSoupBeautifulSoup对象表示的是整个文档的内容。大部分时候，可以把它当作Tag对象，它支持遍历文档树和搜索文档树中定义的大部分方法。 ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:4:3","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\rCommentTag，NavigableString，BeautifulSoup几乎覆盖了 html 和 xml 中的所有内容，但是还有一些特殊对象。 In [30]: markup = \"\u003cb\u003e\u003c!--Hey, buddy. Want to buy a used parser?--\u003e\u003c/b\u003e\" In [31]: soup = BeautifulSoup(markup, 'lxml') In [32]: comment = soup.b.string In [34]: type(comment) Out[34]: bs4.element.Comment Comment对象是一个特殊类型的NavigableString对象。 soup = BeautifulSoup(markup, 'lxml')中的lxml用于指定解析器。 ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:4:4","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r搜索文档树BeautifulSoup定义了很多搜索方法，这里着重介绍 2 个：find_all()和select()。 以“爱丽丝”文档作为例子： In [40]: html_doc = \"\"\" ...: \u003chtml\u003e\u003chead\u003e\u003ctitle\u003eThe Dormouse's story\u003c/title\u003e\u003c/head\u003e ...: ...: \u003cp class=\"title\"\u003e\u003cb\u003eThe Dormouse's story\u003c/b\u003e\u003c/p\u003e ...: ...: \u003cp class=\"story\"\u003eOnce upon a time there were three little sisters; and their names were ...: \u003ca href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"\u003eElsie\u003c/a\u003e, ...: \u003ca href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"\u003eLacie\u003c/a\u003e and ...: \u003ca href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"\u003eTillie\u003c/a\u003e; ...: and they lived at the bottom of a well.\u003c/p\u003e ...: ...: \u003cp class=\"story\"\u003e...\u003c/p\u003e ...: \"\"\" In [41]: from bs4 import BeautifulSoup In [42]: soup = BeautifulSoup(html_doc, 'lxml') 使用find_all()类似的方法可以查找到想要查找的文档内容。 ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:5:0","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r过滤器在介绍find_all()方法之前，先介绍一下过滤器的类型，这些过滤器贯穿整个搜索的 API。过滤器可以被用在 tag 的 name 中，节点的属性中，字符串中或它们的混合中。 字符串最简单的过滤器是字符串。在搜索方法中传入也给字符串参数，BeautifulSoup会查找与字符串完整匹配的内容，下面的例子用于查找文档中所有\u003cb\u003e标签： In [43]: soup.find_all('b') Out[43]: [\u003cb\u003eThe Dormouse's story\u003c/b\u003e] 正则表达式如果传入正则表达式作为参数，BeautifulSoup会通过正则表达式的match()来匹配内容。下例中找出所有以 b 开头的标签，这意味着\u003cbody\u003e和\u003cb\u003e标签都应该被找到： In [44]: import re In [45]: for tag in soup.find_all(re.compile('^b')): ...: print(tag.name) ...: # body # b 列表如果传入列表参数BeautifulSoup会将领与列表中任一元素匹配的内容返回。下列代码将会找到文档中所有\u003ca\u003e和\u003cb\u003e标签： In [46]: soup.find_all(['a','b']) Out[46]: [\u003cb\u003eThe Dormouse's story\u003c/b\u003e, \u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] TrueTrue可以匹配任何值，以下代码查找到所有的 tag，但不会返回字符串节点： In [47]: for tag in soup.find_all(True): ...: print(tag.name) ...: # html # head # title # body # p # b # p # a # a # a p 方法如果没有合适的过滤器，还可以定义一个方法，方法只接受一个元素参数，如果这个方法返回True表示当前元素匹配并且被找到，若不是则返回False。 下列方法检验了当前元素，如果包含class属性却不包含id属性则返回True： def has_class_but_no_id(tag): return tag.has_attr('class') and not tag.has_attr('id') 将该方法作为参数传入find_all()方法将得到所有\u003cp\u003e标签： In [66]: soup.find_all(has_class_but_no_id) Out[66]: [\u003cp class=\"title\"\u003e\u003cb\u003eThe Dormouse's story\u003c/b\u003e\u003c/p\u003e, \u003cp class=\"story\"\u003eOnce upon a time there were three little sisters; and their names were \u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e and \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e; and they lived at the bottom of a well.\u003c/p\u003e, \u003cp class=\"story\"\u003e...\u003c/p\u003e] 返回结果中只有\u003cp\u003e标签没有\u003ca\u003e标签，因为\u003ca\u003e标签还定义了id，没有返回\u003chtml\u003e和\u003chead\u003e，因为\u003chtml\u003e和\u003chead\u003e中没有定义class属性。 下面代码找到所有被文字包含的节点内容： In [68]: from bs4 import NavigableString def surrounded_by_strings(tag): return isinstance(tag.next_element, NavigableString) and isinstance(tag.previous_element, NavigableString) In [70]: for tag in soup.find_all(surrounded_by_strings): ...: print(tag.name) ...: # p # a # a # a # p ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:5:1","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\rfind_all() find_all(name, attrs, recursive, text, **kwargs) find_all()方法搜索当前 tag 的所有 tag 子节点，并判断是否符合过滤器的条件。 name 参数name参数可以查找所有名字为name的 tag，字符串对象会被自动忽略掉。 例如： In [72]: soup.find_all(\"title\") Out[72]: [\u003ctitle\u003eThe Dormouse's story\u003c/title\u003e] name参数的值可以是任一类型的过滤器，字符串、正则表达式、列表、方法或是True。 keyword 参数如果一个指定名字的参数不是搜索内置的参数名，搜索时会把该参数当作指定名字 tag 的属性来搜索。如果包含一个名字为id参数，BeautifulSoup会搜索每个 tag 的id属性。 In [73]: soup.find_all(id=\"link2\") Out[73]: [\u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e] 如果传入href参数，BeautifulSoup会搜索每个 tag 的href属性： In [76]: soup.find_all(href=re.compile('elsie')) Out[76]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e] 搜索指定名字的属性时可以使用的参数值包括：字符串、正则表达式、列表、True。 下例在文档中查找所有包含id属性的 tag，无论id的值是什么： In [77]: soup.find_all(id=True) Out[77]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] 使用多个指定名字的参数可以同时过滤 tag 的多个属性： In [78]: soup.find_all(href=re.compile(\"elsie\"), id='link1') Out[78]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e] 有些 tag 属性在搜索时不能使用，比如 HTML5 中的data-*属性： In [79]: data_soup = BeautifulSoup('\u003cdiv data-foo=\"value\"\u003efoo!\u003c/div\u003e', 'lxml') In [80]: data_soup.find_all(data-foo=\"value\") File \"\u003cipython-input-80-a766c8a0cac6\u003e\", line 1 data_soup.find_all(data-foo=\"value\") ^ SyntaxError: keyword can't be an expression 可以通过find_all()方法attrs参数定义一个字典参数来搜索包含特殊属性的 tag： In [81]: data_soup.find_all(attrs={'data-foo':'value'}) Out[81]: [\u003cdiv data-foo=\"value\"\u003efoo!\u003c/div\u003e] 按 CSS 搜索可以通过class_参数搜索指定 CSS 类名的 tag： In [82]: soup.find_all('a', class_=\"sister\") Out[82]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] class_参数同样接受不同类型的过滤器，字符串，正则表达式，方法或True。 text 参数通过text参数可以搜索文档中的字符串内容。与name参数的可选值一样，text参数接受字符串，正则表达式，列表，True，方法。 In [83]: soup.find_all(text='Elsie') Out[83]: ['Elsie'] In [84]: soup.find_all(text=['Tillie','Elsie','Lacie']) Out[84]: ['Elsie', 'Lacie', 'Tillie'] In [85]: soup.find_all(text=re.compile('Dormouse')) Out[85]: [\"The Dormouse's story\", \"The Dormouse's story\"] def is_the_only_string_within_a_tag(s): \"\"\"Return True if this string is the only child of its parent tag.\"\"\" return (s == s.parent.string) In [87]: soup.find_all(text=is_the_only_string_within_a_tag) Out[87]: [\"The Dormouse's story\", \"The Dormouse's story\", 'Elsie', 'Lacie', 'Tillie', '...'] 虽然text参数用于搜索字符串，还可以与其它参数混合使用来过滤 tag。BeautifulSoup会找到.string属性与text参数值相符的 tag。以下代码用来搜索内容中包含Elsie的\u003ca\u003e标签： In [88]: soup.find_all('a', text=\"Elsie\") Out[88]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e] limit 参数find_all()方法返回全部的搜索结构，如果文档树很大那么搜索会很慢。如果我们不需要全部结果，可以使用limit参数限制返回结果的数量。当搜索结果的数量达到limit的限制时，就停止搜索返回结果。 In [89]: soup.find_all('a') Out[89]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] In [90]: soup.find_all('a',limit=2) Out[90]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e] recursive 参数调用 tag 的find_all()方法时，BeautifulSoup会检索当前 tag 的所有子孙节点，如果只想搜索 tag 的直接子节点，可以使用参数recursive=False。 有如下文档： \u003chtml\u003e \u003chead\u003e \u003ctitle\u003e The Dormouse's story \u003c/title\u003e \u003c/head\u003e ... 是否使用recursive参数的结果： In [95]: soup.html.find_all('title') Out[95]: [\u003ctitle\u003e The Dormouse's story \u003c/title\u003e] In [96]: soup.html.find_all('title', recursive=False) Out[96]: [] ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:5:2","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r像调用 find_all()一样调用 tagfind_all()几乎是BeautifulSoup中最常见的搜索方法，所以定义了它的简写方法。BeautifulSoup对象和Tag对象可以被当作一个方法来使用，这个方法的执行结果与调用这个对象的find_all()方法相同。 下面两行代码是等价的： soup.find_all(\"a\") soup(\"a\") 以下两行代码也是等价的： soup.title.find_all(text=True) soup.title(text=True) ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:5:3","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\rCSS 选择器BeautifulSoup支持大部分的 CSS 选择器，在Tag或BeautifulSoup对象的select()方法中传入字符串参数即可使用 CSS 选择器的语法找到 tag： In [1]: from bs4 import BeautifulSoup In [2]: html_doc = \"\"\" ...: \u003chtml\u003e\u003chead\u003e\u003ctitle\u003eThe Dormouse's story\u003c/title\u003e\u003c/head\u003e ...: \u003cbody\u003e ...: \u003cp class=\"title\"\u003e\u003cb\u003eThe Dormouse's story\u003c/b\u003e\u003c/p\u003e ...: ...: \u003cp class=\"story\"\u003eOnce upon a time there were three little sisters; and their names were ...: \u003ca href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"\u003eElsie\u003c/a\u003e, ...: \u003ca href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"\u003eLacie\u003c/a\u003e and ...: \u003ca href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"\u003eTillie\u003c/a\u003e; ...: and they lived at the bottom of a well.\u003c/p\u003e ...: ...: \u003cp class=\"story\"\u003e...\u003c/p\u003e ...: \"\"\" In [3]: soup = BeautifulSoup(html_doc, 'lxml') In [4]: soup.select('title') Out[4]: [\u003ctitle\u003eThe Dormouse's story\u003c/title\u003e] In [5]: soup.select('p:nth-of-type(3)') Out[5]: [\u003cp class=\"story\"\u003e...\u003c/p\u003e] 通过 tag 标签逐层查找： In [6]: soup.select('body a') Out[6]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] In [7]: soup.select('html head title') Out[7]: [\u003ctitle\u003eThe Dormouse's story\u003c/title\u003e] 找到某个 tag 标签下的直接子标签： In [8]: soup.select('head \u003e title') Out[8]: [\u003ctitle\u003eThe Dormouse's story\u003c/title\u003e] In [9]: soup.select('p \u003e a') Out[9]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] 找到兄弟节点标签： In [14]: soup.select('#link1 ~ .sister') Out[14]: [\u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] In [15]: soup.select('#link1 + .sister') Out[15]: [\u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e] 通过 CSS 的类名查找： In [16]: soup.select('.sister') Out[16]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] In [17]: soup.select('[class~=sister]') Out[17]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] 通过 tag 的 id 查找： In [18]: soup.select('#link1') Out[18]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e] In [19]: soup.select('a#link2') Out[19]: [\u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e] 通过是否存在某个属性来查找： In [20]: soup.select('a[href]') Out[20]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] 通过属性的值来查找： In [21]: soup.select('a[href=\"http://example.com/elsie\"]') Out[21]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e] In [22]: soup.select('a[href^=\"http://example.com/\"]') Out[22]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] In [23]: soup.select('a[href$=\"tillie\"]') Out[23]: [\u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] In [24]: soup.select('a[href*=\".com/el\"]') Out[24]: [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e] 更多有关 CSS 选择器的内容，请参考CSS 选择器参考手册。 ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:5:4","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r爬取豆瓣电影 TOP250 海报接下来，通过爬取豆瓣电影 TOP250 海报实践一下。访问豆瓣电影 Top 250 可以看到每部电影左侧都配有一张海报，我们的目的就是下载这些海报到本地。 多看几页，就会发现每个页面的 URL 和页号是有关系的。 URL 中start这个参数的值等于(页号 - 1) * 25。接下来，再审查一下元素 可以发现海报的地址包含在class值为pic的div元素下，我们可以用BeautifulSoup的select()方法获取到img元素，再提取src属性。代码如下所示： from urllib.request import urlopen from bs4 import BeautifulSoup from fake_useragent import UserAgent from urllib.request import Request import os BASE_URL = \"https://movie.douban.com/top250?start={page_id}\u0026filter=\" user_agent = UserAgent() def get_content(url): \"\"\" 根据url发送请求 :param url: 请求url :return: 响应内容 \"\"\" headers = { 'User-Agent': user_agent.random } request = Request(url, headers=headers) response = urlopen(request) return response.read() def parse_html(html): \"\"\" 解析HTML :param html: HTML文档字符串 :return: \"\"\" soup = BeautifulSoup(html, 'lxml') items = soup.select(\".pic img\") for item in items: yield item.get(\"src\") def save_image(image_url, file_name, folder='images'): \"\"\" 保存图片 :param image_url: 图片地址 :param file_name: 文件名 :param folder: 保存目录 \"\"\" image = get_content(image_url) if not os.path.exists(folder): os.mkdir(folder) file_name = \"{}/{}.jpg\".format(folder, file_name) with open(file_name, 'wb') as f_obj: f_obj.write(image) print(\"保存:\", file_name) def main(): total = 0 for i in range(20): url = BASE_URL.format(page_id=i * 25) html = get_content(url).decode('utf-8') for image in parse_html(html): print(\"下载:\", image) save_image(image, total) total += 1 if __name__ == '__main__': main() 运行结果如下： 最后，可以将所有的海报拼接起来： import math import PIL.Image as Image def merge_images(folder, size=1000): \"\"\" 将folder目录下的图片按尺寸size拼接 :param folder: 图片 :param size: 尺寸 \"\"\" images_count = len(os.listdir(folder)) each_size = int(math.sqrt(size * size / images_count)) - 1 lines_count = int(size / each_size) final_image = Image.new('RGB', (size, size), 'white') row, column = 0, 0 for i in range(images_count): image_path = \"{}/{}.jpg\".format(folder, i) try: image = Image.open(image_path) except IOError as e: print(image_path, \"出错啦！！！\") else: image = image.resize((each_size, each_size)) final_image.paste(image, (row * each_size, column * each_size)) column += 1 if column == lines_count: column = 0 row += 1 final_image.save(\"{}/{}.jpg\".format(folder, \"final_image\"))) 得到： ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:6:0","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r总结本文我们介绍了BeautifulSoup库的一些内容，它可以将 HTML/XML 文档进行解析，得到一个文档树 树中的每个节点都是BeautifulSoup四种对象中的一种。可以用find_all()或select()找到我们需要查找的节点。之后，可以通过节点的属性或者方法获取到我们需要的信息。 ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:7:0","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r参考 https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/ ","date":"2021-11-08","objectID":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/:8:0","tags":["Python","BeautifulSoup","解析器"],"title":"BeautifulSoup库使用","uri":"/beautifulsoup%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"我们可以使用 Python 内置的 urllib 包来请求网络资源。它用起来比较麻烦，而且缺少很多实用的高级功能。本文我们将会介绍一个更加方便的 Python 第三方库——Requests 的使用。 ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:0:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r安装 Requests要安装Requests，只要在终端中运行这个简单命令即可： pip install -i https://pypi.douban.com/simple requests 安装好Requests后，就可以开始尝试使用它啦！ ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:1:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r发送请求使用Requests发送网络请求非常简单。导入Requests模块： import requests 然后获取某个网页。我们来获取 Github 的公共时间线： r = requests.get('https://api.github.com/events') 现在，有了一个名为r的Response的对象。我们可以从这个对象中获取所有我们想要的信息。 ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:2:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r传递 URL 参数我们可能会想用 URL 的查询字符串传递某种数据。如果是手动构建 URL，那么数据会以键值对的形式置于 URL 中，跟在一个问号的后面。例如，http://httpbin.org/get?key=val。Requests允许我们使用params关键字参数，以一个字符串字典来提供这些参数。举例来说，如果想传递key1=value1和key2=value2到http://httpbin.org/get，那么可以使用如下代码： import requests payload = {'name':'viljw', 'cat':'ruby'} r = requests.get('http://httpbin.org/get', params=payload) 打印输出该 URL，能看到 URL 已被正确编码： print(r.url) # http://httpbin.org/get?name=viljw\u0026cat=ruby ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:3:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r响应内容我们能读取服务器响应内容。举个例子： import requests r = requests.get(\"http://httpbin.org/get\") print(r.text) 输出内容如下： Requests会自动节码来自服务器的内容。大多数 unicode 字符集都能被无缝地解码。 请求发出后，Requests会基于 HTTP 头部对响应的编码作出有根据的推测。当访问r.text时，Requests会使用其推测的文本编码。我们可以找出Requests使用了什么编码，并且能够使用r.encoding属性来改变它： import requests r = requests.get(\"http://httpbin.org/get\") print(r.encoding) r.encoding = 'utf-8' print(r.encoding) 如果改变了编码，每当访问r.text，Requests都将会使用r.encoding的新值。 ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:4:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r二进制响应内容对于非文本请求，也能以字节的方式访问请求响应体。例如，以请求返回的二进制数据创建一张图片，可以使用如下代码： import requests from PIL import Image from io import BytesIO r = requests.get(\"https://github.com/fluidicon.png\") im = Image.open(BytesIO(r.content)) im.show() ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:5:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\rJSON 响应内容Requests中有一个内置的 JSON 解码器，帮助我们处理 JSON 数据： import requests from pprint import pprint payload = {'name':\"viljw\", 'cat':'ruby'} r = requests.get(\"http://httpbin.org/get\", params=payload) pprint(r.json()) ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:6:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r定制请求头如果想为请求添加 HTTP 头部，只要简单地传递一个dict给headers参数就可。 import requests from pprint import pprint headers = {'User-Agent': 'viljw-agent'} r = requests.get(\"http://httpbin.org/get\", headers=headers) pprint(r.json()) 如下图所示，User-Agent字段的值已被更改为viljw-agent。 ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:7:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\rPOST 请求通常，我们会想要发送一些编码为表单形式的数据——非常像一个 HTML 表单。要实现这个，只需要简单地传递一个字典给data参数。字典数据在发出请求时会自动编码为表单形式： import requests payload = {\"name\":\"viljw\", \"actor\":\"peter\"} r = requests.post(\"http://httpbin.org/post\", data=payload) print(r.text) 还可以给data参数传入一个元组列表。在表单中多个元素使用同一 key 的时候，这种方式很有用： import requests payload = [(\"name\",\"viljw\"), (\"actor\",\"peter\"),(\"actor\",'marry')] r = requests.post(\"http://httpbin.org/post\", data=payload) print(r.text) ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:8:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r响应状态码我们可以查看响应状态码： import requests r = requests.get(\"http://httpbin.org/get\") print(r.status_code) # 200 为了方便使用，Requests附带了也给内置的状态码查询对象： r.status_code == requests.codes.ok # True 如果发送了一个错误请求(一个 4XX 客户端错误，或 5XX 服务器错误响应)，我们可以通过Response.raise_for_status()来抛出异常： In [1]: import requests In [2]: bad_r = requests.get('http://httpbin.org/status/404') In [3]: bad_r.status_code Out[3]: 404 In [4]: bad_r.raise_for_status() --------------------------------------------------------------------------- HTTPError Traceback (most recent call last) \u003cipython-input-4-cdf6910f7d4c\u003e in \u003cmodule\u003e() ----\u003e 1 bad_r.raise_for_status() c:\\python\\lib\\site-packages\\requests\\models.py in raise_for_status(self) 927 928 if http_error_msg: --\u003e 929 raise HTTPError(http_error_msg, response=self) 930 931 def close(self): HTTPError: 404 Client Error: NOT FOUND for url: http://httpbin.org/status/404 但由于我们的例子中r的status_code是 200，当我们调用raise_for_status()时，得到的是： In [6]: r.raise_for_status() # None ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:9:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r响应头我们可以查看以字典形式的服务器响应头： In [7]: r.headers Out[7]: {'Access-Control-Allow-Credentials': 'true', 'Access-Control-Allow-Origin': '*', 'Content-Encoding': 'gzip', 'Content-Type': 'application/json', 'Date': 'Thu, 03 Oct 2019 07:11:16 GMT', 'Referrer-Policy': 'no-referrer-when-downgrade', 'Server': 'nginx', 'X-Content-Type-Options': 'nosniff', 'X-Frame-Options': 'DENY', 'X-XSS-Protection': '1; mode=block', 'Content-Length': '184', 'Connection': 'keep-alive'} ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:10:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\rCookie如果某个响应中包含一些 cookie，可以快速访问它们： In [19]: r = requests.get('https://www.baidu.com') In [20]: r.cookies Out[20]: \u003cRequestsCookieJar[Cookie(version=0, name='BDORZ', value='27315', port=None, port_specified=False, domain='.baidu.com', domain_specified=True, domain_initial_dot=True, path='/', path_specified=True, secure=False, expires=1570173564, discard=False, comment=None, comment_url=None, rest={}, rfc2109=False)]\u003e In [21]: r.cookies['BDORZ'] Out[21]: '27315' 要想发送 cookies 到服务器，可以使用cookies参数： In [27]: url = 'http://httpbin.org/cookies' In [28]: cookies = dict(cookies_are=\"working\") In [29]: r = requests.get(url, cookies=cookies) In [30]: r.json() Out[30]: {'cookies': {'cookies_are': 'working'}} ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:11:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r超时可以告诉Requests在经过以timeout参数设定的秒数时间之后停止等待响应。 \u003e\u003e\u003e requests.get('http://github.com', timeout=0.001) Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e requests.exceptions.Timeout: HTTPConnectionPool(host='github.com', port=80): Request timed out. (timeout=0.001) ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:12:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r错误与异常遇到网络问题(如：DNS 查询失败、拒绝连接等)时，Requests会抛出一个ConnectionError异常。 如果 HTTP 请求返回了不成功的状态码， Response.raise_for_status()会抛出一个HTTPError异常。 若请求超时，则抛出一个Timeout异常。 若请求超过了设定的最大重定向次数，则会抛出一个TooManyRedirects异常。 所有Requests显式抛出的异常都继承自 requests.exceptions.RequestException 。 ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:13:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r代理如果需要使用代理，可以通过任意请求方法提供proxies参数来配置单个请求： import requests proxies = { 'https': 'https://127.0.0.1:1080' } r = requests.get('https://www.google.com', proxies=proxies) print(r.status_code) # 200 也可以通过环境变量HTTP_PROXY和HTTPS_PROXY来配置代理。 $ export HTTP_PROXY=\"http://10.10.1.10:3128\" $ export HTTPS_PROXY=\"http://10.10.1.10:1080\" $ python \u003e\u003e\u003e import requests \u003e\u003e\u003e requests.get(\"http://example.org\") ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:14:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["网络爬虫"],"content":"\r参考 https://requests-docs-cn.readthedocs.io/zh_CN/latest/index.html ","date":"2021-10-08","objectID":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/:15:0","tags":["Python","Requests","HTTP"],"title":"Requests库使用","uri":"/requests%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"categories":["搜索"],"content":"搜索引擎是我们日常学习工作最常使用的服务之一。你可能每天都在用它，但是却仍旧不知道“搜索”。高效地使用搜索引擎可以事半功倍，下面就盘点一下那些年我们可能错过的实用 Google 搜索技巧吧！ ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:0:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r使用加号(或空格)表示与不需要使用“+”来表示逻辑与，只要空格就可以了。什么意思呢？简单地说就是，当我们在搜索框输入A B搜索时，就是告诉 Google，我们要搜索的内容与 A 并且和 B 有关。比如说，我们想要搜索与 java 和 python 有关的内容，就可以用java python进行搜索。 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:1:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r使用双引号搜索短语如果想要搜索一些短语，比如我们想要搜索与purpose of education有关的内容，而在搜索框输入purpose of education进行搜索，这显然不是很对。因为我们知道 Google 会把它理解成三个关键字的逻辑与，而不是把三个关键字整体当成一个短语。这个时候，就有必要使用双引号，告诉 Google 需要把双引号中的内容看成一个短语。 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:2:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r使用星号星号*是常用的通配符，也可以在搜索中使用，代表任意文字。具体来说，假如有一天，突然想起了朋友们之前在谈论金庸先生的一部叫什么八部的小说，小说的名字却怎么都想不起来，只依稀记得八部两个字，这个时候我们就可以使用星号*表示所有可能的文字进行搜索。 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:3:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r使用减号我们可能想要过滤掉一些不太感兴趣的信息，这个时候就可以使用-。 我们对盗梦空间这部电影不太感兴趣，于是可以使用减号（-），将其从搜索结果中排除。 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:4:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r使用波浪号把波浪号~加在某个词前面，告诉 Google：要搜索与波浪号~后面的那个词相关的近义词。比如，我们要搜索关于大学（college）测验分数（test scores）但不是 SAT 入学分数的相关内容。 college 的近义词，比如 higher education, university 也会一起搜索出来。 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:5:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r列出相似网页有一天你发现了一个非常喜欢的网站，比如 Coursera，于是乎你想知道还有没有类似的网站。我们可以使用操作符related:来解决这件事。 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:6:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r搜索数字范围可以使用..表示数字范围。具体来说， ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:7:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r使用OR表示或用OR表示逻辑或。比如，搜索詹姆斯或科比，或者二者都有的网页。 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:8:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r其他指令 操作符 用途 用法 allinanchor: 限制搜索的词是网页中链接中包含的关键字（可使用多个关键词） allinanchor:keyword1 keyword2 allintext: 限制搜索的词是网页内文包含的关键词（可使用多个关键词） allintext:keyword1 keyword2 allintitle: 限制搜索的词是网页标题中包含的关键词（可使用多个关键词） allintitle:keyword1 keyword2 allinurl: 限制搜索的词是网页网址中包含的关键词（可使用多个关键词） allinurl:keyword1 keyword2 filetype: 限制所搜索的文件一个特定的格式 filetype:extension inanchor: 限制搜索的词是网页中链接中包含的关键词 inanchor:keyword intext: 限制搜索的词是网页内文中包含的关键词 intext:keyword intitle: 限制搜索的词是网页标题中包含的关键词 intitle:keyword inurl: 限制搜索的词是网页网址中包含的关键词 inurl:keyword site: 限制所进行的搜索在指定的域名或网站中 site:domain 举个例子，假如我们要搜索在伯乐在线上的有关 Java 的文章，就可以使用site:操作符，如下所示： ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:9:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r番外篇Google 还包含了许多其他实用有趣的功能。比如： ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:10:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r查看天气 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:10:1","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r股票报价 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:10:2","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r单词含义 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:10:3","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r计算器 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:10:4","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r画函数图像 ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:10:5","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r页面旋转 更多有趣的内容，可查看阅读下列文章。 15 fun things to type into Google 20 Really Cool Google Features You Probably Don’t Know About 8 Hidden (And Useful) Features in Google Search ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:10:6","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["搜索"],"content":"\r参考 Ten Tips for Smarter Google Searches 15 fun things to type into Google ","date":"2020-04-27","objectID":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/:11:0","tags":["搜索","Google"],"title":"Google搜索那些事儿","uri":"/google%E6%90%9C%E7%B4%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"categories":["Tkinter"],"content":"本文我们将学习如何使用Tkinter包编写一些图形用户界面程序。Tkinter是 Python 的一个标准包，因此我们并不需要安装它。我们将从创建一个窗口开始，然后我们在其之上加入一些小组件，比如按钮，复选框等，并使用它们的一些属性。话不多说，让我们开始吧！ ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r创建一个窗口首先，我们导入Tkinter包，然后创建一个窗口，最后给这个窗口设置标题。 from tkinter import * window = Tk() window.title(\"First Window\") window.mainloop() 结果如下： 最后一行我们调用了mainloop函数，这个函数将让窗口等待用户与之交互，直到我们关闭它。如果忘记调用mainloop函数的话，将不会向用户显示任何内容（没有窗口）。 ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:1:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r添加一个标签组件为了给之前的例子增加一个标签组件，我们可以使用Label类： lbl = Label(window, text=\"Hello\") 我们可以通过grid函数设置其在窗口的位置： lbl.grid(column=0, row=0) 完整代码如下所示： from tkinter import * window = Tk() window.title(\"First Window\") lbl = Label(window, text=\"Hello\") lbl.grid(column=0, row=0) window.mainloop() 结果如下： 值得注意的是lbl没有调用grid函数的话是不会显示的。 ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:2:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r设置标签字体大小我们可以使用font参数设置标签字体大小： lbl = Label(window, text=\"Hello\", font=(\"Arial Bold\", 50)) font参数不光可以在标签组件中用，其他组件也可以使用呢！ 可是，现在窗口貌似太小了，连窗口的标题都看不全，如何设置窗口大小呢？ ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:2:1","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r设置窗口大小我们可以用geometry函数来设置窗口大小： window.geometry(\"350x200\") 以上代码将会把窗口设置成 350 个像素宽，200 个像素高。 ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:2:2","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r添加一个按钮组件让我们给窗口增加一个按钮组件，它的创建和添加方式和标签组件差不多： btn = Button(window, text=\"Click Me\") btn.grid(column=1, row=0) 完整代码如下所示： from tkinter import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") lbl = Label(window, text=\"Hello\") lbl.grid(column=0, row=0) btn = Button(window, text=\"Click Me\") btn.grid(column=1, row=0) window.mainloop() 结果如下： ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:3:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r更改按钮前景和背景颜色我们可以用fg参数设置按钮或其他组件的前景色。 我们可以用bg参数设置按钮或其他组件的背景色。 btn = Button(window, text=\"Click Me\", bg=\"orange\", fg=\"red\") 现在，如果点击按钮，什么都不会发生，因为我们没有写处理点击事件的代码。 ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:3:1","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r处理按钮点击事件首先，我们编写一个当按钮点击后需要执行的函数： def clicked(): lbl.configure(text=\"Button was clicked!\") 然后，我们注明一下点击时要调用的函数： btn = Button(window, text=\"Click Me\", command=clicked) 完整代码如下所示： from tkinter import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") lbl = Label(window, text=\"Hello\") lbl.grid(column=0, row=0) def clicked(): lbl.configure(text=\"Button was clicked!\") btn = Button(window, text=\"Click Me\", command=clicked) btn.grid(column=1, row=0) window.mainloop() 当我们点击按钮后，结果如下： ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:3:2","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r添加一个文本框在之前的例子中我们了解了如何添加一些简单组件，现在我们将通过Tkinter的Entry类获取到用户输入。我们可以这样用Entry类创建一个文本框： txt = Entry(window, width=10) 然后可以用grid函数像之前那样添加到窗口中。 from tkinter import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") lbl = Label(window, text=\"Hello\") lbl.grid(column=0, row=0) txt = Entry(window, width=10) txt.grid(column=1, row=0) def clicked(): lbl.configure(text=\"Button was clicked!\") btn = Button(window, text=\"Click Me\", command=clicked) btn.grid(column=2, row=0) window.mainloop() 此时点击按钮，标签组件内的内容没有变化，如何将文本框中输入的信息在标签组件中显示呢？ 我们可以用get函数获取到文本框中输入的信息，然后如下更改clicked函数来设置窗口大小： def clicked(): res = \"Welcome to \" + txt.get() lbl.configure(text=res) 如果我们在文本框中输入信息并点击按钮组件，标签组件将会显示Welcome to 文本框输入信息 。 以下是完整代码： from tkinter import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") lbl = Label(window, text=\"Hello\") lbl.grid(column=0, row=0) txt = Entry(window, width=10) txt.grid(column=1, row=0) def clicked(): res = \"Welcome to \" + txt.get() lbl.configure(text=res) btn = Button(window, text=\"Click Me\", command=clicked) btn.grid(column=2, row=0) window.mainloop() 运行结果为： 但每次我们运行代码后，我们都需要通过点击文本框来设置输入焦点才能输入信息，有什么办法可以自动设置输入焦点吗？ ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:4:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r设置输入焦点很简单，我们只需要调用focus函数来设置窗口大小： txt.focus() 当我们运行代码后，会发现可以直接在文本框中输入信息而不需要点击文本框。 ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:4:1","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r添加一个组合框为了添加一个组合框，可以使用Combobox类： from tkinter.ttk import * combo = Combobox(window) 然后可以给组合框添加一些值。 from tkinter import * from tkinter.ttk import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") combo = Combobox(window) combo['values'] = (1,2,3,4,5,\"Text\") combo.current(1) combo.grid(column=0, row=0) window.mainloop() 如上所示，我们可以用元组设置组合框选项。 我们可以通过传递期望被选中选项的索引给current函数用以设置被选中的选项。 我们可以通过get函数获取到被选中的选项。 combo.get() ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:5:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r添加复选框我们可以用Checkbutton类来创建一个复选框组件： chk = Checkbutton(window, text=\"Choose\") 能通过传递值设置复选框的状态： from tkinter import * from tkinter.ttk import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") chk_state = BooleanVar() chk_state.set(True) # Set check state chk = Checkbutton(window, text=\"Choose\", var=chk_state) chk.grid(column=0, row=0) window.mainloop() 上例我们用的是BooleanVar变量用来设置复选框的状态，也可以使用IntVar变量进行设置。 chk_state = IntVar() chk_state.set(1) # Check chk_state.set(0) # Uncheck 结果和用BooleanVar一样。 ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:6:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r添加单选框添加单选框可以用Radiobutton类创建一个文本框： rad1 = Radiobutton(window, text=\"First\", value=1) 我们需要给每个单选框设置不同的值，否则会不起作用。 from tkinter import * from tkinter.ttk import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") rad1 = Radiobutton(window, text=\"First\", value=1) rad2 = Radiobutton(window, text=\"Second\", value=2) rad3 = Radiobutton(window, text=\"Third\", value=3) rad1.grid(column=0, row=0) rad2.grid(column=1, row=0) rad3.grid(column=2, row=0) window.mainloop() 当然，我们可以给这些单选框设置command参数指定一个函数，当用户点击它们时就会运行该函数。 rad1 = Radiobutton(window, text=\"First\", value=1, command=clicked) def clicked(): # Do what you need pass ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:7:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r获取单选框值为获取到选中单选框的值，我们可以将IntVar变量传给单选框的variable参数，之后用IntVar变量的get函数就可以获取到其值啦！ from tkinter import * from tkinter.ttk import * window = Tk() window.title(\"First Window\") selected = IntVar() lbl = Label(window, text=\"Show Value\") rad1 = Radiobutton(window, text=\"First\", value=1, variable=selected) rad2 = Radiobutton(window, text=\"Second\", value=2, variable=selected) rad3 = Radiobutton(window, text=\"Third\", value=3, variable=selected) def clicked(): lbl.configure(text=selected.get()) btn = Button(window, text=\"Click Me\", command=clicked) rad1.grid(column=0, row=0) rad2.grid(column=1, row=0) rad3.grid(column=2, row=0) btn.grid(column=4, row=0) lbl.grid(column=0, row=1) window.mainloop() 每次我们选中一个单选框，并点击按钮，标签框中就会显示其值： ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:7:1","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r添加文本区添加文本区可以用ScrolledText类创建一个文本框： from tkinter import scrolledtext txt = scrolledtext.ScrolledText(window, width=40, height=10) 我们需要指定一个文本区的宽度和高度，否则它会占住整个窗口： from tkinter import * from tkinter import scrolledtext window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") txt = scrolledtext.ScrolledText(window, width=40, height=10) txt.grid(column=0, row=0) window.mainloop() 用以下方法可以在文本区中插入文本： txt.insert(INSERT, \"Text goes here\") 用以下方法可以将文本区中的文本删除： txt.delete(1.0, END) ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:8:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r创建消息框我们可以按如下方式创建一个消息框： from tkinter import messagebox messagebox.showinfo(\"Message title\", \"Message content\") 我们创建一个按钮，当它被点击时显示一个消息框： from tkinter import * from tkinter import messagebox window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") def clicked(): messagebox.showinfo(\"Message title\", \"Message content\") btn = Button(window, text=\"Click here\", command=clicked) btn.grid(column=0, row=0) window.mainloop() ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:9:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r添加 SpinboxSpinbox是输入控件；与Entry类似，但是可以指定输入范围值。 spin = Spinbox(window, from_=0, to=100) 通过from_和to参数指定范围，也可以用width参数指定控件宽度。 from tkinter import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") spin = Spinbox(window, from_=0, to=100, width=5) spin.grid(column=0, row=0) window.mainloop() 也可以指定某些特定的值，而不是整个范围： from tkinter import * window = Tk() window.title(\"First Window\") window.geometry(\"350x200\") spin = Spinbox(window, values=(3,8,11), width=5) spin.grid(column=0, row=0) window.mainloop() 这样，Spinbox控件就只会显示 3 个数字即 3，8，11。 可以用如下方式给Spinbox控件设置默认值： var = IntVar() var.set(36) spin = Spinbox(window, from_=0, to=100, width=5, textvariable=var) 运行代码就可以看到 36 作为Spinbox控件的默认值显示了。 ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:10:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r添加进度条我们可以用Progressbar类创建进度条： from tkinter.ttk import Progressbar bar = Progressbar(window, length=200) 设置一下进度条的值： bar['value'] = 70 改变进度条的颜色可以按如下步骤进行： from tkinter import * from tkinter.ttk import Progressbar from tkinter import ttk window = Tk() window.title(\"First Window\") window.geometry('350x200') style = ttk.Style() style.theme_use('default') style.configure(\"black.Horizontal.TProgressbar\", background='black') bar = Progressbar(window, length=200, style='black.Horizontal.TProgressbar') bar['value'] = 70 bar.grid(column=0, row=0) window.mainloop() ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:11:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r添加文件对话框我们可以按如下方式创建一个文件对话框： from tkinter import filedialog file = filedialog.askopenfilename() 当你选择一个文件并点击打开，file变量将会保存该文件的路径。 如果想一次选择多个文件并打开，我们可以用： files = filedialog.askopenfilenames() 用filetypes参数指定文件对话框的文件类型，只需在元组中指定扩展名即可。 file = filedialog.askopenfilename(filetypes = ((\"Text files\",\"*.txt\"),(\"all files\",\"*.*\"))) askdirectory函数可以让我们请求目录： dir = filedialog.askdirectory() 可以用initialdir参数指定打开的初始目录： from tkinter import * from tkinter import filedialog import os window = Tk() window.title(\"First Window\") window.geometry('350x200') def clicked(): file = filedialog.askopenfilenames(initialdir=os.path.dirname(__file__)) btn = Button(window, text=\"Click Me\", command=clicked) btn.grid(column=0, row=0) window.mainloop() ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:12:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["Tkinter"],"content":"\r参考 https://likegeeks.com/python-gui-examples-tkinter-tutorial/ ","date":"2019-07-30","objectID":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:13:0","tags":["Python","GUI","Tkinter"],"title":"Tkinter简明教程","uri":"/tkinter%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["OpenCV"],"content":"无论我们想要学习如何将面部识别应用于视频流，还是用深度学习构建图像分类器，或者做其他一些有关图像识别的有趣项目，可能都会需要学一些 OpenCV 的知识，本文将做简单介绍。 ","date":"2019-01-07","objectID":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:0","tags":["OpenCV","Python"],"title":"OpenCV简明教程","uri":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["OpenCV"],"content":"\r加载和显示图像 保存上面的图片，打开你最爱的编辑器，输入以下代码： import cv2 image = cv2.imread('demo.jpg') cv2.imshow('Image', image) cv2.waitKey() 第 3 行，使用cv2.imread()导入图像。 第 4 行，使用cv2.imshow()显示图像。窗口会自动调整为图像大小。第一个参数是窗口的名字，然后是我们的图像。 第 5 行，使用cv2.waitKey()等待键盘输入。 运行一下，结果如下所示： ","date":"2019-01-07","objectID":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:1:0","tags":["OpenCV","Python"],"title":"OpenCV简明教程","uri":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["OpenCV"],"content":"\r获取并修改像素值我们可以先查看一下图像的形状， print(image.shape) # (600,400,3) image.shape可以获取图像的形状。返回的是一个包含行数（高），列数（宽），通道数的元组。 可以根据像素的行、列坐标获取其像素值。对于 BGR 图像来说，返回值为 B，G，R 的值。对灰度图像来说，返回值为其灰度值。 B,G,R = image[320,15] print('B={}, G={}, R={}'.format(B,G,R)) # B=150, G=172, R=197 可以用类似的方式修改像素值， image[320,15] = [52,26,16] B,G,R = image[320,15] print('B={}, G={}, R={}'.format(B,G,R)) # B=52, G=26, R=16 ","date":"2019-01-07","objectID":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:2:0","tags":["OpenCV","Python"],"title":"OpenCV简明教程","uri":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["OpenCV"],"content":"\r图像 ROI有时我们需要对一幅图像的感兴趣的区域（Regions of Interest，ROI）进行操作。比如，我们要检测一幅图像中眼睛的位置，我们首先应该在图像中找到脸，再在脸的区域中找眼睛，而不是直接在一幅图像中搜素。ROI 也是通过索引获得，其实就相当于数组切片。 import cv2 image = cv2.imread('demo.jpg') head = image[27:124,159:260] image[200:297,299:400] = head cv2.imshow('New', image) cv2.waitKey() 结果如下： ","date":"2019-01-07","objectID":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:3:0","tags":["OpenCV","Python"],"title":"OpenCV简明教程","uri":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["OpenCV"],"content":"\r图像缩放OpenCV 提供的函数cv2.resize()可以改变图像的尺寸大小。 import cv2 image = cv2.imread('demo.jpg') resized = cv2.resize(image, (200,400)) cv2.imshow('Image', resized) cv2.waitKey() ","date":"2019-01-07","objectID":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:4:0","tags":["OpenCV","Python"],"title":"OpenCV简明教程","uri":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["OpenCV"],"content":"\r旋转图像 对一个图像旋转角度 $\\theta$，需要用到下面形式的旋转矩阵。 OpenCV 允许我们在任意地方进行旋转，于是旋转矩阵的形式应该改为： 其中： 为了构建这个旋转矩阵，OpenCV 提供了一个函数：cv2.getRotationMatrix2D()。 以下便是在不缩放的情况下将图像旋转 90 度。 import cv2 image = cv2.imread('demo1.jpg') rows,cols,depth = image.shape M = cv2.getRotationMatrix2D((rows // 2, cols // 2), 90, 1) dst = cv2.warpAffine(image,M,(cols,rows)) cv2.imshow('Image', dst) cv2.waitKey() 第 5 行，第一个参数为旋转中心，第二个参数为旋转角度，第三个为旋转后的缩放因子。 第 6 行，第三个参数是输出图像的尺寸。 ","date":"2019-01-07","objectID":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:5:0","tags":["OpenCV","Python"],"title":"OpenCV简明教程","uri":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["OpenCV"],"content":"\r图像模糊在许多的图像处理过程中，我们必须模糊图像以减少高频噪声，使算法更容易检测和理解图像的实际内容。在 OpenCV 中模糊图像非常容易，有很多方法可以用。 import cv2 image = cv2.imread('demo1.jpg') blurred = cv2.GaussianBlur(image, (11, 11), 0) cv2.imshow('Blurred', blurred) cv2.waitKey() 第 4 行，我们使用了高斯模糊，用了11 x 11的核。 较大的核会产生更模糊的图像，较小的核将产生没那么的模糊图像。 ","date":"2019-01-07","objectID":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:6:0","tags":["OpenCV","Python"],"title":"OpenCV简明教程","uri":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["OpenCV"],"content":"\r绘图函数本节我们将在导入的图像上画矩形，圆，线以及添加文字。但值得注意的是，这些操作会影响到原始导入的image，为了避免这样，我们可以用image的副本进行操作。 import cv2 image = cv2.imread('demo.jpg') output = image.copy() cv2.rectangle(output, (163, 30), (244, 124), (0, 0, 255), 2) cv2.imshow('Rectangle', output) cv2.waitKey() 第 5 行，设置的参数如下： img：想要绘制图像的那幅图像，这里是output。 pt1：矩形左上角坐标，这里是(163, 30)。 pt2：矩形右下角坐标，这里是(244, 124)。 color：BGR 元组，这里是红色(0,0,255)。 thickness：线条粗细（如果一个闭合图形设置为负数，那么这个图形就会被填充），这里是2。 结果如下： 接下来，我们在猫咪的图像上画一个圆。 import cv2 image = cv2.imread('demo1.jpg') output = image.copy() cv2.circle(output, (32, 25), 20, (255,0,0),-1) cv2.imshow('Circle', output) cv2.waitKey() 要画圆的话，需要指定圆形的圆心坐标和半径大小。 第 5 行，我们指定圆心为(35,25)，半径大小为20。其他参数含义，和画矩形时一样。 画线的话，我们只需要指定起点和终点即可。 import cv2 image = cv2.imread('demo1.jpg') output = image.copy() cv2.line(output, (35,25),(125,69),(255,0,0),5) cv2.imshow('Line', output) cv2.waitKey() 第 5 行，我们指定起点为(35,25)，终点为(125,69)。 结果如下： 我们可能经常需要在图像上添加文字，比如在进行人脸识别的时候，需要在人的脸上绘制出他们的名字。可以使用 OpenCV 的cv2.putText()函数在图像上添加文字。 import cv2 image = cv2.imread('demo.jpg') output = image.copy() cv2.putText(output, 'Sasaki Nozomi', (10, 25), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2) cv2.imshow('Text', output) cv2.waitKey() 第 5~6 行，设置的参数如下： img：想要绘制图像的那幅图像，这里是output。 text：要绘制的文字内容，这里是Sasaki Nozomi。 pt：绘制的位置，这里是(10,25)。 font：字体类型，这里是cv2.FONT_HERSHEY_SIMPLEX。 scale：字体大小乘数，这里是0.7。 color：字体颜色，这里是红色(0,0,255)。 thickness：字体粗细，这里是2。 如下图所示，“Sasaki Nozomi”绘制在图像上， ","date":"2019-01-07","objectID":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:7:0","tags":["OpenCV","Python"],"title":"OpenCV简明教程","uri":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["OpenCV"],"content":"\r参考 https://opencv-python-tutroals.readthedocs.io/en/latest/ https://www.pyimagesearch.com/2018/07/19/opencv-tutorial-a-guide-to-learn-opencv/ ","date":"2019-01-07","objectID":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:8:0","tags":["OpenCV","Python"],"title":"OpenCV简明教程","uri":"/opencv%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"}]